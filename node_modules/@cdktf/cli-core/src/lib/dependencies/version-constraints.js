"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.versionMatchesConstraint = exports.parseConstraint = void 0;
// Copyright (c) HashiCorp, Inc
// SPDX-License-Identifier: MPL-2.0
const semver = __importStar(require("semver"));
const commons_1 = require("@cdktf/commons");
// constraints can be prefixed with "~>", ">", "<", "=", ">=", "<=" or "!="
// no prefix means "="
function parseConstraint(constraint) {
    var _a;
    const cleaned = constraint.trim();
    const operator = (((_a = cleaned.match(/(~>|>=|<=|>|<|=|!=)/)) === null || _a === void 0 ? void 0 : _a[0]) ||
        "=");
    const version = cleaned.replace(operator, "").trim();
    return {
        operator,
        version,
    };
}
exports.parseConstraint = parseConstraint;
function versionMatchesConstraint(version, constraint) {
    // https://www.terraform.io/language/expressions/version-constraints
    // version can contain multiple constraints split by ","
    var _a, _b;
    const constraints = constraint.split(",");
    version = (_b = (_a = semver.coerce(version)) === null || _a === void 0 ? void 0 : _a.version) !== null && _b !== void 0 ? _b : version;
    // each constraint needs to be satisfied
    return constraints.every((c) => {
        var _a, _b;
        const parsed = parseConstraint(c);
        const cleanedParsedVersion = (_b = (_a = semver.coerce(parsed.version)) === null || _a === void 0 ? void 0 : _a.version) !== null && _b !== void 0 ? _b : parsed.version;
        switch (parsed.operator) {
            case "=":
                return version === cleanedParsedVersion;
            case "!=":
                return version !== cleanedParsedVersion;
            case "~>": {
                // allows rightmost version component to increment
                // ~>2.0 which allows 2.1 and 2.1.1 needs special handling as
                // npm semver handles "~" differently for ~2.0 than for ~2 or ~2.1.0
                // So we need to use "^" (e.g. ^2.0) for this case
                // see: https://github.com/npm/node-semver/issues/11
                const allowMinorAndPatchOnly = parsed.version.split(".").length === 2;
                const range = allowMinorAndPatchOnly
                    ? `^${parsed.version}`
                    : `~${parsed.version}`;
                return semver.satisfies(version, range);
            }
            case ">=":
                return semver.gte(version, cleanedParsedVersion);
            case "<=":
                return semver.lte(version, cleanedParsedVersion);
            case ">":
                return semver.gt(version, cleanedParsedVersion);
            case "<":
                return semver.lt(version, cleanedParsedVersion);
            default:
                throw commons_1.Errors.External(`Unknown constraint operator: ${parsed.operator} in version constraint ${constraint}`);
        }
    });
}
exports.versionMatchesConstraint = versionMatchesConstraint;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVyc2lvbi1jb25zdHJhaW50cy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInZlcnNpb24tY29uc3RyYWludHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSwrQkFBK0I7QUFDL0IsbUNBQW1DO0FBQ25DLCtDQUFpQztBQUNqQyw0Q0FBd0M7QUFJeEMsMkVBQTJFO0FBQzNFLHNCQUFzQjtBQUN0QixTQUFnQixlQUFlLENBQUMsVUFBa0I7O0lBSWhELE1BQU0sT0FBTyxHQUFHLFVBQVUsQ0FBQyxJQUFJLEVBQUUsQ0FBQztJQUVsQyxNQUFNLFFBQVEsR0FBRyxDQUFDLENBQUEsTUFBQSxPQUFPLENBQUMsS0FBSyxDQUFDLHFCQUFxQixDQUFDLDBDQUFHLENBQUMsQ0FBQztRQUN6RCxHQUFHLENBQWEsQ0FBQztJQUNuQixNQUFNLE9BQU8sR0FBRyxPQUFPLENBQUMsT0FBTyxDQUFDLFFBQVEsRUFBRSxFQUFFLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQztJQUVyRCxPQUFPO1FBQ0wsUUFBUTtRQUNSLE9BQU87S0FDUixDQUFDO0FBQ0osQ0FBQztBQWRELDBDQWNDO0FBRUQsU0FBZ0Isd0JBQXdCLENBQ3RDLE9BQWUsRUFDZixVQUFrQjtJQUVsQixvRUFBb0U7SUFDcEUsd0RBQXdEOztJQUV4RCxNQUFNLFdBQVcsR0FBRyxVQUFVLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQzFDLE9BQU8sR0FBRyxNQUFBLE1BQUEsTUFBTSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsMENBQUUsT0FBTyxtQ0FBSSxPQUFPLENBQUM7SUFFckQsd0NBQXdDO0lBQ3hDLE9BQU8sV0FBVyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFOztRQUM3QixNQUFNLE1BQU0sR0FBRyxlQUFlLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFFbEMsTUFBTSxvQkFBb0IsR0FDeEIsTUFBQSxNQUFBLE1BQU0sQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQywwQ0FBRSxPQUFPLG1DQUFJLE1BQU0sQ0FBQyxPQUFPLENBQUM7UUFFM0QsUUFBUSxNQUFNLENBQUMsUUFBUSxFQUFFO1lBQ3ZCLEtBQUssR0FBRztnQkFDTixPQUFPLE9BQU8sS0FBSyxvQkFBb0IsQ0FBQztZQUMxQyxLQUFLLElBQUk7Z0JBQ1AsT0FBTyxPQUFPLEtBQUssb0JBQW9CLENBQUM7WUFDMUMsS0FBSyxJQUFJLENBQUMsQ0FBQztnQkFDVCxrREFBa0Q7Z0JBRWxELDZEQUE2RDtnQkFDN0Qsb0VBQW9FO2dCQUNwRSxrREFBa0Q7Z0JBQ2xELG9EQUFvRDtnQkFDcEQsTUFBTSxzQkFBc0IsR0FBRyxNQUFNLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxNQUFNLEtBQUssQ0FBQyxDQUFDO2dCQUV0RSxNQUFNLEtBQUssR0FBRyxzQkFBc0I7b0JBQ2xDLENBQUMsQ0FBQyxJQUFJLE1BQU0sQ0FBQyxPQUFPLEVBQUU7b0JBQ3RCLENBQUMsQ0FBQyxJQUFJLE1BQU0sQ0FBQyxPQUFPLEVBQUUsQ0FBQztnQkFFekIsT0FBTyxNQUFNLENBQUMsU0FBUyxDQUFDLE9BQU8sRUFBRSxLQUFLLENBQUMsQ0FBQzthQUN6QztZQUNELEtBQUssSUFBSTtnQkFDUCxPQUFPLE1BQU0sQ0FBQyxHQUFHLENBQUMsT0FBTyxFQUFFLG9CQUFvQixDQUFDLENBQUM7WUFDbkQsS0FBSyxJQUFJO2dCQUNQLE9BQU8sTUFBTSxDQUFDLEdBQUcsQ0FBQyxPQUFPLEVBQUUsb0JBQW9CLENBQUMsQ0FBQztZQUNuRCxLQUFLLEdBQUc7Z0JBQ04sT0FBTyxNQUFNLENBQUMsRUFBRSxDQUFDLE9BQU8sRUFBRSxvQkFBb0IsQ0FBQyxDQUFDO1lBQ2xELEtBQUssR0FBRztnQkFDTixPQUFPLE1BQU0sQ0FBQyxFQUFFLENBQUMsT0FBTyxFQUFFLG9CQUFvQixDQUFDLENBQUM7WUFDbEQ7Z0JBQ0UsTUFBTSxnQkFBTSxDQUFDLFFBQVEsQ0FDbkIsZ0NBQWdDLE1BQU0sQ0FBQyxRQUFRLDBCQUEwQixVQUFVLEVBQUUsQ0FDdEYsQ0FBQztTQUNMO0lBQ0gsQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDO0FBbkRELDREQW1EQyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgSGFzaGlDb3JwLCBJbmNcbi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBNUEwtMi4wXG5pbXBvcnQgKiBhcyBzZW12ZXIgZnJvbSBcInNlbXZlclwiO1xuaW1wb3J0IHsgRXJyb3JzIH0gZnJvbSBcIkBjZGt0Zi9jb21tb25zXCI7XG5cbnR5cGUgT3BlcmF0b3IgPSBcIj1cIiB8IFwiIT1cIiB8IFwifj5cIiB8IFwiPj1cIiB8IFwiPD1cIiB8IFwiPlwiIHwgXCI8XCI7XG5cbi8vIGNvbnN0cmFpbnRzIGNhbiBiZSBwcmVmaXhlZCB3aXRoIFwifj5cIiwgXCI+XCIsIFwiPFwiLCBcIj1cIiwgXCI+PVwiLCBcIjw9XCIgb3IgXCIhPVwiXG4vLyBubyBwcmVmaXggbWVhbnMgXCI9XCJcbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUNvbnN0cmFpbnQoY29uc3RyYWludDogc3RyaW5nKToge1xuICBvcGVyYXRvcjogT3BlcmF0b3I7XG4gIHZlcnNpb246IHN0cmluZztcbn0ge1xuICBjb25zdCBjbGVhbmVkID0gY29uc3RyYWludC50cmltKCk7XG5cbiAgY29uc3Qgb3BlcmF0b3IgPSAoY2xlYW5lZC5tYXRjaCgvKH4+fD49fDw9fD58PHw9fCE9KS8pPy5bMF0gfHxcbiAgICBcIj1cIikgYXMgT3BlcmF0b3I7XG4gIGNvbnN0IHZlcnNpb24gPSBjbGVhbmVkLnJlcGxhY2Uob3BlcmF0b3IsIFwiXCIpLnRyaW0oKTtcblxuICByZXR1cm4ge1xuICAgIG9wZXJhdG9yLFxuICAgIHZlcnNpb24sXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB2ZXJzaW9uTWF0Y2hlc0NvbnN0cmFpbnQoXG4gIHZlcnNpb246IHN0cmluZyxcbiAgY29uc3RyYWludDogc3RyaW5nXG4pOiBib29sZWFuIHtcbiAgLy8gaHR0cHM6Ly93d3cudGVycmFmb3JtLmlvL2xhbmd1YWdlL2V4cHJlc3Npb25zL3ZlcnNpb24tY29uc3RyYWludHNcbiAgLy8gdmVyc2lvbiBjYW4gY29udGFpbiBtdWx0aXBsZSBjb25zdHJhaW50cyBzcGxpdCBieSBcIixcIlxuXG4gIGNvbnN0IGNvbnN0cmFpbnRzID0gY29uc3RyYWludC5zcGxpdChcIixcIik7XG4gIHZlcnNpb24gPSBzZW12ZXIuY29lcmNlKHZlcnNpb24pPy52ZXJzaW9uID8/IHZlcnNpb247XG5cbiAgLy8gZWFjaCBjb25zdHJhaW50IG5lZWRzIHRvIGJlIHNhdGlzZmllZFxuICByZXR1cm4gY29uc3RyYWludHMuZXZlcnkoKGMpID0+IHtcbiAgICBjb25zdCBwYXJzZWQgPSBwYXJzZUNvbnN0cmFpbnQoYyk7XG5cbiAgICBjb25zdCBjbGVhbmVkUGFyc2VkVmVyc2lvbiA9XG4gICAgICBzZW12ZXIuY29lcmNlKHBhcnNlZC52ZXJzaW9uKT8udmVyc2lvbiA/PyBwYXJzZWQudmVyc2lvbjtcblxuICAgIHN3aXRjaCAocGFyc2VkLm9wZXJhdG9yKSB7XG4gICAgICBjYXNlIFwiPVwiOlxuICAgICAgICByZXR1cm4gdmVyc2lvbiA9PT0gY2xlYW5lZFBhcnNlZFZlcnNpb247XG4gICAgICBjYXNlIFwiIT1cIjpcbiAgICAgICAgcmV0dXJuIHZlcnNpb24gIT09IGNsZWFuZWRQYXJzZWRWZXJzaW9uO1xuICAgICAgY2FzZSBcIn4+XCI6IHtcbiAgICAgICAgLy8gYWxsb3dzIHJpZ2h0bW9zdCB2ZXJzaW9uIGNvbXBvbmVudCB0byBpbmNyZW1lbnRcblxuICAgICAgICAvLyB+PjIuMCB3aGljaCBhbGxvd3MgMi4xIGFuZCAyLjEuMSBuZWVkcyBzcGVjaWFsIGhhbmRsaW5nIGFzXG4gICAgICAgIC8vIG5wbSBzZW12ZXIgaGFuZGxlcyBcIn5cIiBkaWZmZXJlbnRseSBmb3IgfjIuMCB0aGFuIGZvciB+MiBvciB+Mi4xLjBcbiAgICAgICAgLy8gU28gd2UgbmVlZCB0byB1c2UgXCJeXCIgKGUuZy4gXjIuMCkgZm9yIHRoaXMgY2FzZVxuICAgICAgICAvLyBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9ucG0vbm9kZS1zZW12ZXIvaXNzdWVzLzExXG4gICAgICAgIGNvbnN0IGFsbG93TWlub3JBbmRQYXRjaE9ubHkgPSBwYXJzZWQudmVyc2lvbi5zcGxpdChcIi5cIikubGVuZ3RoID09PSAyO1xuXG4gICAgICAgIGNvbnN0IHJhbmdlID0gYWxsb3dNaW5vckFuZFBhdGNoT25seVxuICAgICAgICAgID8gYF4ke3BhcnNlZC52ZXJzaW9ufWBcbiAgICAgICAgICA6IGB+JHtwYXJzZWQudmVyc2lvbn1gO1xuXG4gICAgICAgIHJldHVybiBzZW12ZXIuc2F0aXNmaWVzKHZlcnNpb24sIHJhbmdlKTtcbiAgICAgIH1cbiAgICAgIGNhc2UgXCI+PVwiOlxuICAgICAgICByZXR1cm4gc2VtdmVyLmd0ZSh2ZXJzaW9uLCBjbGVhbmVkUGFyc2VkVmVyc2lvbik7XG4gICAgICBjYXNlIFwiPD1cIjpcbiAgICAgICAgcmV0dXJuIHNlbXZlci5sdGUodmVyc2lvbiwgY2xlYW5lZFBhcnNlZFZlcnNpb24pO1xuICAgICAgY2FzZSBcIj5cIjpcbiAgICAgICAgcmV0dXJuIHNlbXZlci5ndCh2ZXJzaW9uLCBjbGVhbmVkUGFyc2VkVmVyc2lvbik7XG4gICAgICBjYXNlIFwiPFwiOlxuICAgICAgICByZXR1cm4gc2VtdmVyLmx0KHZlcnNpb24sIGNsZWFuZWRQYXJzZWRWZXJzaW9uKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IEVycm9ycy5FeHRlcm5hbChcbiAgICAgICAgICBgVW5rbm93biBjb25zdHJhaW50IG9wZXJhdG9yOiAke3BhcnNlZC5vcGVyYXRvcn0gaW4gdmVyc2lvbiBjb25zdHJhaW50ICR7Y29uc3RyYWludH1gXG4gICAgICAgICk7XG4gICAgfVxuICB9KTtcbn1cbiJdfQ==