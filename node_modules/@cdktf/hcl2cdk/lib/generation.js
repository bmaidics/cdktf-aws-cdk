"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateConfigType = exports.buildImports = exports.providerConstructImports = exports.wrapCodeInConstructor = exports.addImportForCodeContainer = exports.gen = exports.moduleImports = exports.providerImports = exports.constructsImport = exports.cdktfImport = exports.provider = exports.modules = exports.local = exports.variable = exports.variableTypeToAst = exports.output = exports.resource = exports.backendToExpression = exports.valueToTs = exports.attributeNameToCdktfName = void 0;
// Copyright (c) HashiCorp, Inc
// SPDX-License-Identifier: MPL-2.0
const generator_1 = __importDefault(require("@babel/generator"));
const template_1 = __importDefault(require("@babel/template"));
const t = __importStar(require("@babel/types"));
const prettier_1 = __importDefault(require("prettier"));
const utils_1 = require("./utils");
const expressions_1 = require("./expressions");
const references_1 = require("./references");
const provider_generator_1 = require("@cdktf/provider-generator");
const terraformSchema_1 = require("./terraformSchema");
const commons_1 = require("@cdktf/commons");
const hcl2json_1 = require("@cdktf/hcl2json");
const dynamic_blocks_1 = require("./dynamic-blocks");
const variables_1 = require("./variables");
const util_1 = require("cdktf/lib/util");
const partialCode_1 = require("./partialCode");
function getReference(graph, id) {
    utils_1.logger.debug(`Finding reference for ${id}`);
    const neighbors = graph.outNeighbors(id);
    if (neighbors.length > 0) {
        utils_1.logger.debug(`Found neighbors ${neighbors} for ${id}`);
        const edge = graph.directedEdge(id, neighbors[0]);
        if (edge) {
            utils_1.logger.debug(`Found first edge ${edge} for ${id}`);
            utils_1.logger.debug(`Returning reference ${graph.getEdgeAttribute(edge, "ref")}`);
            return graph.getEdgeAttribute(edge, "ref");
        }
        else {
            utils_1.logger.debug(`Found no edge for ${id}`);
            return undefined;
        }
    }
    else {
        return undefined;
    }
}
function attributeNameToCdktfName(name) {
    return (0, provider_generator_1.escapeAttributeName)((0, utils_1.camelCase)(name));
}
exports.attributeNameToCdktfName = attributeNameToCdktfName;
const valueToTs = async (scope, item, path, isModule = false) => {
    switch (typeof item) {
        case "string":
            if ((await (0, references_1.findUsedReferences)(scope.nodeIds, item)).some((ref) => path.startsWith(ref.referencee.id))) {
                return t.stringLiteral(item);
            }
            return await (0, expressions_1.convertTerraformExpressionToTs)(scope, `"${item}"`, () => (0, terraformSchema_1.getDesiredType)(scope, path));
        case "boolean":
            return await (0, expressions_1.convertTerraformExpressionToTs)(scope, `${item}`, () => (0, terraformSchema_1.getDesiredType)(scope, path));
        case "number":
            return await (0, expressions_1.convertTerraformExpressionToTs)(scope, `${item}`, () => (0, terraformSchema_1.getDesiredType)(scope, path));
        case "object":
            if (item === undefined || item === null) {
                return t.nullLiteral();
            }
            // For iterators and dynamic blocks we put the correct TS expression in the config ahead of time
            if (t.isExpression(item)) {
                return item;
            }
            const attributeType = (0, terraformSchema_1.getTypeAtPath)(scope.providerSchema, path);
            function shouldRemoveArrayBasedOnType(attributeType) {
                if (!attributeType) {
                    return false; // The default assumption is we need the array
                }
                // maps and object don't need to be wrapped in an array
                if (Array.isArray(attributeType) &&
                    (attributeType[0] === "map" || attributeType[0] === "object")) {
                    return true;
                }
                // If it's a block type with max_items = 1 we don't need to wrap it in an array
                if (typeof attributeType === "object" &&
                    "max_items" in attributeType &&
                    attributeType.max_items === 1) {
                    return true;
                }
                return false;
            }
            const unwrappedItem = Array.isArray(item) &&
                (shouldRemoveArrayBasedOnType(attributeType) ||
                    path.endsWith("lifecycle") ||
                    path.endsWith("connection"))
                ? item[0]
                : item;
            if (Array.isArray(unwrappedItem)) {
                return t.arrayExpression(await Promise.all(unwrappedItem.map((i) => (0, exports.valueToTs)(scope, i, `${path}.[]`))));
            }
            return t.objectExpression((await Promise.all(Object.entries(unwrappedItem).map(async ([key, value]) => {
                if (value === undefined) {
                    return undefined;
                }
                if (key === "dynamic") {
                    const { for_each, ...others } = value;
                    const dynamicRef = Object.keys(others)[0];
                    return t.objectProperty(t.identifier(scope.withinOverrideExpression
                        ? dynamicRef
                        : (0, provider_generator_1.escapeAttributeName)((0, utils_1.camelCase)(dynamicRef))), t.arrayExpression());
                }
                const itemPath = `${path}.${key}`;
                const itemAttributeType = (0, terraformSchema_1.getTypeAtPath)(scope.providerSchema, itemPath);
                const typeMetadata = (0, terraformSchema_1.getTypeAtPath)(scope.providerSchema, itemPath);
                const isSingleItemBlock = typeMetadata &&
                    typeof typeMetadata === "object" &&
                    typeMetadata.hasOwnProperty("max_items")
                    ? typeMetadata.max_items === 1
                    : false;
                const shouldBeArray = typeof value === "object" &&
                    !Array.isArray(value) &&
                    !t.isExpression(value) &&
                    !isSingleItemBlock &&
                    // Map type attributes must not be wrapped in arrays
                    !(0, terraformSchema_1.isMapAttribute)(itemAttributeType) &&
                    key !== "tags" &&
                    key !== "forEach" &&
                    key !== "lifecycle";
                const keepKeyName = !isModule &&
                    key !== "depends_on" &&
                    !path.includes("lifecycle") &&
                    (key === "for_each" ||
                        !typeMetadata ||
                        (0, terraformSchema_1.isMapAttribute)(attributeType)) &&
                    !(path.startsWith("var.") && path.includes("validation"));
                return t.objectProperty(t.stringLiteral(keepKeyName ? key : attributeNameToCdktfName(key)), shouldBeArray
                    ? t.arrayExpression([await (0, exports.valueToTs)(scope, value, itemPath)])
                    : await (0, exports.valueToTs)(scope, value, itemPath));
            }))).filter((expr) => expr !== undefined));
    }
    throw new Error("Unsupported type " + item);
};
exports.valueToTs = valueToTs;
async function backendToExpression(scope, tf) {
    return (await Promise.all(Object.entries(tf || {}).map(async ([type, [config]]) => {
        const backendIdentifier = (0, utils_1.pascalCase)(`${type}Backend`);
        scope.importables.push({
            constructName: backendIdentifier,
            provider: "cdktf",
        });
        return t.expressionStatement(t.newExpression(t.identifier(backendIdentifier), [
            t.thisExpression(),
            t.objectExpression((await Promise.all(Object.entries(config).map(async ([property, value]) => t.objectProperty(t.identifier((0, utils_1.camelCase)(property)), await (0, exports.valueToTs)(scope, value, "path-for-backends-can-be-ignored"))))).reduce((carry, item) => [...carry, item], [])),
        ]));
    }))).reduce((carry, item) => [...carry, item], []);
}
exports.backendToExpression = backendToExpression;
function addOverrideExpression(variable, path, value, explanatoryComment) {
    const ast = t.expressionStatement(t.callExpression(t.memberExpression(t.identifier(variable), t.identifier("addOverride")), [t.stringLiteral(path), value]));
    if (explanatoryComment) {
        t.addComment(ast, "leading", explanatoryComment);
    }
    return ast;
}
function addOverrideLogicalIdExpression(variable, logicalId) {
    const ast = t.expressionStatement(t.callExpression(t.memberExpression(t.identifier(variable), t.identifier("overrideLogicalId")), [t.stringLiteral(logicalId)]));
    t.addComment(ast, "leading", "This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.");
    return ast;
}
function getRemoteStateType(item) {
    const backendRecord = item.find((val) => val.backend);
    if (backendRecord) {
        const backend = backendRecord.backend;
        switch (backend) {
            case "remote":
                return "";
            case "etcdv3":
                return "_etcd_v3";
            default:
                return `_${backend}`;
        }
    }
    else {
        return "";
    }
}
function resourceType(provider, name, item) {
    switch (provider) {
        case "data.terraform":
            return `cdktf.data_terraform_${name.join("_")}${getRemoteStateType(item)}`;
        case "null":
            return `NullProvider.${name.join("_")}`;
        default:
            return `${provider}.${name.join("_")}`;
    }
}
function mapConfigPerResourceType(resource, item) {
    // Backends have a slightly different API
    if (resource.startsWith("cdktf.data_terraform_")) {
        return item.config;
    }
    return item;
}
const loopComment = `In most cases loops should be handled in the programming language context and 
not inside of the Terraform context. If you are looping over something external, e.g. a variable or a file input
you should consider using a for loop. If you are looping over something only known to Terraform, e.g. a result of a data source
you need to keep this like it is.`;
async function resource(scope, type, key, id, item, graph) {
    const [provider, ...name] = type.split("_");
    const resource = resourceType(provider, name, item);
    if (!provider) {
        throw new Error(`Could not parse resource type '${type}'`);
    }
    let expressions = [];
    const varName = (0, variables_1.variableName)(scope, resource, key);
    const { for_each, count, provisioner, ...config } = item[0];
    const mappedConfig = mapConfigPerResourceType(resource, config);
    let forEachIteratorName;
    if (for_each) {
        forEachIteratorName = (0, variables_1.variableName)(scope, resource, `${key}_for_each_iterator`);
        const referenceAst = await (0, expressions_1.convertTerraformExpressionToTs)(scope, `"${for_each}"`, () => ["list", "dynamic"]);
        scope.importables.push({
            provider: "cdktf",
            constructName: "TerraformIterator",
        });
        const iterator = t.variableDeclaration("const", [
            t.variableDeclarator(t.identifier(forEachIteratorName), t.callExpression(t.memberExpression(t.identifier("TerraformIterator"), t.identifier("fromList")), [referenceAst])),
        ]);
        t.addComment(iterator, "leading", loopComment);
        expressions.push(iterator);
        mappedConfig.forEach = t.identifier(forEachIteratorName);
    }
    let countIteratorName;
    if (count) {
        countIteratorName = (0, variables_1.variableName)(scope, resource, `${key}_count`);
        const referenceAst = await (0, expressions_1.convertTerraformExpressionToTs)(scope, `"${count}"`, () => "number");
        scope.importables.push({
            provider: "cdktf",
            constructName: "TerraformCount",
        });
        const iterator = t.variableDeclaration("const", [
            t.variableDeclarator(t.identifier(countIteratorName), t.callExpression(t.memberExpression(t.identifier("TerraformCount"), t.identifier("of")), [referenceAst])),
        ]);
        t.addComment(iterator, "leading", loopComment);
        mappedConfig.count = t.identifier(countIteratorName);
        expressions.push(iterator);
    }
    const dynBlocks = (0, dynamic_blocks_1.extractDynamicBlocks)(mappedConfig);
    const nestedDynamicBlocks = dynBlocks.filter((block) => (0, dynamic_blocks_1.isNestedDynamicBlock)(dynBlocks, block));
    const dynamicBlocksUsingOverrides = dynBlocks.filter((block) => 
    // nested blocks need overrides
    nestedDynamicBlocks.includes(block) ||
        // blocks that contain nested blocks need them as well
        nestedDynamicBlocks.some((nestedBlock) => nestedBlock.path.startsWith(block.path)));
    // all others can be handled by the CDKTF runtime
    const dynamicBlocksUsingRuntime = dynBlocks.filter((block) => !dynamicBlocksUsingOverrides.includes(block));
    for (const [i, block] of dynamicBlocksUsingRuntime.entries()) {
        const dynamicBlockIteratorName = (0, variables_1.variableName)(scope, resource, `${key}_dynamic_iterator_${i}`);
        const referenceAst = await (0, expressions_1.convertTerraformExpressionToTs)(scope, `"${block.for_each}"`, () => ["list", "dynamic"]);
        scope.importables.push({
            provider: "cdktf",
            constructName: "TerraformIterator",
        });
        const iterator = t.variableDeclaration("const", [
            t.variableDeclarator(t.identifier(dynamicBlockIteratorName), t.callExpression(t.memberExpression(t.identifier("TerraformIterator"), t.identifier("fromList")), [referenceAst])),
        ]);
        t.addComment(iterator, "leading", loopComment);
        expressions.push(iterator);
        const dynamicCallExpression = t.callExpression(t.memberExpression(t.identifier(dynamicBlockIteratorName), t.identifier("dynamic")), [
            await (0, exports.valueToTs)({
                ...scope,
                scopedVariables: {
                    [block.scopedVar]: dynamicBlockIteratorName,
                },
            }, (0, partialCode_1.fillWithConfigAccessors)(scope, Array.isArray(block.content) ? block.content[0] : block.content, block.path.replace(block.scopedVar, "")), block.path.replace(block.scopedVar, ""), false),
        ]);
        const parts = block.path
            .replace(`dynamic.${block.scopedVar}`, "")
            .split(".")
            .filter((p) => p.length > 0);
        const parent = parts.reduce((acc, part) => {
            if (Array.isArray(acc) && !Number.isNaN(parseInt(part, 10))) {
                return acc[parseInt(part, 10)];
            }
            else {
                return acc[part];
            }
        }, mappedConfig);
        parent[block.scopedVar] = dynamicCallExpression;
        delete parent.dynamic;
    }
    const overrideReference = dynamicBlocksUsingOverrides.length
        ? {
            start: 0,
            end: 0,
            referencee: {
                id: `${type}.${key}`,
                full: `${type}.${key}`,
            },
        }
        : undefined;
    if (provisioner) {
        mappedConfig.provisioners = await Promise.all(Object.entries(provisioner).flatMap(([type, p]) => p.map((pp) => (0, exports.valueToTs)(scope, { type, ...pp }, "path-for-provisioners-can-be-ignored"))));
    }
    expressions = expressions.concat(await asExpression({ ...scope, forEachIteratorName, countIteratorName }, resource, key, mappedConfig, false, false, getReference(graph, id) || overrideReference));
    // Check for dynamic blocks
    expressions = expressions.concat(await Promise.all(dynamicBlocksUsingOverrides.map(async ({ path, for_each, content }) => {
        // We need to let the expression conversion know all available
        // dynamic block names, so we don't replace them. The "dynamic-block"
        // scoped variable indicates to the expression conversion to use the
        // key name instead of an iterator
        const scopedVariablesInPath = Object.fromEntries(path
            .substring(1) // The path starts with a dot that results in an empty split
            .split(".")
            .filter((p) => !["dynamic", "content"].includes(p) && isNaN(parseInt(p)))
            .map((p) => [p, "dynamic-block"]));
        return addOverrideExpression(varName, path.substring(1), // The path starts with a dot that we don't want
        await (0, exports.valueToTs)({
            ...scope,
            withinOverrideExpression: true,
            scopedVariables: scopedVariablesInPath,
        }, {
            for_each,
            content,
        }, "path-for-dynamic-blocks-can-be-ignored"), loopComment);
    })));
    return expressions;
}
exports.resource = resource;
async function asExpression(scope, type, name, config, isModuleImport, isProvider, reference) {
    const { providers, ...otherOptions } = config;
    const constructId = (0, utils_1.uniqueId)(scope.constructs, name);
    const overrideId = !isProvider && constructId !== name;
    const completeObject = (0, partialCode_1.fillWithConfigAccessors)(scope, otherOptions, type);
    const expression = t.newExpression((0, variables_1.constructAst)(scope, type, isModuleImport), [
        t.thisExpression(),
        t.stringLiteral(constructId),
        await (0, exports.valueToTs)(scope, {
            ...completeObject,
            providers: providers && Object.keys(providers).length
                ? Object.entries(providers).map(([key, value]) => ({
                    moduleAlias: key,
                    provider: value,
                }))
                : undefined,
        }, `${type}`, isModuleImport),
    ]);
    const statements = [];
    const varName = reference
        ? (0, variables_1.referenceToVariableName)(scope, reference)
        : (0, variables_1.variableName)(scope, type, name);
    if (reference || overrideId) {
        statements.push(t.variableDeclaration("const", [
            t.variableDeclarator(t.identifier(varName), expression),
        ]));
    }
    else {
        statements.push(t.expressionStatement(expression));
    }
    if (overrideId) {
        statements.push(addOverrideLogicalIdExpression(varName, name));
    }
    return statements;
}
async function output(scope, key, _id, item, _graph) {
    const [{ value, description, sensitive }] = item;
    return asExpression(scope, "cdktf.TerraformOutput", key, {
        value,
        description,
        sensitive,
    }, false, false, undefined);
}
exports.output = output;
async function variableTypeToAst(scope, type) {
    const addVariableTypeToImports = () => scope.importables.push({
        constructName: "VariableType",
        provider: "cdktf",
    });
    function parsedTypeToAst(type) {
        if (hcl2json_1.TFExpressionSyntaxTree.isScopeTraversalExpression(type)) {
            addVariableTypeToImports();
            switch (type.meta.value) {
                case "string":
                    return t.identifier("VariableType.STRING");
                case "number":
                    return t.identifier("VariableType.NUMBER");
                case "bool":
                    return t.identifier("VariableType.BOOL");
                case "any":
                default:
                    return t.identifier("VariableType.ANY");
            }
        }
        if (hcl2json_1.TFExpressionSyntaxTree.isFunctionCallExpression(type)) {
            addVariableTypeToImports();
            switch (type.meta.name) {
                case "list":
                case "set":
                case "map":
                case "tuple":
                case "object":
                    return t.callExpression(t.identifier(`VariableType.${type.meta.name}`), type.children.map((child) => parsedTypeToAst(child)));
            }
        }
        if (hcl2json_1.TFExpressionSyntaxTree.isObjectExpression(type)) {
            return t.objectExpression(Object.entries(type.meta.items).map(([key, value]) => t.objectProperty(t.stringLiteral(key), 
            // This does not deal with complex types nested within objects
            // If such a type is found it will result in an Any type
            // e.g. { foo: list(string) } will result in { foo: any }
            parsedTypeToAst({
                type: "scopeTraversal",
                meta: { value },
            }))));
        }
        addVariableTypeToImports();
        return t.identifier("VariableType.ANY");
    }
    return parsedTypeToAst(await (0, expressions_1.expressionAst)(type));
}
exports.variableTypeToAst = variableTypeToAst;
async function variable(scope, key, id, item, graph) {
    const [{ type, ...props }] = item;
    if (!getReference(graph, id)) {
        return [];
    }
    return asExpression(scope, id, key, { ...props, type: type ? await variableTypeToAst(scope, type) : undefined }, false, false, getReference(graph, id));
}
exports.variable = variable;
async function local(scope, key, id, item, graph) {
    utils_1.logger.debug(`Initializing local resource ${key} with id ${id}`);
    if (!getReference(graph, id)) {
        utils_1.logger.debug(`No reference found for ${key}`);
        return [];
    }
    return [
        t.variableDeclaration("const", [
            t.variableDeclarator(t.identifier((0, variables_1.variableName)(scope, "local", key)), await (0, exports.valueToTs)(scope, item, "path-for-local-blocks-can-be-ignored")),
        ]),
    ];
}
exports.local = local;
async function modules(scope, key, id, item, graph) {
    const [{ source, version, ...props }] = item;
    const moduleConstraint = new provider_generator_1.TerraformModuleConstraint(source);
    return asExpression(scope, moduleConstraint.className, key, props, true, false, getReference(graph, id));
}
exports.modules = modules;
async function provider(scope, key, id, item, graph) {
    const { version, ...props } = item;
    const importKey = key === "null" ? "NullProvider" : key;
    return asExpression(scope, `${importKey}.${(0, utils_1.pascalCase)(key)}Provider`, key, props, false, true, getReference(graph, id));
}
exports.provider = provider;
exports.cdktfImport = (0, template_1.default)(`import * as cdktf from "cdktf"`)();
exports.constructsImport = (0, template_1.default)(`import * as constructs from "constructs"`)();
const providerImports = (providers) => providers.map((providerName) => {
    const parts = providerName.split("/");
    const name = parts.length > 1 ? parts[1] : parts[0];
    const importName = name === "null" ? "NullProvider" : name;
    return (0, template_1.default)(`import * as ${importName} from "./.gen/providers/${name.replace("./", "")}"`)();
});
exports.providerImports = providerImports;
const moduleImports = (modules) => {
    const uniqueModules = new Set();
    Object.values(modules || {}).map(([module]) => uniqueModules.add(module.source));
    const imports = [];
    uniqueModules.forEach((m) => {
        const moduleConstraint = new provider_generator_1.TerraformModuleConstraint(m);
        imports.push(template_1.default.ast(`import * as ${moduleConstraint.className} from "./.gen/modules/${moduleConstraint.fileName}"`));
    });
    return imports;
};
exports.moduleImports = moduleImports;
async function gen(statements) {
    utils_1.logger.debug(`Generating code for ${JSON.stringify(statements, null, 2)}`);
    const code = prettier_1.default.format((0, generator_1.default)(t.program(statements)).code, {
        parser: "babel",
    });
    utils_1.logger.debug(`Generated code:\n${code}`);
    return code;
}
exports.gen = gen;
function addImportForCodeContainer(scope, codeContainer) {
    switch (codeContainer) {
        case "constructs.Construct":
            scope.importables.push({
                provider: "constructs",
                constructName: "Construct",
            });
            break;
        case "cdktf.TerraformStack":
            scope.importables.push({
                provider: "cdktf",
                constructName: "TerraformStack",
            });
            break;
        default:
            throw commons_1.Errors.Internal("Unsupported code container: " + codeContainer);
    }
}
exports.addImportForCodeContainer = addImportForCodeContainer;
function wrapCodeInConstructor(codeContainer, code, className, configTypeName) {
    let baseContainerClass;
    switch (codeContainer) {
        case "constructs.Construct":
            baseContainerClass = t.identifier("Construct");
            break;
        case "cdktf.TerraformStack":
            baseContainerClass = t.identifier("TerraformStack");
            break;
        default:
            throw commons_1.Errors.Internal("Unsupported code container: " + codeContainer);
    }
    if (configTypeName) {
        return template_1.default.statement(`
  class %%className%% extends %%base%% {
    constructor(scope: Construct, name: string, config: ${configTypeName}) {
      super(scope, name);
      %%code%%
    }
  }
`, { syntacticPlaceholders: true, plugins: ["typescript"] })({
            code,
            base: baseContainerClass,
            className: t.identifier(className),
        });
    }
    return template_1.default.statement(`
  class %%className%% extends %%base%% {
    constructor(scope: Construct, name: string) {
      super(scope, name);
      %%code%%
    }
  }
`, { syntacticPlaceholders: true, plugins: ["typescript"] })({
        code,
        base: baseContainerClass,
        className: t.identifier(className),
    });
}
exports.wrapCodeInConstructor = wrapCodeInConstructor;
const providerConstructImports = (importable) => {
    let provider = importable[0].provider;
    let namespace = importable[0].namespace;
    const names = importable.map((i) => i.constructName);
    if (provider === "cdktf" || provider === "constructs") {
        return (0, template_1.default)(`import { ${names.join(", ")} } from "${provider}"`)();
    }
    if (namespace) {
        namespace = (0, util_1.snakeCase)(namespace).replace(/_/g, "-");
    }
    // Special cases to undo provider names that we override
    if (provider === "NullProvider") {
        provider = "null";
    }
    return (0, template_1.default)(`import { ${names.join(", ")} } from "./.gen/providers/${provider}/${namespace}"`)();
};
exports.providerConstructImports = providerConstructImports;
function buildImports(importables) {
    const groupedImportables = importables.reduce((acc, importable) => {
        const ns = importable.namespace || "";
        // Doing some hacky ordering of the imports to make them look a bit nicer
        const prefix = importable.provider === "constructs"
            ? "1"
            : importable.provider === "cdktf"
                ? "2"
                : "3";
        const groupName = `${prefix}.${importable.provider}.${ns}`;
        const fullName = `${importable.provider}.${ns}.${importable.constructName}`;
        if (acc[groupName]) {
            const existsAlready = acc[groupName].some((importable) => `${importable.provider}.${ns}.${importable.constructName}` ===
                fullName);
            if (existsAlready) {
                return acc;
            }
            acc[groupName].push(importable);
            acc[groupName].sort();
        }
        else {
            acc[groupName] = [importable];
        }
        return acc;
    }, {});
    let commentAdded = false;
    const constructImports = Object.keys(groupedImportables)
        .sort()
        .map((groupName) => {
        const importStatement = (0, exports.providerConstructImports)(groupedImportables[groupName]);
        if (groupName.startsWith("3.") && !commentAdded) {
            commentAdded = true;
            t.addComment(importStatement, "leading", `\n* Provider bindings are generated by running \`cdktf get\`.
* See https://cdk.tf/provider-generation for more details.\n`);
        }
        return importStatement;
    });
    return constructImports;
}
exports.buildImports = buildImports;
function generateConfigType(name, config) {
    return t.tsInterfaceDeclaration(t.identifier(name), undefined, undefined, t.tsInterfaceBody(Object.entries(config).map(([key, _value]) => t.tsPropertySignature(t.identifier(key), t.tSTypeAnnotation(t.tsAnyKeyword()) // TODO: Try to make this better than any
    ))));
}
exports.generateConfigType = generateConfigType;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2VuZXJhdGlvbi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImdlbmVyYXRpb24udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSwrQkFBK0I7QUFDL0IsbUNBQW1DO0FBQ25DLGlFQUF3QztBQUN4QywrREFBdUM7QUFDdkMsZ0RBQWtDO0FBRWxDLHdEQUFnQztBQVNoQyxtQ0FBa0U7QUFTbEUsK0NBQThFO0FBRTlFLDZDQUFrRDtBQUNsRCxrRUFHbUM7QUFDbkMsdURBSTJCO0FBQzNCLDRDQUEwRTtBQUMxRSw4Q0FBZ0U7QUFDaEUscURBQThFO0FBQzlFLDJDQUlxQjtBQUNyQix5Q0FBMkM7QUFDM0MsK0NBQXdEO0FBRXhELFNBQVMsWUFBWSxDQUFDLEtBQW9CLEVBQUUsRUFBVTtJQUNwRCxjQUFNLENBQUMsS0FBSyxDQUFDLHlCQUF5QixFQUFFLEVBQUUsQ0FBQyxDQUFDO0lBQzVDLE1BQU0sU0FBUyxHQUFHLEtBQUssQ0FBQyxZQUFZLENBQUMsRUFBRSxDQUFDLENBQUM7SUFFekMsSUFBSSxTQUFTLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtRQUN4QixjQUFNLENBQUMsS0FBSyxDQUFDLG1CQUFtQixTQUFTLFFBQVEsRUFBRSxFQUFFLENBQUMsQ0FBQztRQUN2RCxNQUFNLElBQUksR0FBRyxLQUFLLENBQUMsWUFBWSxDQUFDLEVBQUUsRUFBRSxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUVsRCxJQUFJLElBQUksRUFBRTtZQUNSLGNBQU0sQ0FBQyxLQUFLLENBQUMsb0JBQW9CLElBQUksUUFBUSxFQUFFLEVBQUUsQ0FBQyxDQUFDO1lBQ25ELGNBQU0sQ0FBQyxLQUFLLENBQ1YsdUJBQXVCLEtBQUssQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLEVBQUUsS0FBSyxDQUFDLEVBQUUsQ0FDN0QsQ0FBQztZQUNGLE9BQU8sS0FBSyxDQUFDLGdCQUFnQixDQUFDLElBQUksRUFBRSxL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QUFFLENBQUMsQ0FBQyx5Q0FBeUM7S0FDL0UsQ0FDRixDQUNGLENBQ0YsQ0FBQztBQUNKLENBQUM7QUFqQkQsZ0RBaUJDIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSBIYXNoaUNvcnAsIEluY1xuLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1QTC0yLjBcbmltcG9ydCBnZW5lcmF0ZSBmcm9tIFwiQGJhYmVsL2dlbmVyYXRvclwiO1xuaW1wb3J0IHRlbXBsYXRlIGZyb20gXCJAYmFiZWwvdGVtcGxhdGVcIjtcbmltcG9ydCAqIGFzIHQgZnJvbSBcIkBiYWJlbC90eXBlc1wiO1xuaW1wb3J0IHsgRGlyZWN0ZWRHcmFwaCB9IGZyb20gXCJncmFwaG9sb2d5XCI7XG5pbXBvcnQgcHJldHRpZXIgZnJvbSBcInByZXR0aWVyXCI7XG5cbmltcG9ydCB7XG4gIFRlcnJhZm9ybVJlc291cmNlQmxvY2ssXG4gIFByb2dyYW1TY29wZSxcbiAgUmVzb3VyY2VTY29wZSxcbiAgSW1wb3J0YWJsZUNvbnN0cnVjdCxcbiAgQXR0cmlidXRlUGF0aCxcbn0gZnJvbSBcIi4vdHlwZXNcIjtcbmltcG9ydCB7IGNhbWVsQ2FzZSwgbG9nZ2VyLCBwYXNjYWxDYXNlLCB1bmlxdWVJZCB9IGZyb20gXCIuL3V0aWxzXCI7XG5pbXBvcnQge1xuICBSZXNvdXJjZSxcbiAgVGVycmFmb3JtQ29uZmlnLFxuICBNb2R1bGUsXG4gIFByb3ZpZGVyLFxuICBWYXJpYWJsZSxcbiAgT3V0cHV0LFxufSBmcm9tIFwiLi9zY2hlbWFcIjtcbmltcG9ydCB7IGNvbnZlcnRUZXJyYWZvcm1FeHByZXNzaW9uVG9UcywgZXhwcmVzc2lvbkFzdCB9IGZyb20gXCIuL2V4cHJlc3Npb25zXCI7XG5pbXBvcnQgeyBSZWZlcmVuY2UgfSBmcm9tIFwiLi90eXBlc1wiO1xuaW1wb3J0IHsgZmluZFVzZWRSZWZlcmVuY2VzIH0gZnJvbSBcIi4vcmVmZXJlbmNlc1wiO1xuaW1wb3J0IHtcbiAgVGVycmFmb3JtTW9kdWxlQ29uc3RyYWludCxcbiAgZXNjYXBlQXR0cmlidXRlTmFtZSxcbn0gZnJvbSBcIkBjZGt0Zi9wcm92aWRlci1nZW5lcmF0b3JcIjtcbmltcG9ydCB7XG4gIGdldFR5cGVBdFBhdGgsXG4gIGlzTWFwQXR0cmlidXRlLFxuICBnZXREZXNpcmVkVHlwZSxcbn0gZnJvbSBcIi4vdGVycmFmb3JtU2NoZW1hXCI7XG5pbXBvcnQgeyBFcnJvcnMsIEF0dHJpYnV0ZVR5cGUsIEJsb2NrVHlwZSwgU2NoZW1hIH0gZnJvbSBcIkBjZGt0Zi9jb21tb25zXCI7XG5pbXBvcnQgeyBURkV4cHJlc3Npb25TeW50YXhUcmVlIGFzIHRleCB9IGZyb20gXCJAY2RrdGYvaGNsMmpzb25cIjtcbmltcG9ydCB7IGV4dHJhY3REeW5hbWljQmxvY2tzLCBpc05lc3RlZER5bmFtaWNCbG9jayB9IGZyb20gXCIuL2R5bmFtaWMtYmxvY2tzXCI7XG5pbXBvcnQge1xuICBjb25zdHJ1Y3RBc3QsXG4gIHJlZmVyZW5jZVRvVmFyaWFibGVOYW1lLFxuICB2YXJpYWJsZU5hbWUsXG59IGZyb20gXCIuL3ZhcmlhYmxlc1wiO1xuaW1wb3J0IHsgc25ha2VDYXNlIH0gZnJvbSBcImNka3RmL2xpYi91dGlsXCI7XG5pbXBvcnQgeyBmaWxsV2l0aENvbmZpZ0FjY2Vzc29ycyB9IGZyb20gXCIuL3BhcnRpYWxDb2RlXCI7XG5cbmZ1bmN0aW9uIGdldFJlZmVyZW5jZShncmFwaDogRGlyZWN0ZWRHcmFwaCwgaWQ6IHN0cmluZykge1xuICBsb2dnZXIuZGVidWcoYEZpbmRpbmcgcmVmZXJlbmNlIGZvciAke2lkfWApO1xuICBjb25zdCBuZWlnaGJvcnMgPSBncmFwaC5vdXROZWlnaGJvcnMoaWQpO1xuXG4gIGlmIChuZWlnaGJvcnMubGVuZ3RoID4gMCkge1xuICAgIGxvZ2dlci5kZWJ1ZyhgRm91bmQgbmVpZ2hib3JzICR7bmVpZ2hib3JzfSBmb3IgJHtpZH1gKTtcbiAgICBjb25zdCBlZGdlID0gZ3JhcGguZGlyZWN0ZWRFZGdlKGlkLCBuZWlnaGJvcnNbMF0pO1xuXG4gICAgaWYgKGVkZ2UpIHtcbiAgICAgIGxvZ2dlci5kZWJ1ZyhgRm91bmQgZmlyc3QgZWRnZSAke2VkZ2V9IGZvciAke2lkfWApO1xuICAgICAgbG9nZ2VyLmRlYnVnKFxuICAgICAgICBgUmV0dXJuaW5nIHJlZmVyZW5jZSAke2dyYXBoLmdldEVkZ2VBdHRyaWJ1dGUoZWRnZSwgXCJyZWZcIil9YFxuICAgICAgKTtcbiAgICAgIHJldHVybiBncmFwaC5nZXRFZGdlQXR0cmlidXRlKGVkZ2UsIFwicmVmXCIpIGFzIFJlZmVyZW5jZTtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9nZ2VyLmRlYnVnKGBGb3VuZCBubyBlZGdlIGZvciAke2lkfWApO1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYXR0cmlidXRlTmFtZVRvQ2RrdGZOYW1lKG5hbWU6IHN0cmluZykge1xuICByZXR1cm4gZXNjYXBlQXR0cmlidXRlTmFtZShjYW1lbENhc2UobmFtZSkpO1xufVxuXG5leHBvcnQgY29uc3QgdmFsdWVUb1RzID0gYXN5bmMgKFxuICBzY29wZTogUmVzb3VyY2VTY29wZSxcbiAgaXRlbTogVGVycmFmb3JtUmVzb3VyY2VCbG9jayxcbiAgcGF0aDogc3RyaW5nLFxuICBpc01vZHVsZSA9IGZhbHNlXG4pOiBQcm9taXNlPHQuRXhwcmVzc2lvbj4gPT4ge1xuICBzd2l0Y2ggKHR5cGVvZiBpdGVtKSB7XG4gICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgaWYgKFxuICAgICAgICAoYXdhaXQgZmluZFVzZWRSZWZlcmVuY2VzKHNjb3BlLm5vZGVJZHMsIGl0ZW0pKS5zb21lKChyZWYpID0+XG4gICAgICAgICAgcGF0aC5zdGFydHNXaXRoKHJlZi5yZWZlcmVuY2VlLmlkKVxuICAgICAgICApXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIHQuc3RyaW5nTGl0ZXJhbChpdGVtKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGF3YWl0IGNvbnZlcnRUZXJyYWZvcm1FeHByZXNzaW9uVG9UcyhzY29wZSwgYFwiJHtpdGVtfVwiYCwgKCkgPT5cbiAgICAgICAgZ2V0RGVzaXJlZFR5cGUoc2NvcGUsIHBhdGgpXG4gICAgICApO1xuXG4gICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgIHJldHVybiBhd2FpdCBjb252ZXJ0VGVycmFmb3JtRXhwcmVzc2lvblRvVHMoc2NvcGUsIGAke2l0ZW19YCwgKCkgPT5cbiAgICAgICAgZ2V0RGVzaXJlZFR5cGUoc2NvcGUsIHBhdGgpXG4gICAgICApO1xuICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgIHJldHVybiBhd2FpdCBjb252ZXJ0VGVycmFmb3JtRXhwcmVzc2lvblRvVHMoc2NvcGUsIGAke2l0ZW19YCwgKCkgPT5cbiAgICAgICAgZ2V0RGVzaXJlZFR5cGUoc2NvcGUsIHBhdGgpXG4gICAgICApO1xuICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgIGlmIChpdGVtID09PSB1bmRlZmluZWQgfHwgaXRlbSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdC5udWxsTGl0ZXJhbCgpO1xuICAgICAgfVxuXG4gICAgICAvLyBGb3IgaXRlcmF0b3JzIGFuZCBkeW5hbWljIGJsb2NrcyB3ZSBwdXQgdGhlIGNvcnJlY3QgVFMgZXhwcmVzc2lvbiBpbiB0aGUgY29uZmlnIGFoZWFkIG9mIHRpbWVcbiAgICAgIGlmICh0LmlzRXhwcmVzc2lvbihpdGVtKSkge1xuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgYXR0cmlidXRlVHlwZSA9IGdldFR5cGVBdFBhdGgoc2NvcGUucHJvdmlkZXJTY2hlbWEsIHBhdGgpO1xuXG4gICAgICBmdW5jdGlvbiBzaG91bGRSZW1vdmVBcnJheUJhc2VkT25UeXBlKFxuICAgICAgICBhdHRyaWJ1dGVUeXBlOiBTY2hlbWEgfCBBdHRyaWJ1dGVUeXBlIHwgQmxvY2tUeXBlIHwgbnVsbFxuICAgICAgKTogYm9vbGVhbiB7XG4gICAgICAgIGlmICghYXR0cmlidXRlVHlwZSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gVGhlIGRlZmF1bHQgYXNzdW1wdGlvbiBpcyB3ZSBuZWVkIHRoZSBhcnJheVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gbWFwcyBhbmQgb2JqZWN0IGRvbid0IG5lZWQgdG8gYmUgd3JhcHBlZCBpbiBhbiBhcnJheVxuICAgICAgICBpZiAoXG4gICAgICAgICAgQXJyYXkuaXNBcnJheShhdHRyaWJ1dGVUeXBlKSAmJlxuICAgICAgICAgIChhdHRyaWJ1dGVUeXBlWzBdID09PSBcIm1hcFwiIHx8IGF0dHJpYnV0ZVR5cGVbMF0gPT09IFwib2JqZWN0XCIpXG4gICAgICAgICkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgaXQncyBhIGJsb2NrIHR5cGUgd2l0aCBtYXhfaXRlbXMgPSAxIHdlIGRvbid0IG5lZWQgdG8gd3JhcCBpdCBpbiBhbiBhcnJheVxuICAgICAgICBpZiAoXG4gICAgICAgICAgdHlwZW9mIGF0dHJpYnV0ZVR5cGUgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICBcIm1heF9pdGVtc1wiIGluIGF0dHJpYnV0ZVR5cGUgJiZcbiAgICAgICAgICBhdHRyaWJ1dGVUeXBlLm1heF9pdGVtcyA9PT0gMVxuICAgICAgICApIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdW53cmFwcGVkSXRlbSA9XG4gICAgICAgIEFycmF5LmlzQXJyYXkoaXRlbSkgJiZcbiAgICAgICAgKHNob3VsZFJlbW92ZUFycmF5QmFzZWRPblR5cGUoYXR0cmlidXRlVHlwZSkgfHxcbiAgICAgICAgICBwYXRoLmVuZHNXaXRoKFwibGlmZWN5Y2xlXCIpIHx8XG4gICAgICAgICAgcGF0aC5lbmRzV2l0aChcImNvbm5lY3Rpb25cIikpXG4gICAgICAgICAgPyBpdGVtWzBdXG4gICAgICAgICAgOiBpdGVtO1xuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh1bndyYXBwZWRJdGVtKSkge1xuICAgICAgICByZXR1cm4gdC5hcnJheUV4cHJlc3Npb24oXG4gICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgICAgICB1bndyYXBwZWRJdGVtLm1hcCgoaSkgPT4gdmFsdWVUb1RzKHNjb3BlLCBpLCBgJHtwYXRofS5bXWApKVxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHQub2JqZWN0RXhwcmVzc2lvbihcbiAgICAgICAgKFxuICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICAgICAgT2JqZWN0LmVudHJpZXModW53cmFwcGVkSXRlbSkubWFwKGFzeW5jIChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKGtleSA9PT0gXCJkeW5hbWljXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGZvcl9lYWNoLCAuLi5vdGhlcnMgfSA9IHZhbHVlIGFzIGFueTtcbiAgICAgICAgICAgICAgICBjb25zdCBkeW5hbWljUmVmID0gT2JqZWN0LmtleXMob3RoZXJzKVswXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdC5vYmplY3RQcm9wZXJ0eShcbiAgICAgICAgICAgICAgICAgIHQuaWRlbnRpZmllcihcbiAgICAgICAgICAgICAgICAgICAgc2NvcGUud2l0aGluT3ZlcnJpZGVFeHByZXNzaW9uXG4gICAgICAgICAgICAgICAgICAgICAgPyBkeW5hbWljUmVmXG4gICAgICAgICAgICAgICAgICAgICAgOiBlc2NhcGVBdHRyaWJ1dGVOYW1lKGNhbWVsQ2FzZShkeW5hbWljUmVmKSlcbiAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICB0LmFycmF5RXhwcmVzc2lvbigpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGNvbnN0IGl0ZW1QYXRoID0gYCR7cGF0aH0uJHtrZXl9YDtcbiAgICAgICAgICAgICAgY29uc3QgaXRlbUF0dHJpYnV0ZVR5cGUgPSBnZXRUeXBlQXRQYXRoKFxuICAgICAgICAgICAgICAgIHNjb3BlLnByb3ZpZGVyU2NoZW1hLFxuICAgICAgICAgICAgICAgIGl0ZW1QYXRoXG4gICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgY29uc3QgdHlwZU1ldGFkYXRhID0gZ2V0VHlwZUF0UGF0aChcbiAgICAgICAgICAgICAgICBzY29wZS5wcm92aWRlclNjaGVtYSxcbiAgICAgICAgICAgICAgICBpdGVtUGF0aFxuICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgIGNvbnN0IGlzU2luZ2xlSXRlbUJsb2NrID1cbiAgICAgICAgICAgICAgICB0eXBlTWV0YWRhdGEgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgdHlwZU1ldGFkYXRhID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICAgICAgdHlwZU1ldGFkYXRhLmhhc093blByb3BlcnR5KFwibWF4X2l0ZW1zXCIpXG4gICAgICAgICAgICAgICAgICA/ICh0eXBlTWV0YWRhdGEgYXMgYW55KS5tYXhfaXRlbXMgPT09IDFcbiAgICAgICAgICAgICAgICAgIDogZmFsc2U7XG5cbiAgICAgICAgICAgICAgY29uc3Qgc2hvdWxkQmVBcnJheSA9XG4gICAgICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICAgICAgIUFycmF5LmlzQXJyYXkodmFsdWUpICYmXG4gICAgICAgICAgICAgICAgIXQuaXNFeHByZXNzaW9uKHZhbHVlKSAmJlxuICAgICAgICAgICAgICAgICFpc1NpbmdsZUl0ZW1CbG9jayAmJlxuICAgICAgICAgICAgICAgIC8vIE1hcCB0eXBlIGF0dHJpYnV0ZXMgbXVzdCBub3QgYmUgd3JhcHBlZCBpbiBhcnJheXNcbiAgICAgICAgICAgICAgICAhaXNNYXBBdHRyaWJ1dGUoaXRlbUF0dHJpYnV0ZVR5cGUpICYmXG4gICAgICAgICAgICAgICAga2V5ICE9PSBcInRhZ3NcIiAmJlxuICAgICAgICAgICAgICAgIGtleSAhPT0gXCJmb3JFYWNoXCIgJiZcbiAgICAgICAgICAgICAgICBrZXkgIT09IFwibGlmZWN5Y2xlXCI7XG5cbiAgICAgICAgICAgICAgY29uc3Qga2VlcEtleU5hbWU6IGJvb2xlYW4gPVxuICAgICAgICAgICAgICAgICFpc01vZHVsZSAmJlxuICAgICAgICAgICAgICAgIGtleSAhPT0gXCJkZXBlbmRzX29uXCIgJiZcbiAgICAgICAgICAgICAgICAhcGF0aC5pbmNsdWRlcyhcImxpZmVjeWNsZVwiKSAmJlxuICAgICAgICAgICAgICAgIChrZXkgPT09IFwiZm9yX2VhY2hcIiB8fFxuICAgICAgICAgICAgICAgICAgIXR5cGVNZXRhZGF0YSB8fFxuICAgICAgICAgICAgICAgICAgaXNNYXBBdHRyaWJ1dGUoYXR0cmlidXRlVHlwZSkpICYmXG4gICAgICAgICAgICAgICAgIShwYXRoLnN0YXJ0c1dpdGgoXCJ2YXIuXCIpICYmIHBhdGguaW5jbHVkZXMoXCJ2YWxpZGF0aW9uXCIpKTtcblxuICAgICAgICAgICAgICByZXR1cm4gdC5vYmplY3RQcm9wZXJ0eShcbiAgICAgICAgICAgICAgICB0LnN0cmluZ0xpdGVyYWwoXG4gICAgICAgICAgICAgICAgICBrZWVwS2V5TmFtZSA/IGtleSA6IGF0dHJpYnV0ZU5hbWVUb0Nka3RmTmFtZShrZXkpXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBzaG91bGRCZUFycmF5XG4gICAgICAgICAgICAgICAgICA/IHQuYXJyYXlFeHByZXNzaW9uKFthd2FpdCB2YWx1ZVRvVHMoc2NvcGUsIHZhbHVlLCBpdGVtUGF0aCldKVxuICAgICAgICAgICAgICAgICAgOiBhd2FpdCB2YWx1ZVRvVHMoc2NvcGUsIHZhbHVlLCBpdGVtUGF0aClcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKVxuICAgICAgICApLmZpbHRlcigoZXhwcikgPT4gZXhwciAhPT0gdW5kZWZpbmVkKSBhcyB0Lk9iamVjdFByb3BlcnR5W11cbiAgICAgICk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgdHlwZSBcIiArIGl0ZW0pO1xufTtcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGJhY2tlbmRUb0V4cHJlc3Npb24oXG4gIHNjb3BlOiBQcm9ncmFtU2NvcGUsXG4gIHRmOiBUZXJyYWZvcm1Db25maWdbXCJiYWNrZW5kXCJdXG4pOiBQcm9taXNlPHQuU3RhdGVtZW50W10+IHtcbiAgcmV0dXJuIChcbiAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgIE9iamVjdC5lbnRyaWVzKHRmIHx8IHt9KS5tYXAoYXN5bmMgKFt0eXBlLCBbY29uZmlnXV0pID0+IHtcbiAgICAgICAgY29uc3QgYmFja2VuZElkZW50aWZpZXIgPSBwYXNjYWxDYXNlKGAke3R5cGV9QmFja2VuZGApO1xuICAgICAgICBzY29wZS5pbXBvcnRhYmxlcy5wdXNoKHtcbiAgICAgICAgICBjb25zdHJ1Y3ROYW1lOiBiYWNrZW5kSWRlbnRpZmllcixcbiAgICAgICAgICBwcm92aWRlcjogXCJjZGt0ZlwiLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHQuZXhwcmVzc2lvblN0YXRlbWVudChcbiAgICAgICAgICB0Lm5ld0V4cHJlc3Npb24odC5pZGVudGlmaWVyKGJhY2tlbmRJZGVudGlmaWVyKSwgW1xuICAgICAgICAgICAgdC50aGlzRXhwcmVzc2lvbigpLFxuICAgICAgICAgICAgdC5vYmplY3RFeHByZXNzaW9uKFxuICAgICAgICAgICAgICAoXG4gICAgICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgICAgICAgICAgICBPYmplY3QuZW50cmllcyhjb25maWcpLm1hcChhc3luYyAoW3Byb3BlcnR5LCB2YWx1ZV0pID0+XG4gICAgICAgICAgICAgICAgICAgIHQub2JqZWN0UHJvcGVydHkoXG4gICAgICAgICAgICAgICAgICAgICAgdC5pZGVudGlmaWVyKGNhbWVsQ2FzZShwcm9wZXJ0eSkpLFxuICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHZhbHVlVG9UcyhcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBcInBhdGgtZm9yLWJhY2tlbmRzLWNhbi1iZS1pZ25vcmVkXCJcbiAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICkucmVkdWNlKFxuICAgICAgICAgICAgICAgIChjYXJyeSwgaXRlbSkgPT4gWy4uLmNhcnJ5LCBpdGVtXSxcbiAgICAgICAgICAgICAgICBbXSBhcyB0Lk9iamVjdFByb3BlcnR5W11cbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICBdKVxuICAgICAgICApO1xuICAgICAgfSlcbiAgICApXG4gICkucmVkdWNlKChjYXJyeSwgaXRlbSkgPT4gWy4uLmNhcnJ5LCBpdGVtXSwgW10gYXMgdC5TdGF0ZW1lbnRbXSk7XG59XG5cbmZ1bmN0aW9uIGFkZE92ZXJyaWRlRXhwcmVzc2lvbihcbiAgdmFyaWFibGU6IHN0cmluZyxcbiAgcGF0aDogc3RyaW5nLFxuICB2YWx1ZTogdC5FeHByZXNzaW9uLFxuICBleHBsYW5hdG9yeUNvbW1lbnQ/OiBzdHJpbmdcbikge1xuICBjb25zdCBhc3QgPSB0LmV4cHJlc3Npb25TdGF0ZW1lbnQoXG4gICAgdC5jYWxsRXhwcmVzc2lvbihcbiAgICAgIHQubWVtYmVyRXhwcmVzc2lvbih0LmlkZW50aWZpZXIodmFyaWFibGUpLCB0LmlkZW50aWZpZXIoXCJhZGRPdmVycmlkZVwiKSksXG4gICAgICBbdC5zdHJpbmdMaXRlcmFsKHBhdGgpLCB2YWx1ZV1cbiAgICApXG4gICk7XG5cbiAgaWYgKGV4cGxhbmF0b3J5Q29tbWVudCkge1xuICAgIHQuYWRkQ29tbWVudChhc3QsIFwibGVhZGluZ1wiLCBleHBsYW5hdG9yeUNvbW1lbnQpO1xuICB9XG5cbiAgcmV0dXJuIGFzdDtcbn1cblxuZnVuY3Rpb24gYWRkT3ZlcnJpZGVMb2dpY2FsSWRFeHByZXNzaW9uKHZhcmlhYmxlOiBzdHJpbmcsIGxvZ2ljYWxJZDogc3RyaW5nKSB7XG4gIGNvbnN0IGFzdCA9IHQuZXhwcmVzc2lvblN0YXRlbWVudChcbiAgICB0LmNhbGxFeHByZXNzaW9uKFxuICAgICAgdC5tZW1iZXJFeHByZXNzaW9uKFxuICAgICAgICB0LmlkZW50aWZpZXIodmFyaWFibGUpLFxuICAgICAgICB0LmlkZW50aWZpZXIoXCJvdmVycmlkZUxvZ2ljYWxJZFwiKVxuICAgICAgKSxcbiAgICAgIFt0LnN0cmluZ0xpdGVyYWwobG9naWNhbElkKV1cbiAgICApXG4gICk7XG5cbiAgdC5hZGRDb21tZW50KFxuICAgIGFzdCxcbiAgICBcImxlYWRpbmdcIixcbiAgICBcIlRoaXMgYWxsb3dzIHRoZSBUZXJyYWZvcm0gcmVzb3VyY2UgbmFtZSB0byBtYXRjaCB0aGUgb3JpZ2luYWwgbmFtZS4gWW91IGNhbiByZW1vdmUgdGhlIGNhbGwgaWYgeW91IGRvbid0IG5lZWQgdGhlbSB0byBtYXRjaC5cIlxuICApO1xuXG4gIHJldHVybiBhc3Q7XG59XG5cbmZ1bmN0aW9uIGdldFJlbW90ZVN0YXRlVHlwZShpdGVtOiBSZXNvdXJjZSkge1xuICBjb25zdCBiYWNrZW5kUmVjb3JkID0gaXRlbS5maW5kKCh2YWwpID0+IHZhbC5iYWNrZW5kKTtcbiAgaWYgKGJhY2tlbmRSZWNvcmQpIHtcbiAgICBjb25zdCBiYWNrZW5kID0gYmFja2VuZFJlY29yZC5iYWNrZW5kO1xuICAgIHN3aXRjaCAoYmFja2VuZCkge1xuICAgICAgY2FzZSBcInJlbW90ZVwiOlxuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIGNhc2UgXCJldGNkdjNcIjpcbiAgICAgICAgcmV0dXJuIFwiX2V0Y2RfdjNcIjtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBgXyR7YmFja2VuZH1gO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gXCJcIjtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXNvdXJjZVR5cGUocHJvdmlkZXI6IHN0cmluZywgbmFtZTogc3RyaW5nW10sIGl0ZW06IFJlc291cmNlKSB7XG4gIHN3aXRjaCAocHJvdmlkZXIpIHtcbiAgICBjYXNlIFwiZGF0YS50ZXJyYWZvcm1cIjpcbiAgICAgIHJldHVybiBgY2RrdGYuZGF0YV90ZXJyYWZvcm1fJHtuYW1lLmpvaW4oXCJfXCIpfSR7Z2V0UmVtb3RlU3RhdGVUeXBlKFxuICAgICAgICBpdGVtXG4gICAgICApfWA7XG4gICAgY2FzZSBcIm51bGxcIjpcbiAgICAgIHJldHVybiBgTnVsbFByb3ZpZGVyLiR7bmFtZS5qb2luKFwiX1wiKX1gO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gYCR7cHJvdmlkZXJ9LiR7bmFtZS5qb2luKFwiX1wiKX1gO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hcENvbmZpZ1BlclJlc291cmNlVHlwZShyZXNvdXJjZTogc3RyaW5nLCBpdGVtOiBSZXNvdXJjZVswXSkge1xuICAvLyBCYWNrZW5kcyBoYXZlIGEgc2xpZ2h0bHkgZGlmZmVyZW50IEFQSVxuICBpZiAocmVzb3VyY2Uuc3RhcnRzV2l0aChcImNka3RmLmRhdGFfdGVycmFmb3JtX1wiKSkge1xuICAgIHJldHVybiBpdGVtLmNvbmZpZztcbiAgfVxuICByZXR1cm4gaXRlbTtcbn1cblxuY29uc3QgbG9vcENvbW1lbnQgPSBgSW4gbW9zdCBjYXNlcyBsb29wcyBzaG91bGQgYmUgaGFuZGxlZCBpbiB0aGUgcHJvZ3JhbW1pbmcgbGFuZ3VhZ2UgY29udGV4dCBhbmQgXG5ub3QgaW5zaWRlIG9mIHRoZSBUZXJyYWZvcm0gY29udGV4dC4gSWYgeW91IGFyZSBsb29waW5nIG92ZXIgc29tZXRoaW5nIGV4dGVybmFsLCBlLmcuIGEgdmFyaWFibGUgb3IgYSBmaWxlIGlucHV0XG55b3Ugc2hvdWxkIGNvbnNpZGVyIHVzaW5nIGEgZm9yIGxvb3AuIElmIHlvdSBhcmUgbG9vcGluZyBvdmVyIHNvbWV0aGluZyBvbmx5IGtub3duIHRvIFRlcnJhZm9ybSwgZS5nLiBhIHJlc3VsdCBvZiBhIGRhdGEgc291cmNlXG55b3UgbmVlZCB0byBrZWVwIHRoaXMgbGlrZSBpdCBpcy5gO1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlc291cmNlKFxuICBzY29wZTogUHJvZ3JhbVNjb3BlLFxuICB0eXBlOiBzdHJpbmcsXG4gIGtleTogc3RyaW5nLFxuICBpZDogc3RyaW5nLFxuICBpdGVtOiBSZXNvdXJjZSxcbiAgZ3JhcGg6IERpcmVjdGVkR3JhcGhcbik6IFByb21pc2U8dC5TdGF0ZW1lbnRbXT4ge1xuICBjb25zdCBbcHJvdmlkZXIsIC4uLm5hbWVdID0gdHlwZS5zcGxpdChcIl9cIik7XG4gIGNvbnN0IHJlc291cmNlID0gcmVzb3VyY2VUeXBlKHByb3ZpZGVyLCBuYW1lLCBpdGVtKTtcblxuICBpZiAoIXByb3ZpZGVyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgcGFyc2UgcmVzb3VyY2UgdHlwZSAnJHt0eXBlfSdgKTtcbiAgfVxuICBsZXQgZXhwcmVzc2lvbnM6IHQuU3RhdGVtZW50W10gPSBbXTtcbiAgY29uc3QgdmFyTmFtZSA9IHZhcmlhYmxlTmFtZShzY29wZSwgcmVzb3VyY2UsIGtleSk7XG4gIGNvbnN0IHsgZm9yX2VhY2gsIGNvdW50LCBwcm92aXNpb25lciwgLi4uY29uZmlnIH0gPSBpdGVtWzBdO1xuICBjb25zdCBtYXBwZWRDb25maWcgPSBtYXBDb25maWdQZXJSZXNvdXJjZVR5cGUocmVzb3VyY2UsIGNvbmZpZyk7XG5cbiAgbGV0IGZvckVhY2hJdGVyYXRvck5hbWU6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgaWYgKGZvcl9lYWNoKSB7XG4gICAgZm9yRWFjaEl0ZXJhdG9yTmFtZSA9IHZhcmlhYmxlTmFtZShcbiAgICAgIHNjb3BlLFxuICAgICAgcmVzb3VyY2UsXG4gICAgICBgJHtrZXl9X2Zvcl9lYWNoX2l0ZXJhdG9yYFxuICAgICk7XG4gICAgY29uc3QgcmVmZXJlbmNlQXN0ID0gYXdhaXQgY29udmVydFRlcnJhZm9ybUV4cHJlc3Npb25Ub1RzKFxuICAgICAgc2NvcGUsXG4gICAgICBgXCIke2Zvcl9lYWNofVwiYCxcbiAgICAgICgpID0+IFtcImxpc3RcIiwgXCJkeW5hbWljXCJdXG4gICAgKTtcblxuICAgIHNjb3BlLmltcG9ydGFibGVzLnB1c2goe1xuICAgICAgcHJvdmlkZXI6IFwiY2RrdGZcIixcbiAgICAgIGNvbnN0cnVjdE5hbWU6IFwiVGVycmFmb3JtSXRlcmF0b3JcIixcbiAgICB9KTtcblxuICAgIGNvbnN0IGl0ZXJhdG9yID0gdC52YXJpYWJsZURlY2xhcmF0aW9uKFwiY29uc3RcIiwgW1xuICAgICAgdC52YXJpYWJsZURlY2xhcmF0b3IoXG4gICAgICAgIHQuaWRlbnRpZmllcihmb3JFYWNoSXRlcmF0b3JOYW1lKSxcbiAgICAgICAgdC5jYWxsRXhwcmVzc2lvbihcbiAgICAgICAgICB0Lm1lbWJlckV4cHJlc3Npb24oXG4gICAgICAgICAgICB0LmlkZW50aWZpZXIoXCJUZXJyYWZvcm1JdGVyYXRvclwiKSxcbiAgICAgICAgICAgIHQuaWRlbnRpZmllcihcImZyb21MaXN0XCIpXG4gICAgICAgICAgKSxcblxuICAgICAgICAgIFtyZWZlcmVuY2VBc3RdXG4gICAgICAgIClcbiAgICAgICksXG4gICAgXSk7XG4gICAgdC5hZGRDb21tZW50KGl0ZXJhdG9yLCBcImxlYWRpbmdcIiwgbG9vcENvbW1lbnQpO1xuICAgIGV4cHJlc3Npb25zLnB1c2goaXRlcmF0b3IpO1xuXG4gICAgbWFwcGVkQ29uZmlnLmZvckVhY2ggPSB0LmlkZW50aWZpZXIoZm9yRWFjaEl0ZXJhdG9yTmFtZSk7XG4gIH1cblxuICBsZXQgY291bnRJdGVyYXRvck5hbWU6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgaWYgKGNvdW50KSB7XG4gICAgY291bnRJdGVyYXRvck5hbWUgPSB2YXJpYWJsZU5hbWUoc2NvcGUsIHJlc291cmNlLCBgJHtrZXl9X2NvdW50YCk7XG4gICAgY29uc3QgcmVmZXJlbmNlQXN0ID0gYXdhaXQgY29udmVydFRlcnJhZm9ybUV4cHJlc3Npb25Ub1RzKFxuICAgICAgc2NvcGUsXG4gICAgICBgXCIke2NvdW50fVwiYCxcbiAgICAgICgpID0+IFwibnVtYmVyXCJcbiAgICApO1xuXG4gICAgc2NvcGUuaW1wb3J0YWJsZXMucHVzaCh7XG4gICAgICBwcm92aWRlcjogXCJjZGt0ZlwiLFxuICAgICAgY29uc3RydWN0TmFtZTogXCJUZXJyYWZvcm1Db3VudFwiLFxuICAgIH0pO1xuXG4gICAgY29uc3QgaXRlcmF0b3IgPSB0LnZhcmlhYmxlRGVjbGFyYXRpb24oXCJjb25zdFwiLCBbXG4gICAgICB0LnZhcmlhYmxlRGVjbGFyYXRvcihcbiAgICAgICAgdC5pZGVudGlmaWVyKGNvdW50SXRlcmF0b3JOYW1lKSxcbiAgICAgICAgdC5jYWxsRXhwcmVzc2lvbihcbiAgICAgICAgICB0Lm1lbWJlckV4cHJlc3Npb24oXG4gICAgICAgICAgICB0LmlkZW50aWZpZXIoXCJUZXJyYWZvcm1Db3VudFwiKSxcbiAgICAgICAgICAgIHQuaWRlbnRpZmllcihcIm9mXCIpXG4gICAgICAgICAgKSxcbiAgICAgICAgICBbcmVmZXJlbmNlQXN0XVxuICAgICAgICApXG4gICAgICApLFxuICAgIF0pO1xuICAgIHQuYWRkQ29tbWVudChpdGVyYXRvciwgXCJsZWFkaW5nXCIsIGxvb3BDb21tZW50KTtcbiAgICBtYXBwZWRDb25maWcuY291bnQgPSB0LmlkZW50aWZpZXIoY291bnRJdGVyYXRvck5hbWUpO1xuICAgIGV4cHJlc3Npb25zLnB1c2goaXRlcmF0b3IpO1xuICB9XG5cbiAgY29uc3QgZHluQmxvY2tzID0gZXh0cmFjdER5bmFtaWNCbG9ja3MobWFwcGVkQ29uZmlnKTtcbiAgY29uc3QgbmVzdGVkRHluYW1pY0Jsb2NrcyA9IGR5bkJsb2Nrcy5maWx0ZXIoKGJsb2NrKSA9PlxuICAgIGlzTmVzdGVkRHluYW1pY0Jsb2NrKGR5bkJsb2NrcywgYmxvY2spXG4gICk7XG4gIGNvbnN0IGR5bmFtaWNCbG9ja3NVc2luZ092ZXJyaWRlcyA9IGR5bkJsb2Nrcy5maWx0ZXIoXG4gICAgKGJsb2NrKSA9PlxuICAgICAgLy8gbmVzdGVkIGJsb2NrcyBuZWVkIG92ZXJyaWRlc1xuICAgICAgbmVzdGVkRHluYW1pY0Jsb2Nrcy5pbmNsdWRlcyhibG9jaykgfHxcbiAgICAgIC8vIGJsb2NrcyB0aGF0IGNvbnRhaW4gbmVzdGVkIGJsb2NrcyBuZWVkIHRoZW0gYXMgd2VsbFxuICAgICAgbmVzdGVkRHluYW1pY0Jsb2Nrcy5zb21lKChuZXN0ZWRCbG9jaykgPT5cbiAgICAgICAgbmVzdGVkQmxvY2sucGF0aC5zdGFydHNXaXRoKGJsb2NrLnBhdGgpXG4gICAgICApXG4gICk7XG4gIC8vIGFsbCBvdGhlcnMgY2FuIGJlIGhhbmRsZWQgYnkgdGhlIENES1RGIHJ1bnRpbWVcbiAgY29uc3QgZHluYW1pY0Jsb2Nrc1VzaW5nUnVudGltZSA9IGR5bkJsb2Nrcy5maWx0ZXIoXG4gICAgKGJsb2NrKSA9PiAhZHluYW1pY0Jsb2Nrc1VzaW5nT3ZlcnJpZGVzLmluY2x1ZGVzKGJsb2NrKVxuICApO1xuXG4gIGZvciAoY29uc3QgW2ksIGJsb2NrXSBvZiBkeW5hbWljQmxvY2tzVXNpbmdSdW50aW1lLmVudHJpZXMoKSkge1xuICAgIGNvbnN0IGR5bmFtaWNCbG9ja0l0ZXJhdG9yTmFtZSA9IHZhcmlhYmxlTmFtZShcbiAgICAgIHNjb3BlLFxuICAgICAgcmVzb3VyY2UsXG4gICAgICBgJHtrZXl9X2R5bmFtaWNfaXRlcmF0b3JfJHtpfWBcbiAgICApO1xuXG4gICAgY29uc3QgcmVmZXJlbmNlQXN0ID0gYXdhaXQgY29udmVydFRlcnJhZm9ybUV4cHJlc3Npb25Ub1RzKFxuICAgICAgc2NvcGUsXG4gICAgICBgXCIke2Jsb2NrLmZvcl9lYWNofVwiYCxcbiAgICAgICgpID0+IFtcImxpc3RcIiwgXCJkeW5hbWljXCJdXG4gICAgKTtcblxuICAgIHNjb3BlLmltcG9ydGFibGVzLnB1c2goe1xuICAgICAgcHJvdmlkZXI6IFwiY2RrdGZcIixcbiAgICAgIGNvbnN0cnVjdE5hbWU6IFwiVGVycmFmb3JtSXRlcmF0b3JcIixcbiAgICB9KTtcblxuICAgIGNvbnN0IGl0ZXJhdG9yID0gdC52YXJpYWJsZURlY2xhcmF0aW9uKFwiY29uc3RcIiwgW1xuICAgICAgdC52YXJpYWJsZURlY2xhcmF0b3IoXG4gICAgICAgIHQuaWRlbnRpZmllcihkeW5hbWljQmxvY2tJdGVyYXRvck5hbWUpLFxuICAgICAgICB0LmNhbGxFeHByZXNzaW9uKFxuICAgICAgICAgIHQubWVtYmVyRXhwcmVzc2lvbihcbiAgICAgICAgICAgIHQuaWRlbnRpZmllcihcIlRlcnJhZm9ybUl0ZXJhdG9yXCIpLFxuICAgICAgICAgICAgdC5pZGVudGlmaWVyKFwiZnJvbUxpc3RcIilcbiAgICAgICAgICApLFxuICAgICAgICAgIFtyZWZlcmVuY2VBc3RdXG4gICAgICAgIClcbiAgICAgICksXG4gICAgXSk7XG4gICAgdC5hZGRDb21tZW50KGl0ZXJhdG9yLCBcImxlYWRpbmdcIiwgbG9vcENvbW1lbnQpO1xuICAgIGV4cHJlc3Npb25zLnB1c2goaXRlcmF0b3IpO1xuICAgIGNvbnN0IGR5bmFtaWNDYWxsRXhwcmVzc2lvbiA9IHQuY2FsbEV4cHJlc3Npb24oXG4gICAgICB0Lm1lbWJlckV4cHJlc3Npb24oXG4gICAgICAgIHQuaWRlbnRpZmllcihkeW5hbWljQmxvY2tJdGVyYXRvck5hbWUpLFxuICAgICAgICB0LmlkZW50aWZpZXIoXCJkeW5hbWljXCIpXG4gICAgICApLFxuICAgICAgW1xuICAgICAgICBhd2FpdCB2YWx1ZVRvVHMoXG4gICAgICAgICAge1xuICAgICAgICAgICAgLi4uc2NvcGUsXG4gICAgICAgICAgICBzY29wZWRWYXJpYWJsZXM6IHtcbiAgICAgICAgICAgICAgW2Jsb2NrLnNjb3BlZFZhcl06IGR5bmFtaWNCbG9ja0l0ZXJhdG9yTmFtZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgICBmaWxsV2l0aENvbmZpZ0FjY2Vzc29ycyhcbiAgICAgICAgICAgIHNjb3BlLFxuICAgICAgICAgICAgQXJyYXkuaXNBcnJheShibG9jay5jb250ZW50KSA/IGJsb2NrLmNvbnRlbnRbMF0gOiBibG9jay5jb250ZW50LFxuICAgICAgICAgICAgYmxvY2sucGF0aC5yZXBsYWNlKGJsb2NrLnNjb3BlZFZhciwgXCJcIilcbiAgICAgICAgICApLFxuICAgICAgICAgIGJsb2NrLnBhdGgucmVwbGFjZShibG9jay5zY29wZWRWYXIsIFwiXCIpLFxuICAgICAgICAgIGZhbHNlXG4gICAgICAgICksXG4gICAgICBdXG4gICAgKTtcblxuICAgIGNvbnN0IHBhcnRzID0gYmxvY2sucGF0aFxuICAgICAgLnJlcGxhY2UoYGR5bmFtaWMuJHtibG9jay5zY29wZWRWYXJ9YCwgXCJcIilcbiAgICAgIC5zcGxpdChcIi5cIilcbiAgICAgIC5maWx0ZXIoKHApID0+IHAubGVuZ3RoID4gMCk7XG5cbiAgICBjb25zdCBwYXJlbnQgPSBwYXJ0cy5yZWR1Y2UoKGFjYywgcGFydCkgPT4ge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYWNjKSAmJiAhTnVtYmVyLmlzTmFOKHBhcnNlSW50KHBhcnQsIDEwKSkpIHtcbiAgICAgICAgcmV0dXJuIGFjY1twYXJzZUludChwYXJ0LCAxMCldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGFjY1twYXJ0XTtcbiAgICAgIH1cbiAgICB9LCBtYXBwZWRDb25maWcpO1xuICAgIHBhcmVudFtibG9jay5zY29wZWRWYXJdID0gZHluYW1pY0NhbGxFeHByZXNzaW9uO1xuICAgIGRlbGV0ZSBwYXJlbnQuZHluYW1pYztcbiAgfVxuXG4gIGNvbnN0IG92ZXJyaWRlUmVmZXJlbmNlID0gZHluYW1pY0Jsb2Nrc1VzaW5nT3ZlcnJpZGVzLmxlbmd0aFxuICAgID8ge1xuICAgICAgICBzdGFydDogMCxcbiAgICAgICAgZW5kOiAwLFxuICAgICAgICByZWZlcmVuY2VlOiB7XG4gICAgICAgICAgaWQ6IGAke3R5cGV9LiR7a2V5fWAsXG4gICAgICAgICAgZnVsbDogYCR7dHlwZX0uJHtrZXl9YCxcbiAgICAgICAgfSxcbiAgICAgIH1cbiAgICA6IHVuZGVmaW5lZDtcblxuICBpZiAocHJvdmlzaW9uZXIpIHtcbiAgICBtYXBwZWRDb25maWcucHJvdmlzaW9uZXJzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICBPYmplY3QuZW50cmllcyhwcm92aXNpb25lcikuZmxhdE1hcCgoW3R5cGUsIHBdOiBbc3RyaW5nLCBhbnldKSA9PlxuICAgICAgICBwLm1hcCgocHA6IFJlY29yZDxzdHJpbmcsIGFueT4pID0+XG4gICAgICAgICAgdmFsdWVUb1RzKFxuICAgICAgICAgICAgc2NvcGUsXG4gICAgICAgICAgICB7IHR5cGUsIC4uLnBwIH0sXG4gICAgICAgICAgICBcInBhdGgtZm9yLXByb3Zpc2lvbmVycy1jYW4tYmUtaWdub3JlZFwiXG4gICAgICAgICAgKVxuICAgICAgICApXG4gICAgICApXG4gICAgKTtcbiAgfVxuXG4gIGV4cHJlc3Npb25zID0gZXhwcmVzc2lvbnMuY29uY2F0KFxuICAgIGF3YWl0IGFzRXhwcmVzc2lvbihcbiAgICAgIHsgLi4uc2NvcGUsIGZvckVhY2hJdGVyYXRvck5hbWUsIGNvdW50SXRlcmF0b3JOYW1lIH0sXG4gICAgICByZXNvdXJjZSxcbiAgICAgIGtleSxcbiAgICAgIG1hcHBlZENvbmZpZyxcbiAgICAgIGZhbHNlLFxuICAgICAgZmFsc2UsXG4gICAgICBnZXRSZWZlcmVuY2UoZ3JhcGgsIGlkKSB8fCBvdmVycmlkZVJlZmVyZW5jZVxuICAgIClcbiAgKTtcblxuICAvLyBDaGVjayBmb3IgZHluYW1pYyBibG9ja3NcbiAgZXhwcmVzc2lvbnMgPSBleHByZXNzaW9ucy5jb25jYXQoXG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICBkeW5hbWljQmxvY2tzVXNpbmdPdmVycmlkZXMubWFwKGFzeW5jICh7IHBhdGgsIGZvcl9lYWNoLCBjb250ZW50IH0pID0+IHtcbiAgICAgICAgLy8gV2UgbmVlZCB0byBsZXQgdGhlIGV4cHJlc3Npb24gY29udmVyc2lvbiBrbm93IGFsbCBhdmFpbGFibGVcbiAgICAgICAgLy8gZHluYW1pYyBibG9jayBuYW1lcywgc28gd2UgZG9uJ3QgcmVwbGFjZSB0aGVtLiBUaGUgXCJkeW5hbWljLWJsb2NrXCJcbiAgICAgICAgLy8gc2NvcGVkIHZhcmlhYmxlIGluZGljYXRlcyB0byB0aGUgZXhwcmVzc2lvbiBjb252ZXJzaW9uIHRvIHVzZSB0aGVcbiAgICAgICAgLy8ga2V5IG5hbWUgaW5zdGVhZCBvZiBhbiBpdGVyYXRvclxuICAgICAgICBjb25zdCBzY29wZWRWYXJpYWJsZXNJblBhdGggPSBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICAgICAgcGF0aFxuICAgICAgICAgICAgLnN1YnN0cmluZygxKSAvLyBUaGUgcGF0aCBzdGFydHMgd2l0aCBhIGRvdCB0aGF0IHJlc3VsdHMgaW4gYW4gZW1wdHkgc3BsaXRcbiAgICAgICAgICAgIC5zcGxpdChcIi5cIilcbiAgICAgICAgICAgIC5maWx0ZXIoXG4gICAgICAgICAgICAgIChwKSA9PiAhW1wiZHluYW1pY1wiLCBcImNvbnRlbnRcIl0uaW5jbHVkZXMocCkgJiYgaXNOYU4ocGFyc2VJbnQocCkpXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAubWFwKChwKSA9PiBbcCwgXCJkeW5hbWljLWJsb2NrXCJdKVxuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybiBhZGRPdmVycmlkZUV4cHJlc3Npb24oXG4gICAgICAgICAgdmFyTmFtZSxcbiAgICAgICAgICBwYXRoLnN1YnN0cmluZygxKSwgLy8gVGhlIHBhdGggc3RhcnRzIHdpdGggYSBkb3QgdGhhdCB3ZSBkb24ndCB3YW50XG4gICAgICAgICAgYXdhaXQgdmFsdWVUb1RzKFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAuLi5zY29wZSxcbiAgICAgICAgICAgICAgd2l0aGluT3ZlcnJpZGVFeHByZXNzaW9uOiB0cnVlLFxuICAgICAgICAgICAgICBzY29wZWRWYXJpYWJsZXM6IHNjb3BlZFZhcmlhYmxlc0luUGF0aCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGZvcl9lYWNoLFxuICAgICAgICAgICAgICBjb250ZW50LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwicGF0aC1mb3ItZHluYW1pYy1ibG9ja3MtY2FuLWJlLWlnbm9yZWRcIlxuICAgICAgICAgICksXG4gICAgICAgICAgbG9vcENvbW1lbnRcbiAgICAgICAgKTtcbiAgICAgIH0pXG4gICAgKVxuICApO1xuXG4gIHJldHVybiBleHByZXNzaW9ucztcbn1cblxuYXN5bmMgZnVuY3Rpb24gYXNFeHByZXNzaW9uKFxuICBzY29wZTogUmVzb3VyY2VTY29wZSxcbiAgdHlwZTogc3RyaW5nLFxuICBuYW1lOiBzdHJpbmcsXG4gIGNvbmZpZzogVGVycmFmb3JtUmVzb3VyY2VCbG9jayxcbiAgaXNNb2R1bGVJbXBvcnQ6IGJvb2xlYW4sXG4gIGlzUHJvdmlkZXI6IGJvb2xlYW4sXG4gIHJlZmVyZW5jZT86IFJlZmVyZW5jZVxuKSB7XG4gIGNvbnN0IHsgcHJvdmlkZXJzLCAuLi5vdGhlck9wdGlvbnMgfSA9IGNvbmZpZyBhcyBhbnk7XG5cbiAgY29uc3QgY29uc3RydWN0SWQgPSB1bmlxdWVJZChzY29wZS5jb25zdHJ1Y3RzLCBuYW1lKTtcbiAgY29uc3Qgb3ZlcnJpZGVJZCA9ICFpc1Byb3ZpZGVyICYmIGNvbnN0cnVjdElkICE9PSBuYW1lO1xuXG4gIGNvbnN0IGNvbXBsZXRlT2JqZWN0ID0gZmlsbFdpdGhDb25maWdBY2Nlc3NvcnMoc2NvcGUsIG90aGVyT3B0aW9ucywgdHlwZSk7XG5cbiAgY29uc3QgZXhwcmVzc2lvbiA9IHQubmV3RXhwcmVzc2lvbihcbiAgICBjb25zdHJ1Y3RBc3Qoc2NvcGUsIHR5cGUsIGlzTW9kdWxlSW1wb3J0KSxcbiAgICBbXG4gICAgICB0LnRoaXNFeHByZXNzaW9uKCksXG4gICAgICB0LnN0cmluZ0xpdGVyYWwoY29uc3RydWN0SWQpLFxuXG4gICAgICBhd2FpdCB2YWx1ZVRvVHMoXG4gICAgICAgIHNjb3BlLFxuICAgICAgICB7XG4gICAgICAgICAgLi4uY29tcGxldGVPYmplY3QsXG4gICAgICAgICAgcHJvdmlkZXJzOlxuICAgICAgICAgICAgcHJvdmlkZXJzICYmIE9iamVjdC5rZXlzKHByb3ZpZGVycykubGVuZ3RoXG4gICAgICAgICAgICAgID8gT2JqZWN0LmVudHJpZXMocHJvdmlkZXJzKS5tYXAoKFtrZXksIHZhbHVlXSkgPT4gKHtcbiAgICAgICAgICAgICAgICAgIG1vZHVsZUFsaWFzOiBrZXksXG4gICAgICAgICAgICAgICAgICBwcm92aWRlcjogdmFsdWUsXG4gICAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICB9LFxuICAgICAgICBgJHt0eXBlfWAsXG4gICAgICAgIGlzTW9kdWxlSW1wb3J0XG4gICAgICApLFxuICAgIF1cbiAgKTtcblxuICBjb25zdCBzdGF0ZW1lbnRzID0gW107XG4gIGNvbnN0IHZhck5hbWUgPSByZWZlcmVuY2VcbiAgICA/IHJlZmVyZW5jZVRvVmFyaWFibGVOYW1lKHNjb3BlLCByZWZlcmVuY2UpXG4gICAgOiB2YXJpYWJsZU5hbWUoc2NvcGUsIHR5cGUsIG5hbWUpO1xuXG4gIGlmIChyZWZlcmVuY2UgfHwgb3ZlcnJpZGVJZCkge1xuICAgIHN0YXRlbWVudHMucHVzaChcbiAgICAgIHQudmFyaWFibGVEZWNsYXJhdGlvbihcImNvbnN0XCIsIFtcbiAgICAgICAgdC52YXJpYWJsZURlY2xhcmF0b3IodC5pZGVudGlmaWVyKHZhck5hbWUpLCBleHByZXNzaW9uKSxcbiAgICAgIF0pXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICBzdGF0ZW1lbnRzLnB1c2godC5leHByZXNzaW9uU3RhdGVtZW50KGV4cHJlc3Npb24pKTtcbiAgfVxuXG4gIGlmIChvdmVycmlkZUlkKSB7XG4gICAgc3RhdGVtZW50cy5wdXNoKGFkZE92ZXJyaWRlTG9naWNhbElkRXhwcmVzc2lvbih2YXJOYW1lLCBuYW1lKSk7XG4gIH1cblxuICByZXR1cm4gc3RhdGVtZW50cztcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIG91dHB1dChcbiAgc2NvcGU6IFByb2dyYW1TY29wZSxcbiAga2V5OiBzdHJpbmcsXG4gIF9pZDogc3RyaW5nLFxuICBpdGVtOiBPdXRwdXQsXG4gIF9ncmFwaDogRGlyZWN0ZWRHcmFwaFxuKSB7XG4gIGNvbnN0IFt7IHZhbHVlLCBkZXNjcmlwdGlvbiwgc2Vuc2l0aXZlIH1dID0gaXRlbTtcblxuICByZXR1cm4gYXNFeHByZXNzaW9uKFxuICAgIHNjb3BlLFxuICAgIFwiY2RrdGYuVGVycmFmb3JtT3V0cHV0XCIsXG4gICAga2V5LFxuICAgIHtcbiAgICAgIHZhbHVlLFxuICAgICAgZGVzY3JpcHRpb24sXG4gICAgICBzZW5zaXRpdmUsXG4gICAgfSxcbiAgICBmYWxzZSxcbiAgICBmYWxzZSxcbiAgICB1bmRlZmluZWRcbiAgKTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHZhcmlhYmxlVHlwZVRvQXN0KFxuICBzY29wZTogUHJvZ3JhbVNjb3BlLFxuICB0eXBlOiBzdHJpbmdcbik6IFByb21pc2U8dC5FeHByZXNzaW9uPiB7XG4gIGNvbnN0IGFkZFZhcmlhYmxlVHlwZVRvSW1wb3J0cyA9ICgpID0+XG4gICAgc2NvcGUuaW1wb3J0YWJsZXMucHVzaCh7XG4gICAgICBjb25zdHJ1Y3ROYW1lOiBcIlZhcmlhYmxlVHlwZVwiLFxuICAgICAgcHJvdmlkZXI6IFwiY2RrdGZcIixcbiAgICB9KTtcblxuICBmdW5jdGlvbiBwYXJzZWRUeXBlVG9Bc3QodHlwZTogdGV4LkV4cHJlc3Npb25UeXBlKTogdC5FeHByZXNzaW9uIHtcbiAgICBpZiAodGV4LmlzU2NvcGVUcmF2ZXJzYWxFeHByZXNzaW9uKHR5cGUpKSB7XG4gICAgICBhZGRWYXJpYWJsZVR5cGVUb0ltcG9ydHMoKTtcbiAgICAgIHN3aXRjaCAodHlwZS5tZXRhLnZhbHVlKSB7XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICByZXR1cm4gdC5pZGVudGlmaWVyKFwiVmFyaWFibGVUeXBlLlNUUklOR1wiKTtcbiAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICAgIHJldHVybiB0LmlkZW50aWZpZXIoXCJWYXJpYWJsZVR5cGUuTlVNQkVSXCIpO1xuICAgICAgICBjYXNlIFwiYm9vbFwiOlxuICAgICAgICAgIHJldHVybiB0LmlkZW50aWZpZXIoXCJWYXJpYWJsZVR5cGUuQk9PTFwiKTtcbiAgICAgICAgY2FzZSBcImFueVwiOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiB0LmlkZW50aWZpZXIoXCJWYXJpYWJsZVR5cGUuQU5ZXCIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0ZXguaXNGdW5jdGlvbkNhbGxFeHByZXNzaW9uKHR5cGUpKSB7XG4gICAgICBhZGRWYXJpYWJsZVR5cGVUb0ltcG9ydHMoKTtcbiAgICAgIHN3aXRjaCAodHlwZS5tZXRhLm5hbWUpIHtcbiAgICAgICAgY2FzZSBcImxpc3RcIjpcbiAgICAgICAgY2FzZSBcInNldFwiOlxuICAgICAgICBjYXNlIFwibWFwXCI6XG4gICAgICAgIGNhc2UgXCJ0dXBsZVwiOlxuICAgICAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICAgICAgcmV0dXJuIHQuY2FsbEV4cHJlc3Npb24oXG4gICAgICAgICAgICB0LmlkZW50aWZpZXIoYFZhcmlhYmxlVHlwZS4ke3R5cGUubWV0YS5uYW1lfWApLFxuICAgICAgICAgICAgdHlwZS5jaGlsZHJlbi5tYXAoKGNoaWxkKSA9PiBwYXJzZWRUeXBlVG9Bc3QoY2hpbGQpKVxuICAgICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRleC5pc09iamVjdEV4cHJlc3Npb24odHlwZSkpIHtcbiAgICAgIHJldHVybiB0Lm9iamVjdEV4cHJlc3Npb24oXG4gICAgICAgIE9iamVjdC5lbnRyaWVzKHR5cGUubWV0YS5pdGVtcykubWFwKChba2V5LCB2YWx1ZV0pID0+XG4gICAgICAgICAgdC5vYmplY3RQcm9wZXJ0eShcbiAgICAgICAgICAgIHQuc3RyaW5nTGl0ZXJhbChrZXkpLFxuICAgICAgICAgICAgLy8gVGhpcyBkb2VzIG5vdCBkZWFsIHdpdGggY29tcGxleCB0eXBlcyBuZXN0ZWQgd2l0aGluIG9iamVjdHNcbiAgICAgICAgICAgIC8vIElmIHN1Y2ggYSB0eXBlIGlzIGZvdW5kIGl0IHdpbGwgcmVzdWx0IGluIGFuIEFueSB0eXBlXG4gICAgICAgICAgICAvLyBlLmcuIHsgZm9vOiBsaXN0KHN0cmluZykgfSB3aWxsIHJlc3VsdCBpbiB7IGZvbzogYW55IH1cbiAgICAgICAgICAgIHBhcnNlZFR5cGVUb0FzdCh7XG4gICAgICAgICAgICAgIHR5cGU6IFwic2NvcGVUcmF2ZXJzYWxcIixcbiAgICAgICAgICAgICAgbWV0YTogeyB2YWx1ZSB9LFxuICAgICAgICAgICAgfSBhcyBhbnkpXG4gICAgICAgICAgKVxuICAgICAgICApXG4gICAgICApO1xuICAgIH1cblxuICAgIGFkZFZhcmlhYmxlVHlwZVRvSW1wb3J0cygpO1xuICAgIHJldHVybiB0LmlkZW50aWZpZXIoXCJWYXJpYWJsZVR5cGUuQU5ZXCIpO1xuICB9XG5cbiAgcmV0dXJuIHBhcnNlZFR5cGVUb0FzdChhd2FpdCBleHByZXNzaW9uQXN0KHR5cGUpKTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHZhcmlhYmxlKFxuICBzY29wZTogUHJvZ3JhbVNjb3BlLFxuICBrZXk6IHN0cmluZyxcbiAgaWQ6IHN0cmluZyxcbiAgaXRlbTogVmFyaWFibGUsXG4gIGdyYXBoOiBEaXJlY3RlZEdyYXBoXG4pIHtcbiAgY29uc3QgW3sgdHlwZSwgLi4ucHJvcHMgfV0gPSBpdGVtO1xuXG4gIGlmICghZ2V0UmVmZXJlbmNlKGdyYXBoLCBpZCkpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICByZXR1cm4gYXNFeHByZXNzaW9uKFxuICAgIHNjb3BlLFxuICAgIGlkLFxuICAgIGtleSxcbiAgICB7IC4uLnByb3BzLCB0eXBlOiB0eXBlID8gYXdhaXQgdmFyaWFibGVUeXBlVG9Bc3Qoc2NvcGUsIHR5cGUpIDogdW5kZWZpbmVkIH0sXG4gICAgZmFsc2UsXG4gICAgZmFsc2UsXG4gICAgZ2V0UmVmZXJlbmNlKGdyYXBoLCBpZClcbiAgKTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGxvY2FsKFxuICBzY29wZTogUHJvZ3JhbVNjb3BlLFxuICBrZXk6IHN0cmluZyxcbiAgaWQ6IHN0cmluZyxcbiAgaXRlbTogVGVycmFmb3JtUmVzb3VyY2VCbG9jayxcbiAgZ3JhcGg6IERpcmVjdGVkR3JhcGhcbik6IFByb21pc2U8dC5WYXJpYWJsZURlY2xhcmF0aW9uW10+IHtcbiAgbG9nZ2VyLmRlYnVnKGBJbml0aWFsaXppbmcgbG9jYWwgcmVzb3VyY2UgJHtrZXl9IHdpdGggaWQgJHtpZH1gKTtcbiAgaWYgKCFnZXRSZWZlcmVuY2UoZ3JhcGgsIGlkKSkge1xuICAgIGxvZ2dlci5kZWJ1ZyhgTm8gcmVmZXJlbmNlIGZvdW5kIGZvciAke2tleX1gKTtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgcmV0dXJuIFtcbiAgICB0LnZhcmlhYmxlRGVjbGFyYXRpb24oXCJjb25zdFwiLCBbXG4gICAgICB0LnZhcmlhYmxlRGVjbGFyYXRvcihcbiAgICAgICAgdC5pZGVudGlmaWVyKHZhcmlhYmxlTmFtZShzY29wZSwgXCJsb2NhbFwiLCBrZXkpKSxcbiAgICAgICAgYXdhaXQgdmFsdWVUb1RzKHNjb3BlLCBpdGVtLCBcInBhdGgtZm9yLWxvY2FsLWJsb2Nrcy1jYW4tYmUtaWdub3JlZFwiKVxuICAgICAgKSxcbiAgICBdKSxcbiAgXTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIG1vZHVsZXMoXG4gIHNjb3BlOiBQcm9ncmFtU2NvcGUsXG4gIGtleTogc3RyaW5nLFxuICBpZDogc3RyaW5nLFxuICBpdGVtOiBNb2R1bGUsXG4gIGdyYXBoOiBEaXJlY3RlZEdyYXBoXG4pIHtcbiAgY29uc3QgW3sgc291cmNlLCB2ZXJzaW9uLCAuLi5wcm9wcyB9XSA9IGl0ZW07XG5cbiAgY29uc3QgbW9kdWxlQ29uc3RyYWludCA9IG5ldyBUZXJyYWZvcm1Nb2R1bGVDb25zdHJhaW50KHNvdXJjZSk7XG5cbiAgcmV0dXJuIGFzRXhwcmVzc2lvbihcbiAgICBzY29wZSxcbiAgICBtb2R1bGVDb25zdHJhaW50LmNsYXNzTmFtZSxcbiAgICBrZXksXG4gICAgcHJvcHMsXG4gICAgdHJ1ZSxcbiAgICBmYWxzZSxcbiAgICBnZXRSZWZlcmVuY2UoZ3JhcGgsIGlkKVxuICApO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcHJvdmlkZXIoXG4gIHNjb3BlOiBQcm9ncmFtU2NvcGUsXG4gIGtleTogc3RyaW5nLFxuICBpZDogc3RyaW5nLFxuICBpdGVtOiBQcm92aWRlclswXSxcbiAgZ3JhcGg6IERpcmVjdGVkR3JhcGhcbikge1xuICBjb25zdCB7IHZlcnNpb24sIC4uLnByb3BzIH0gPSBpdGVtO1xuXG4gIGNvbnN0IGltcG9ydEtleSA9IGtleSA9PT0gXCJudWxsXCIgPyBcIk51bGxQcm92aWRlclwiIDoga2V5O1xuXG4gIHJldHVybiBhc0V4cHJlc3Npb24oXG4gICAgc2NvcGUsXG4gICAgYCR7aW1wb3J0S2V5fS4ke3Bhc2NhbENhc2Uoa2V5KX1Qcm92aWRlcmAsXG4gICAga2V5LFxuICAgIHByb3BzLFxuICAgIGZhbHNlLFxuICAgIHRydWUsXG4gICAgZ2V0UmVmZXJlbmNlKGdyYXBoLCBpZClcbiAgKTtcbn1cblxuZXhwb3J0IGNvbnN0IGNka3RmSW1wb3J0ID0gdGVtcGxhdGUoXG4gIGBpbXBvcnQgKiBhcyBjZGt0ZiBmcm9tIFwiY2RrdGZcImBcbikoKSBhcyB0LlN0YXRlbWVudDtcblxuZXhwb3J0IGNvbnN0IGNvbnN0cnVjdHNJbXBvcnQgPSB0ZW1wbGF0ZShcbiAgYGltcG9ydCAqIGFzIGNvbnN0cnVjdHMgZnJvbSBcImNvbnN0cnVjdHNcImBcbikoKSBhcyB0LlN0YXRlbWVudDtcblxuZXhwb3J0IGNvbnN0IHByb3ZpZGVySW1wb3J0cyA9IChwcm92aWRlcnM6IHN0cmluZ1tdKSA9PlxuICBwcm92aWRlcnMubWFwKChwcm92aWRlck5hbWUpID0+IHtcbiAgICBjb25zdCBwYXJ0cyA9IHByb3ZpZGVyTmFtZS5zcGxpdChcIi9cIik7XG4gICAgY29uc3QgbmFtZSA9IHBhcnRzLmxlbmd0aCA+IDEgPyBwYXJ0c1sxXSA6IHBhcnRzWzBdO1xuICAgIGNvbnN0IGltcG9ydE5hbWUgPSBuYW1lID09PSBcIm51bGxcIiA/IFwiTnVsbFByb3ZpZGVyXCIgOiBuYW1lO1xuICAgIHJldHVybiB0ZW1wbGF0ZShcbiAgICAgIGBpbXBvcnQgKiBhcyAke2ltcG9ydE5hbWV9IGZyb20gXCIuLy5nZW4vcHJvdmlkZXJzLyR7bmFtZS5yZXBsYWNlKFxuICAgICAgICBcIi4vXCIsXG4gICAgICAgIFwiXCJcbiAgICAgICl9XCJgXG4gICAgKSgpIGFzIHQuU3RhdGVtZW50O1xuICB9KTtcblxuZXhwb3J0IGNvbnN0IG1vZHVsZUltcG9ydHMgPSAobW9kdWxlczogUmVjb3JkPHN0cmluZywgTW9kdWxlPiB8IHVuZGVmaW5lZCkgPT4ge1xuICBjb25zdCB1bmlxdWVNb2R1bGVzID0gbmV3IFNldDxzdHJpbmc+KCk7XG4gIE9iamVjdC52YWx1ZXMobW9kdWxlcyB8fCB7fSkubWFwKChbbW9kdWxlXSkgPT5cbiAgICB1bmlxdWVNb2R1bGVzLmFkZChtb2R1bGUuc291cmNlKVxuICApO1xuXG4gIGNvbnN0IGltcG9ydHM6IHQuU3RhdGVtZW50W10gPSBbXTtcbiAgdW5pcXVlTW9kdWxlcy5mb3JFYWNoKChtKSA9PiB7XG4gICAgY29uc3QgbW9kdWxlQ29uc3RyYWludCA9IG5ldyBUZXJyYWZvcm1Nb2R1bGVDb25zdHJhaW50KG0pO1xuICAgIGltcG9ydHMucHVzaChcbiAgICAgIHRlbXBsYXRlLmFzdChcbiAgICAgICAgYGltcG9ydCAqIGFzICR7bW9kdWxlQ29uc3RyYWludC5jbGFzc05hbWV9IGZyb20gXCIuLy5nZW4vbW9kdWxlcy8ke21vZHVsZUNvbnN0cmFpbnQuZmlsZU5hbWV9XCJgXG4gICAgICApIGFzIHQuU3RhdGVtZW50XG4gICAgKTtcbiAgfSk7XG4gIHJldHVybiBpbXBvcnRzO1xufTtcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdlbihzdGF0ZW1lbnRzOiB0LlN0YXRlbWVudFtdKSB7XG4gIGxvZ2dlci5kZWJ1ZyhgR2VuZXJhdGluZyBjb2RlIGZvciAke0pTT04uc3RyaW5naWZ5KHN0YXRlbWVudHMsIG51bGwsIDIpfWApO1xuICBjb25zdCBjb2RlID0gcHJldHRpZXIuZm9ybWF0KGdlbmVyYXRlKHQucHJvZ3JhbShzdGF0ZW1lbnRzKSBhcyBhbnkpLmNvZGUsIHtcbiAgICBwYXJzZXI6IFwiYmFiZWxcIixcbiAgfSk7XG5cbiAgbG9nZ2VyLmRlYnVnKGBHZW5lcmF0ZWQgY29kZTpcXG4ke2NvZGV9YCk7XG5cbiAgcmV0dXJuIGNvZGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRJbXBvcnRGb3JDb2RlQ29udGFpbmVyKFxuICBzY29wZTogUHJvZ3JhbVNjb3BlLFxuICBjb2RlQ29udGFpbmVyOiBzdHJpbmdcbikge1xuICBzd2l0Y2ggKGNvZGVDb250YWluZXIpIHtcbiAgICBjYXNlIFwiY29uc3RydWN0cy5Db25zdHJ1Y3RcIjpcbiAgICAgIHNjb3BlLmltcG9ydGFibGVzLnB1c2goe1xuICAgICAgICBwcm92aWRlcjogXCJjb25zdHJ1Y3RzXCIsXG4gICAgICAgIGNvbnN0cnVjdE5hbWU6IFwiQ29uc3RydWN0XCIsXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcImNka3RmLlRlcnJhZm9ybVN0YWNrXCI6XG4gICAgICBzY29wZS5pbXBvcnRhYmxlcy5wdXNoKHtcbiAgICAgICAgcHJvdmlkZXI6IFwiY2RrdGZcIixcbiAgICAgICAgY29uc3RydWN0TmFtZTogXCJUZXJyYWZvcm1TdGFja1wiLFxuICAgICAgfSk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgRXJyb3JzLkludGVybmFsKFwiVW5zdXBwb3J0ZWQgY29kZSBjb250YWluZXI6IFwiICsgY29kZUNvbnRhaW5lcik7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHdyYXBDb2RlSW5Db25zdHJ1Y3RvcihcbiAgY29kZUNvbnRhaW5lcjogc3RyaW5nLFxuICBjb2RlOiB0LlN0YXRlbWVudFtdLFxuICBjbGFzc05hbWU6IHN0cmluZyxcbiAgY29uZmlnVHlwZU5hbWU/OiBzdHJpbmdcbik6IHQuU3RhdGVtZW50IHtcbiAgbGV0IGJhc2VDb250YWluZXJDbGFzczogdC5JZGVudGlmaWVyO1xuICBzd2l0Y2ggKGNvZGVDb250YWluZXIpIHtcbiAgICBjYXNlIFwiY29uc3RydWN0cy5Db25zdHJ1Y3RcIjpcbiAgICAgIGJhc2VDb250YWluZXJDbGFzcyA9IHQuaWRlbnRpZmllcihcIkNvbnN0cnVjdFwiKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcImNka3RmLlRlcnJhZm9ybVN0YWNrXCI6XG4gICAgICBiYXNlQ29udGFpbmVyQ2xhc3MgPSB0LmlkZW50aWZpZXIoXCJUZXJyYWZvcm1TdGFja1wiKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBFcnJvcnMuSW50ZXJuYWwoXCJVbnN1cHBvcnRlZCBjb2RlIGNvbnRhaW5lcjogXCIgKyBjb2RlQ29udGFpbmVyKTtcbiAgfVxuICBpZiAoY29uZmlnVHlwZU5hbWUpIHtcbiAgICByZXR1cm4gdGVtcGxhdGUuc3RhdGVtZW50KFxuICAgICAgYFxuICBjbGFzcyAlJWNsYXNzTmFtZSUlIGV4dGVuZHMgJSViYXNlJSUge1xuICAgIGNvbnN0cnVjdG9yKHNjb3BlOiBDb25zdHJ1Y3QsIG5hbWU6IHN0cmluZywgY29uZmlnOiAke2NvbmZpZ1R5cGVOYW1lfSkge1xuICAgICAgc3VwZXIoc2NvcGUsIG5hbWUpO1xuICAgICAgJSVjb2RlJSVcbiAgICB9XG4gIH1cbmAsXG4gICAgICB7IHN5bnRhY3RpY1BsYWNlaG9sZGVyczogdHJ1ZSwgcGx1Z2luczogW1widHlwZXNjcmlwdFwiXSB9XG4gICAgKSh7XG4gICAgICBjb2RlLFxuICAgICAgYmFzZTogYmFzZUNvbnRhaW5lckNsYXNzLFxuICAgICAgY2xhc3NOYW1lOiB0LmlkZW50aWZpZXIoY2xhc3NOYW1lKSxcbiAgICB9KSBhcyB0LlN0YXRlbWVudDtcbiAgfVxuICByZXR1cm4gdGVtcGxhdGUuc3RhdGVtZW50KFxuICAgIGBcbiAgY2xhc3MgJSVjbGFzc05hbWUlJSBleHRlbmRzICUlYmFzZSUlIHtcbiAgICBjb25zdHJ1Y3RvcihzY29wZTogQ29uc3RydWN0LCBuYW1lOiBzdHJpbmcpIHtcbiAgICAgIHN1cGVyKHNjb3BlLCBuYW1lKTtcbiAgICAgICUlY29kZSUlXG4gICAgfVxuICB9XG5gLFxuICAgIHsgc3ludGFjdGljUGxhY2Vob2xkZXJzOiB0cnVlLCBwbHVnaW5zOiBbXCJ0eXBlc2NyaXB0XCJdIH1cbiAgKSh7XG4gICAgY29kZSxcbiAgICBiYXNlOiBiYXNlQ29udGFpbmVyQ2xhc3MsXG4gICAgY2xhc3NOYW1lOiB0LmlkZW50aWZpZXIoY2xhc3NOYW1lKSxcbiAgfSkgYXMgdC5TdGF0ZW1lbnQ7XG59XG5cbmV4cG9ydCBjb25zdCBwcm92aWRlckNvbnN0cnVjdEltcG9ydHMgPSAoaW1wb3J0YWJsZTogSW1wb3J0YWJsZUNvbnN0cnVjdFtdKSA9PiB7XG4gIGxldCBwcm92aWRlciA9IGltcG9ydGFibGVbMF0ucHJvdmlkZXI7XG4gIGxldCBuYW1lc3BhY2UgPSBpbXBvcnRhYmxlWzBdLm5hbWVzcGFjZTtcbiAgY29uc3QgbmFtZXMgPSBpbXBvcnRhYmxlLm1hcCgoaSkgPT4gaS5jb25zdHJ1Y3ROYW1lKTtcblxuICBpZiAocHJvdmlkZXIgPT09IFwiY2RrdGZcIiB8fCBwcm92aWRlciA9PT0gXCJjb25zdHJ1Y3RzXCIpIHtcbiAgICByZXR1cm4gdGVtcGxhdGUoXG4gICAgICBgaW1wb3J0IHsgJHtuYW1lcy5qb2luKFwiLCBcIil9IH0gZnJvbSBcIiR7cHJvdmlkZXJ9XCJgXG4gICAgKSgpIGFzIHQuU3RhdGVtZW50O1xuICB9XG5cbiAgaWYgKG5hbWVzcGFjZSkge1xuICAgIG5hbWVzcGFjZSA9IHNuYWtlQ2FzZShuYW1lc3BhY2UpLnJlcGxhY2UoL18vZywgXCItXCIpO1xuICB9XG5cbiAgLy8gU3BlY2lhbCBjYXNlcyB0byB1bmRvIHByb3ZpZGVyIG5hbWVzIHRoYXQgd2Ugb3ZlcnJpZGVcbiAgaWYgKHByb3ZpZGVyID09PSBcIk51bGxQcm92aWRlclwiKSB7XG4gICAgcHJvdmlkZXIgPSBcIm51bGxcIjtcbiAgfVxuXG4gIHJldHVybiB0ZW1wbGF0ZShcbiAgICBgaW1wb3J0IHsgJHtuYW1lcy5qb2luKFxuICAgICAgXCIsIFwiXG4gICAgKX0gfSBmcm9tIFwiLi8uZ2VuL3Byb3ZpZGVycy8ke3Byb3ZpZGVyfS8ke25hbWVzcGFjZX1cImBcbiAgKSgpIGFzIHQuU3RhdGVtZW50O1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkSW1wb3J0cyhpbXBvcnRhYmxlczogSW1wb3J0YWJsZUNvbnN0cnVjdFtdKSB7XG4gIGNvbnN0IGdyb3VwZWRJbXBvcnRhYmxlcyA9IGltcG9ydGFibGVzLnJlZHVjZSgoYWNjLCBpbXBvcnRhYmxlKSA9PiB7XG4gICAgY29uc3QgbnMgPSBpbXBvcnRhYmxlLm5hbWVzcGFjZSB8fCBcIlwiO1xuICAgIC8vIERvaW5nIHNvbWUgaGFja3kgb3JkZXJpbmcgb2YgdGhlIGltcG9ydHMgdG8gbWFrZSB0aGVtIGxvb2sgYSBiaXQgbmljZXJcbiAgICBjb25zdCBwcmVmaXggPVxuICAgICAgaW1wb3J0YWJsZS5wcm92aWRlciA9PT0gXCJjb25zdHJ1Y3RzXCJcbiAgICAgICAgPyBcIjFcIlxuICAgICAgICA6IGltcG9ydGFibGUucHJvdmlkZXIgPT09IFwiY2RrdGZcIlxuICAgICAgICA/IFwiMlwiXG4gICAgICAgIDogXCIzXCI7XG4gICAgY29uc3QgZ3JvdXBOYW1lID0gYCR7cHJlZml4fS4ke2ltcG9ydGFibGUucHJvdmlkZXJ9LiR7bnN9YDtcbiAgICBjb25zdCBmdWxsTmFtZSA9IGAke2ltcG9ydGFibGUucHJvdmlkZXJ9LiR7bnN9LiR7aW1wb3J0YWJsZS5jb25zdHJ1Y3ROYW1lfWA7XG5cbiAgICBpZiAoYWNjW2dyb3VwTmFtZV0pIHtcbiAgICAgIGNvbnN0IGV4aXN0c0FscmVhZHkgPSBhY2NbZ3JvdXBOYW1lXS5zb21lKFxuICAgICAgICAoaW1wb3J0YWJsZSkgPT5cbiAgICAgICAgICBgJHtpbXBvcnRhYmxlLnByb3ZpZGVyfS4ke25zfS4ke2ltcG9ydGFibGUuY29uc3RydWN0TmFtZX1gID09PVxuICAgICAgICAgIGZ1bGxOYW1lXG4gICAgICApO1xuICAgICAgaWYgKGV4aXN0c0FscmVhZHkpIHtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH1cbiAgICAgIGFjY1tncm91cE5hbWVdLnB1c2goaW1wb3J0YWJsZSk7XG4gICAgICBhY2NbZ3JvdXBOYW1lXS5zb3J0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFjY1tncm91cE5hbWVdID0gW2ltcG9ydGFibGVdO1xuICAgIH1cblxuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9IGFzIFJlY29yZDxzdHJpbmcsIEltcG9ydGFibGVDb25zdHJ1Y3RbXT4pO1xuXG4gIGxldCBjb21tZW50QWRkZWQgPSBmYWxzZTtcbiAgY29uc3QgY29uc3RydWN0SW1wb3J0cyA9IE9iamVjdC5rZXlzKGdyb3VwZWRJbXBvcnRhYmxlcylcbiAgICAuc29ydCgpXG4gICAgLm1hcCgoZ3JvdXBOYW1lKSA9PiB7XG4gICAgICBjb25zdCBpbXBvcnRTdGF0ZW1lbnQgPSBwcm92aWRlckNvbnN0cnVjdEltcG9ydHMoXG4gICAgICAgIGdyb3VwZWRJbXBvcnRhYmxlc1tncm91cE5hbWVdXG4gICAgICApO1xuXG4gICAgICBpZiAoZ3JvdXBOYW1lLnN0YXJ0c1dpdGgoXCIzLlwiKSAmJiAhY29tbWVudEFkZGVkKSB7XG4gICAgICAgIGNvbW1lbnRBZGRlZCA9IHRydWU7XG4gICAgICAgIHQuYWRkQ29tbWVudChcbiAgICAgICAgICBpbXBvcnRTdGF0ZW1lbnQsXG4gICAgICAgICAgXCJsZWFkaW5nXCIsXG4gICAgICAgICAgYFxcbiogUHJvdmlkZXIgYmluZGluZ3MgYXJlIGdlbmVyYXRlZCBieSBydW5uaW5nIFxcYGNka3RmIGdldFxcYC5cbiogU2VlIGh0dHBzOi8vY2RrLnRmL3Byb3ZpZGVyLWdlbmVyYXRpb24gZm9yIG1vcmUgZGV0YWlscy5cXG5gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaW1wb3J0U3RhdGVtZW50O1xuICAgIH0pO1xuXG4gIHJldHVybiBjb25zdHJ1Y3RJbXBvcnRzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVDb25maWdUeXBlKFxuICBuYW1lOiBzdHJpbmcsXG4gIGNvbmZpZzogUmVjb3JkPHN0cmluZywgQXR0cmlidXRlUGF0aD5cbik6IHQuU3RhdGVtZW50IHtcbiAgcmV0dXJuIHQudHNJbnRlcmZhY2VEZWNsYXJhdGlvbihcbiAgICB0LmlkZW50aWZpZXIobmFtZSksXG4gICAgdW5kZWZpbmVkLFxuICAgIHVuZGVmaW5lZCxcbiAgICB0LnRzSW50ZXJmYWNlQm9keShcbiAgICAgIE9iamVjdC5lbnRyaWVzKGNvbmZpZykubWFwKChba2V5LCBfdmFsdWVdKSA9PlxuICAgICAgICB0LnRzUHJvcGVydHlTaWduYXR1cmUoXG4gICAgICAgICAgdC5pZGVudGlmaWVyKGtleSksXG4gICAgICAgICAgdC50U1R5cGVBbm5vdGF0aW9uKHQudHNBbnlLZXl3b3JkKCkpIC8vIFRPRE86IFRyeSB0byBtYWtlIHRoaXMgYmV0dGVyIHRoYW4gYW55XG4gICAgICAgIClcbiAgICAgIClcbiAgICApXG4gICk7XG59XG4iXX0=