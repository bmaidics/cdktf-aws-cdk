"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.attributeNameToCdktfName = exports.isRegistryModule = exports.convertProject = exports.getTerraformConfigFromDir = exports.convert = exports.convertToTypescript = exports.parseProviderRequirements = exports.getParsedHcl = exports.CODE_MARKER = void 0;
// Copyright (c) HashiCorp, Inc
// SPDX-License-Identifier: MPL-2.0
const hcl2json_1 = require("@cdktf/hcl2json");
const provider_generator_1 = require("@cdktf/provider-generator");
Object.defineProperty(exports, "isRegistryModule", { enumerable: true, get: function () { return provider_generator_1.isRegistryModule; } });
const t = __importStar(require("@babel/types"));
const prettier_1 = __importDefault(require("prettier"));
const path = __importStar(require("path"));
const glob = __importStar(require("glob"));
const fs = __importStar(require("fs"));
const graphology_1 = require("graphology");
const rosetta = __importStar(require("jsii-rosetta"));
const schema_1 = require("./schema");
const references_1 = require("./references");
const generation_1 = require("./generation");
const iteration_1 = require("./iteration");
const provider_1 = require("./provider");
const utils_1 = require("./utils");
const generation_2 = require("./generation");
Object.defineProperty(exports, "attributeNameToCdktfName", { enumerable: true, get: function () { return generation_2.attributeNameToCdktfName; } });
const jsii_rosetta_workarounds_1 = require("./jsii-rosetta-workarounds");
exports.CODE_MARKER = "// define resources here";
async function getParsedHcl(hcl) {
    utils_1.logger.debug(`Parsing HCL: ${hcl}`);
    // Get the JSON representation of the HCL
    let json;
    try {
        json = await (0, hcl2json_1.parse)("terraform.tf", hcl);
    }
    catch (err) {
        utils_1.logger.error(`Failed to parse HCL: ${err}`);
        throw new Error(`Error: Could not parse HCL, this means either that the HCL passed is invalid or that you found a bug. If the HCL seems valid, please file a bug under https://cdk.tf/bugs/new/convert`);
    }
    // Ensure the JSON representation matches the expected structure
    let plan;
    try {
        plan = schema_1.schema.parse(json);
    }
    catch (err) {
        throw new Error(`Error: HCL-JSON does not conform to schema. This is not expected, please file a bug under https://cdk.tf/bugs/new/convert
Please include this information:
${JSON.stringify(err.errors)}`);
    }
    return plan;
}
exports.getParsedHcl = getParsedHcl;
async function parseProviderRequirements(hcl) {
    utils_1.logger.debug("Parsing provider requirements");
    const plan = await getParsedHcl(hcl);
    return (0, provider_1.getProviderRequirements)(plan);
}
exports.parseProviderRequirements = parseProviderRequirements;
async function convertToTypescript(hcl, providerSchema, codeContainer) {
    var _a;
    utils_1.logger.debug("Converting to typescript");
    const plan = await getParsedHcl(hcl);
    // Each key in the scope needs to be unique, therefore we save them in a set
    // Each variable needs to be unique as well, we save them in a record so we can identify if two variables are the same
    const scope = {
        providerSchema,
        providerGenerator: Object.keys(providerSchema.provider_schemas || {}).reduce((carry, fqpn) => {
            const providerGenerator = new provider_generator_1.TerraformProviderGenerator(new provider_generator_1.CodeMaker(), providerSchema);
            providerGenerator.buildResourceModels(fqpn); // can't use that type on the keys yet, since we are not on TS >=4.4 yet :sadcat:
            return { ...carry, [fqpn]: providerGenerator };
        }, {}),
        constructs: new Set(),
        variables: {},
        hasTokenBasedTypeCoercion: false,
        nodeIds: [],
        importables: [],
        topLevelConfig: {},
    };
    const graph = new graphology_1.DirectedGraph();
    // Get all items in the JSON as a map of id to function that generates the AST
    // We will use this to construct the nodes for a dependency graph
    // We need to use a function here because the same node has different representation based on if it's referenced by another one
    const nodeMap = {
        ...(0, iteration_1.forEachProvider)(scope, plan.provider, generation_1.provider),
        ...(0, iteration_1.forEachGlobal)(scope, "var", plan.variable, generation_1.variable),
        // locals are a special case
        ...(0, iteration_1.forEachGlobal)(scope, "local", Array.isArray(plan.locals)
            ? plan.locals.reduce((carry, locals) => ({ ...carry, ...locals }), {})
            : {}, generation_1.local),
        ...(0, iteration_1.forEachGlobal)(scope, "out", plan.output, generation_1.output),
        ...(0, iteration_1.forEachGlobal)(scope, "module", plan.module, generation_1.modules),
        ...(0, iteration_1.forEachNamespaced)(scope, plan.resource, generation_1.resource),
        ...(0, iteration_1.forEachNamespaced)(scope, plan.data, generation_1.resource, "data"),
    };
    // Add all nodes to the dependency graph so we can detect if an edge is added for an unknown link
    Object.entries(nodeMap).forEach(([key, value]) => {
        utils_1.logger.debug(`Adding node '${key}' to graph`);
        graph.addNode(key, { code: value });
    });
    // Finding references becomes easier of the to be referenced ids are already known
    const nodeIds = Object.keys(nodeMap);
    scope.nodeIds = nodeIds;
    async function addEdges(id, value) {
        (await (0, references_1.findUsedReferences)(nodeIds, value)).forEach((ref) => {
            if (!graph.hasDirectedEdge(ref.referencee.id, id) &&
                graph.hasNode(ref.referencee.id) // in case the referencee is a dynamic variable
            ) {
                if (!graph.hasNode(id)) {
                    throw new Error(`The dependency graph is expected to link from ${ref.referencee.id} to ${id} but ${id} does not exist. 
            These nodes exist: ${graph.nodes().join("\n")}`);
                }
                // The graph should have no self-references
                if (id === ref.referencee.id) {
                    utils_1.logger.debug(`Skipping self-reference for ${id}`);
                    return;
                }
                utils_1.logger.debug(`Adding edge from ${ref.referencee.id} to ${id}`);
                graph.addDirectedEdge(ref.referencee.id, id, { ref });
            }
        });
    }
    // We recursively inspect each resource value to find references to other values
    // We add these to a dependency graph so that the programming code has the right order
    async function addGlobalEdges(_scope, _key, id, value) {
        await addEdges(id, value);
    }
    async function addProviderEdges(_scope, _key, id, value) {
        await addEdges(id, value);
    }
    async function addNamespacedEdges(_scope, _type, _key, id, value) {
        await addEdges(id, value);
    }
    await Promise.all(Object.values({
        ...(0, iteration_1.forEachProvider)(scope, plan.provider, addProviderEdges),
        ...(0, iteration_1.forEachGlobal)(scope, "var", plan.variable, addGlobalEdges),
        // locals are a special case
        ...(0, iteration_1.forEachGlobal)(scope, "local", Array.isArray(plan.locals)
            ? plan.locals.reduce((carry, locals) => ({ ...carry, ...locals }), {})
            : {}, addGlobalEdges),
        ...(0, iteration_1.forEachGlobal)(scope, "out", plan.output, addGlobalEdges),
        ...(0, iteration_1.forEachGlobal)(scope, "module", plan.module, addGlobalEdges),
        ...(0, iteration_1.forEachNamespaced)(scope, plan.resource, addNamespacedEdges),
        ...(0, iteration_1.forEachNamespaced)(scope, plan.data, addNamespacedEdges, "data"),
    }).map((addEdgesToGraph) => addEdgesToGraph(graph)));
    utils_1.logger.debug(`Graph: ${JSON.stringify(graph, null, 2)}`);
    utils_1.logger.debug(`Starting to assemble the typescript code`);
    // We traverse the dependency graph to get the unordered JSON nodes into an ordered array
    // where no node is referenced before it's defined
    // As we check that the nodes on both ends of an edge exist we can be sure
    // that no infinite loop exists, there can be no stray dependency on a node
    const expressions = [];
    let nodesToVisit = [...nodeIds];
    // This ensures we detect cycles and don't end up in an endless loop
    let nodesVisitedThisIteration = 0;
    do {
        nodesVisitedThisIteration = 0;
        // Find next nodes to visit
        const nodeExpressionGenerators = graph.mapNodes((nodeId, { code }) => {
            if (!nodesToVisit.includes(nodeId)) {
                return undefined;
            }
            const unresolvedDependencies = graph
                .inNeighbors(nodeId)
                .filter((item) => nodesToVisit.includes(item));
            if (unresolvedDependencies.length === 0) {
                nodesToVisit = nodesToVisit.filter((id) => nodeId !== id);
                nodesVisitedThisIteration = nodesVisitedThisIteration + 1;
                utils_1.logger.debug(`Visiting node ${nodeId}`);
                return code;
            }
            return undefined;
        });
        // Generate the code for the nodes
        for (const code of nodeExpressionGenerators) {
            if (code) {
                expressions.push(...(await code(graph)));
            }
        }
        utils_1.logger.debug(`${nodesToVisit.length} unvisited nodes: ${nodesToVisit.join(", ")}`);
    } while (nodesToVisit.length > 0 && nodesVisitedThisIteration != 0);
    if (nodesToVisit.length > 0) {
        throw new Error(`There are ${nodesToVisit.length} terraform elements that could not be visited. 
      This is likely due to a cycle in the dependency graph. 
      These nodes are: ${nodesToVisit.join(", ")}`);
    }
    utils_1.logger.debug(`${nodesToVisit.length} unvisited nodes: ${nodesToVisit.join(", ")}`);
    const backendExpressions = (await Promise.all(((_a = plan.terraform) === null || _a === void 0 ? void 0 : _a.map((terraform) => (0, generation_1.backendToExpression)(scope, terraform.backend))) || [Promise.resolve([])])).reduce((carry, item) => [...carry, ...item], []);
    utils_1.logger.debug(`Using these backend expressions: ${JSON.stringify(backendExpressions, null, 2)}`);
    // We collect all module sources
    const moduleRequirements = [
        ...new Set(Object.values(plan.module || {}).reduce((carry, moduleBlock) => [
            ...carry,
            ...moduleBlock.reduce((arr, { source, version }) => [
                ...arr,
                version ? `${source}@${version}` : source,
            ], []),
        ], []) || []),
    ];
    utils_1.logger.debug(`Found these modules: ${JSON.stringify(moduleRequirements, null, 2)}`);
    if (Object.keys(plan.variable || {}).length > 0 && expressions.length > 0) {
        expressions[0] = t.addComment(expressions[0], "leading", `Terraform Variables are not always the best fit for getting inputs in the context of Terraform CDK.
You can read more about this at https://cdk.tf/variables`);
    }
    const providerRequirements = (0, provider_1.getProviderRequirements)(plan);
    utils_1.logger.debug(`Found these provider requirements: ${JSON.stringify(providerRequirements, null, 2)}`);
    // We add a comment if there are providers with missing schema information
    const providersLackingSchema = Object.keys(providerRequirements).filter((providerName) => providerName !== "terraform" &&
        !Object.keys(providerSchema.provider_schemas || {}).some((schemaName) => schemaName.endsWith(providerName)));
    utils_1.logger.debug(`${providersLackingSchema.length} providers lack schema information: ${providersLackingSchema.join(", ")}`);
    if (providersLackingSchema.length > 0) {
        expressions[0] = t.addComment(expressions[0], "leading", `The following providers are missing schema information and might need manual adjustments to synthesize correctly: ${providersLackingSchema.join(", ")}.
For a more precise conversion please use the --provider flag in convert.`);
    }
    // Always add constructs
    scope.importables.push({
        constructName: "Construct",
        provider: "constructs",
    });
    if (scope.hasTokenBasedTypeCoercion) {
        scope.importables.push({
            constructName: "Token",
            provider: "cdktf",
        });
    }
    // Add specific import for codeContainer
    (0, generation_1.addImportForCodeContainer)(scope, codeContainer);
    const constructImports = (0, generation_1.buildImports)(scope.importables);
    const code = [...(backendExpressions || []), ...expressions];
    const configTypeName = Object.keys(scope.topLevelConfig).length > 0 ? "MyConfig" : undefined;
    const classConfig = configTypeName
        ? [(0, generation_1.generateConfigType)(configTypeName, scope.topLevelConfig)]
        : [];
    // We split up the generated code so that users can have more control over what to insert where
    return {
        // TODO: Remove imports and code because rosetta won't be able to translate them
        all: await (0, generation_1.gen)([
            ...constructImports,
            ...(0, generation_1.moduleImports)(plan.module),
            ...classConfig,
            (0, generation_1.wrapCodeInConstructor)(codeContainer, code, "MyConvertedCode", configTypeName),
        ]),
        imports: await (0, generation_1.gen)([...constructImports, ...(0, generation_1.moduleImports)(plan.module)]),
        code: await (0, generation_1.gen)(code),
        providers: Object.entries(providerRequirements).map(([source, version]) => version === "*" ? source : `${source}@${version}`),
        modules: moduleRequirements,
        // We track some usage data to make it easier to understand what is used
        stats: {
            numberOfModules: moduleRequirements.length,
            numberOfProviders: Object.keys(providerRequirements).length,
            resources: (0, iteration_1.resourceStats)(plan.resource || {}),
            data: (0, iteration_1.resourceStats)(plan.data || {}),
            convertedLines: hcl.split("\n").length,
        },
    };
}
exports.convertToTypescript = convertToTypescript;
const translators = {
    python: {
        visitor: () => new rosetta.PythonVisitor(),
        postTranslationMutation: jsii_rosetta_workarounds_1.replacePythonImports,
    },
    java: {
        visitor: () => new rosetta.JavaVisitor(),
        postTranslationMutation: jsii_rosetta_workarounds_1.replaceJavaImports,
    },
    csharp: {
        visitor: () => new rosetta.CSharpVisitor(),
        postTranslationMutation: jsii_rosetta_workarounds_1.replaceCsharpImports,
    },
    go: {
        visitor: () => new rosetta.GoVisitor(),
        postTranslationMutation: jsii_rosetta_workarounds_1.replaceGoImports,
    },
};
function translatorForLanguage(language) {
    return (file, throwOnTranslationError) => {
        const { visitor, postTranslationMutation } = translators[language];
        const { translation, diagnostics } = rosetta.translateTypeScript(file, visitor(), throwOnTranslationError ? { includeCompilerDiagnostics: true } : {});
        if (throwOnTranslationError &&
            diagnostics.filter((diag) => diag.isError).length > 0) {
            utils_1.logger.debug(`Could not translate TS to ${language}:\n${file.contents}`);
            throw new Error(`Could not translate TS to ${language}: ${diagnostics
                .map((diag) => diag.formattedMessage)
                .join("\n")}`);
        }
        return postTranslationMutation(translation);
    };
}
async function convert(hcl, { language, providerSchema, throwOnTranslationError = false, codeContainer = "cdktf.TerraformStack", }) {
    const fileName = "terraform.tf";
    const translater = language === "typescript"
        ? (file, _throwOnTranslationError) => file.contents
        : translatorForLanguage(language);
    if (!translater) {
        throw new Error("Unsupported language used: " + language);
    }
    const tsCode = await convertToTypescript(hcl, providerSchema, codeContainer);
    return {
        ...tsCode,
        all: translater({ fileName, contents: tsCode.all }, throwOnTranslationError),
        imports: translater({ fileName, contents: tsCode.imports }, false),
        code: translater({ fileName, contents: tsCode.code }, false),
        stats: { ...tsCode.stats, language },
    };
}
exports.convert = convert;
function getTerraformConfigFromDir(importPath) {
    const absPath = path.resolve(importPath);
    const fileContents = glob
        .sync("./*.tf", { cwd: absPath })
        .map((p) => fs.readFileSync(path.resolve(absPath, p), "utf8"));
    return fileContents.join("\n");
}
exports.getTerraformConfigFromDir = getTerraformConfigFromDir;
async function convertProject(combinedHcl, { language, providerSchema }) {
    if (language !== "typescript") {
        throw new Error("Unsupported language used: " + language);
    }
    const { imports, code, providers, modules: tfModules, stats, } = await convert(combinedHcl, {
        language,
        providerSchema,
    });
    return {
        code: (inputMainFile) => {
            const importMainFile = [imports, inputMainFile].join("\n");
            const outputMainFile = importMainFile.replace(exports.CODE_MARKER, code);
            return prettier_1.default.format(outputMainFile, { parser: "babel" });
        },
        cdktfJson: (inputCdktfJson) => {
            const cdktfJson = { ...inputCdktfJson };
            cdktfJson.terraformProviders = providers;
            cdktfJson.terraformModules = tfModules;
            return cdktfJson;
        },
        stats,
    };
}
exports.convertProject = convertProject;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJpbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLCtCQUErQjtBQUMvQixtQ0FBbUM7QUFDbkMsOENBQXdDO0FBQ3hDLGtFQUltQztBQXdqQjFCLGlHQTNqQlAscUNBQWdCLE9BMmpCTztBQXRqQnpCLGdEQUFrQztBQUNsQyx3REFBZ0M7QUFDaEMsMkNBQTZCO0FBQzdCLDJDQUE2QjtBQUM3Qix1Q0FBeUI7QUFDekIsMkNBQTJDO0FBQzNDLHNEQUF3QztBQUd4QyxxQ0FBa0M7QUFDbEMsNkNBQWtEO0FBQ2xELDZDQWNzQjtBQUV0QiwyQ0FLcUI7QUFDckIseUNBQXFEO0FBQ3JELG1DQUFpQztBQUVqQyw2Q0FBd0Q7QUFraEI3Qix5R0FsaEJsQixxQ0FBd0IsT0FraEJrQjtBQWpoQm5ELHlFQUtvQztBQUd2QixRQUFBLFdBQVcsR0FBRywwQkFBMEIsQ0FBQztBQUUvQyxLQUFLLFVBQVUsWUFBWSxDQUFDLEdBQVc7SUFDNUMsY0FBTSxDQUFDLEtBQUssQ0FBQyxnQkFBZ0IsR0FBRyxFQUFFLENBQUMsQ0FBQztJQUNwQyx5Q0FBeUM7SUFDekMsSUFBSSxJQUE2QixDQUFDO0lBQ2xDLElBQUk7UUFDRixJQUFJLEdBQUcsTUFBTSxJQUFBLGdCQUFLLEVBQUMsY0FBYyxFQUFFLEdBQUcsQ0FBQyxDQUFDO0tBQ3pDO0lBQUMsT0FBTyxHQUFHLEVBQUU7UUFDWixjQUFNLENBQUMsS0FBSyxDQUFDLHdCQUF3QixHQUFHLEVBQUUsQ0FBQyxDQUFDO1FBQzVDLE1BQU0sSUFBSSxLQUFLLENBQ2IsdUxBQXVMLENBQ3hMLENBQUM7S0FDSDtJQUVELGdFQUFnRTtJQUNoRSxJQUFJLElBQTRCLENBQUM7SUFDakMsSUFBSTtRQUNGLElBQUksR0FBRyxlQUFNLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDO0tBQzNCO0lBQUMsT0FBTyxHQUFH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RCw4REFPQztBQU1NLEtBQUssVUFBVSxjQUFjLENBQ2xDLFdBQW1CLEVBQ25CLEVBQUUsUUFBUSxFQUFFLGNBQWMsRUFBa0I7SUFFNUMsSUFBSSxRQUFRLEtBQUssWUFBWSxFQUFFO1FBQzdCLE1BQU0sSUFBSSxLQUFLLENBQUMsNkJBQTZCLEdBQUcsUUFBUSxDQUFDLENBQUM7S0FDM0Q7SUFFRCxNQUFNLEVBQ0osT0FBTyxFQUNQLElBQUksRUFDSixTQUFTLEVBQ1QsT0FBTyxFQUFFLFNBQVMsRUFDbEIsS0FBSyxHQUNOLEdBQUcsTUFBTSxPQUFPLENBQUMsV0FBVyxFQUFFO1FBQzdCLFFBQVE7UUFDUixjQUFjO0tBQ2YsQ0FBQyxDQUFDO0lBRUgsT0FBTztRQUNMLElBQUksRUFBRSxDQUFDLGFBQXFCLEVBQUUsRUFBRTtZQUM5QixNQUFNLGNBQWMsR0FBRyxDQUFDLE9BQU8sRUFBRSxhQUFhLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7WUFDM0QsTUFBTSxjQUFjLEdBQUcsY0FBYyxDQUFDLE9BQU8sQ0FBQyxtQkFBVyxFQUFFLElBQUksQ0FBQyxDQUFDO1lBQ2pFLE9BQU8sa0JBQVEsQ0FBQyxNQUFNLENBQUMsY0FBYyxFQUFFLEVBQUUsTUFBTSxFQUFFLE9BQU8sRUFBRSxDQUFDLENBQUM7UUFDOUQsQ0FBQztRQUNELFNBQVMsRUFBRSxDQUFDLGNBQXlCLEVBQUUsRUFBRTtZQUN2QyxNQUFNLFNBQVMsR0FBRyxFQUFFLEdBQUcsY0FBYyxFQUFFLENBQUM7WUFDeEMsU0FBUyxDQUFDLGtCQUFrQixHQUFHLFNBQVMsQ0FBQztZQUN6QyxTQUFTLENBQUMsZ0JBQWdCLEdBQUcsU0FBUyxDQUFDO1lBQ3ZDLE9BQU8sU0FBUyxDQUFDO1FBQ25CLENBQUM7UUFDRCxLQUFLO0tBQ04sQ0FBQztBQUNKLENBQUM7QUFqQ0Qsd0NBaUNDIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSBIYXNoaUNvcnAsIEluY1xuLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1QTC0yLjBcbmltcG9ydCB7IHBhcnNlIH0gZnJvbSBcIkBjZGt0Zi9oY2wyanNvblwiO1xuaW1wb3J0IHtcbiAgaXNSZWdpc3RyeU1vZHVsZSxcbiAgVGVycmFmb3JtUHJvdmlkZXJHZW5lcmF0b3IsXG4gIENvZGVNYWtlcixcbn0gZnJvbSBcIkBjZGt0Zi9wcm92aWRlci1nZW5lcmF0b3JcIjtcblxuaW1wb3J0ICogYXMgdCBmcm9tIFwiQGJhYmVsL3R5cGVzXCI7XG5pbXBvcnQgcHJldHRpZXIgZnJvbSBcInByZXR0aWVyXCI7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gXCJwYXRoXCI7XG5pbXBvcnQgKiBhcyBnbG9iIGZyb20gXCJnbG9iXCI7XG5pbXBvcnQgKiBhcyBmcyBmcm9tIFwiZnNcIjtcbmltcG9ydCB7IERpcmVjdGVkR3JhcGggfSBmcm9tIFwiZ3JhcGhvbG9neVwiO1xuaW1wb3J0ICogYXMgcm9zZXR0YSBmcm9tIFwianNpaS1yb3NldHRhXCI7XG5pbXBvcnQgKiBhcyB6IGZyb20gXCJ6b2RcIjtcblxuaW1wb3J0IHsgc2NoZW1hIH0gZnJvbSBcIi4vc2NoZW1hXCI7XG5pbXBvcnQgeyBmaW5kVXNlZFJlZmVyZW5jZXMgfSBmcm9tIFwiLi9yZWZlcmVuY2VzXCI7XG5pbXBvcnQge1xuICBiYWNrZW5kVG9FeHByZXNzaW9uLFxuICBnZW4sXG4gIGxvY2FsLFxuICBtb2R1bGVJbXBvcnRzLFxuICBtb2R1bGVzLFxuICBvdXRwdXQsXG4gIHByb3ZpZGVyLFxuICByZXNvdXJjZSxcbiAgdmFyaWFibGUsXG4gIHdyYXBDb2RlSW5Db25zdHJ1Y3RvcixcbiAgYWRkSW1wb3J0Rm9yQ29kZUNvbnRhaW5lcixcbiAgYnVpbGRJbXBvcnRzLFxuICBnZW5lcmF0ZUNvbmZpZ1R5cGUsXG59IGZyb20gXCIuL2dlbmVyYXRpb25cIjtcbmltcG9ydCB7IFRlcnJhZm9ybVJlc291cmNlQmxvY2ssIFByb2dyYW1TY29wZSB9IGZyb20gXCIuL3R5cGVzXCI7XG5pbXBvcnQge1xuICBmb3JFYWNoUHJvdmlkZXIsXG4gIGZvckVhY2hHbG9iYWwsXG4gIGZvckVhY2hOYW1lc3BhY2VkLFxuICByZXNvdXJjZVN0YXRzLFxufSBmcm9tIFwiLi9pdGVyYXRpb25cIjtcbmltcG9ydCB7IGdldFByb3ZpZGVyUmVxdWlyZW1lbnRzIH0gZnJvbSBcIi4vcHJvdmlkZXJcIjtcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gXCIuL3V0aWxzXCI7XG5pbXBvcnQgeyBGUVBOIH0gZnJvbSBcIkBjZGt0Zi9wcm92aWRlci1zY2hlbWFcIjtcbmltcG9ydCB7IGF0dHJpYnV0ZU5hbWVUb0Nka3RmTmFtZSB9IGZyb20gXCIuL2dlbmVyYXRpb25cIjtcbmltcG9ydCB7XG4gIHJlcGxhY2VDc2hhcnBJbXBvcnRzLFxuICByZXBsYWNlR29JbXBvcnRzLFxuICByZXBsYWNlSmF2YUltcG9ydHMsXG4gIHJlcGxhY2VQeXRob25JbXBvcnRzLFxufSBmcm9tIFwiLi9qc2lpLXJvc2V0dGEtd29ya2Fyb3VuZHNcIjtcbmltcG9ydCB7IFByb3ZpZGVyU2NoZW1hIH0gZnJvbSBcIkBjZGt0Zi9jb21tb25zXCI7XG5cbmV4cG9ydCBjb25zdCBDT0RFX01BUktFUiA9IFwiLy8gZGVmaW5lIHJlc291cmNlcyBoZXJlXCI7XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRQYXJzZWRIY2woaGNsOiBzdHJpbmcpIHtcbiAgbG9nZ2VyLmRlYnVnKGBQYXJzaW5nIEhDTDogJHtoY2x9YCk7XG4gIC8vIEdldCB0aGUgSlNPTiByZXByZXNlbnRhdGlvbiBvZiB0aGUgSENMXG4gIGxldCBqc29uOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcbiAgdHJ5IHtcbiAgICBqc29uID0gYXdhaXQgcGFyc2UoXCJ0ZXJyYWZvcm0udGZcIiwgaGNsKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgbG9nZ2VyLmVycm9yKGBGYWlsZWQgdG8gcGFyc2UgSENMOiAke2Vycn1gKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgRXJyb3I6IENvdWxkIG5vdCBwYXJzZSBIQ0wsIHRoaXMgbWVhbnMgZWl0aGVyIHRoYXQgdGhlIEhDTCBwYXNzZWQgaXMgaW52YWxpZCBvciB0aGF0IHlvdSBmb3VuZCBhIGJ1Zy4gSWYgdGhlIEhDTCBzZWVtcyB2YWxpZCwgcGxlYXNlIGZpbGUgYSBidWcgdW5kZXIgaHR0cHM6Ly9jZGsudGYvYnVncy9uZXcvY29udmVydGBcbiAgICApO1xuICB9XG5cbiAgLy8gRW5zdXJlIHRoZSBKU09OIHJlcHJlc2VudGF0aW9uIG1hdGNoZXMgdGhlIGV4cGVjdGVkIHN0cnVjdHVyZVxuICBsZXQgcGxhbjogei5pbmZlcjx0eXBlb2Ygc2NoZW1hPjtcbiAgdHJ5IHtcbiAgICBwbGFuID0gc2NoZW1hLnBhcnNlKGpzb24pO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yOiBIQ0wtSlNPTiBkb2VzIG5vdCBjb25mb3JtIHRvIHNjaGVtYS4gVGhpcyBpcyBub3QgZXhwZWN0ZWQsIHBsZWFzZSBmaWxlIGEgYnVnIHVuZGVyIGh0dHBzOi8vY2RrLnRmL2J1Z3MvbmV3L2NvbnZlcnRcblBsZWFzZSBpbmNsdWRlIHRoaXMgaW5mb3JtYXRpb246XG4ke0pTT04uc3RyaW5naWZ5KChlcnIgYXMgei5ab2RFcnJvcikuZXJyb3JzKX1gKTtcbiAgfVxuXG4gIHJldHVybiBwbGFuO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcGFyc2VQcm92aWRlclJlcXVpcmVtZW50cyhoY2w6IHN0cmluZykge1xuICBsb2dnZXIuZGVidWcoXCJQYXJzaW5nIHByb3ZpZGVyIHJlcXVpcmVtZW50c1wiKTtcbiAgY29uc3QgcGxhbiA9IGF3YWl0IGdldFBhcnNlZEhjbChoY2wpO1xuICByZXR1cm4gZ2V0UHJvdmlkZXJSZXF1aXJlbWVudHMocGxhbik7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjb252ZXJ0VG9UeXBlc2NyaXB0KFxuICBoY2w6IHN0cmluZyxcbiAgcHJvdmlkZXJTY2hlbWE6IFByb3ZpZGVyU2NoZW1hLFxuICBjb2RlQ29udGFpbmVyOiBzdHJpbmdcbikge1xuICBsb2dnZXIuZGVidWcoXCJDb252ZXJ0aW5nIHRvIHR5cGVzY3JpcHRcIik7XG4gIGNvbnN0IHBsYW4gPSBhd2FpdCBnZXRQYXJzZWRIY2woaGNsKTtcblxuICAvLyBFYWNoIGtleSBpbiB0aGUgc2NvcGUgbmVlZHMgdG8gYmUgdW5pcXVlLCB0aGVyZWZvcmUgd2Ugc2F2ZSB0aGVtIGluIGEgc2V0XG4gIC8vIEVhY2ggdmFyaWFibGUgbmVlZHMgdG8gYmUgdW5pcXVlIGFzIHdlbGwsIHdlIHNhdmUgdGhlbSBpbiBhIHJlY29yZCBzbyB3ZSBjYW4gaWRlbnRpZnkgaWYgdHdvIHZhcmlhYmxlcyBhcmUgdGhlIHNhbWVcbiAgY29uc3Qgc2NvcGU6IFByb2dyYW1TY29wZSA9IHtcbiAgICBwcm92aWRlclNjaGVtYSxcbiAgICBwcm92aWRlckdlbmVyYXRvcjogT2JqZWN0LmtleXMoXG4gICAgICBwcm92aWRlclNjaGVtYS5wcm92aWRlcl9zY2hlbWFzIHx8IHt9XG4gICAgKS5yZWR1Y2UoKGNhcnJ5LCBmcXBuKSA9PiB7XG4gICAgICBjb25zdCBwcm92aWRlckdlbmVyYXRvciA9IG5ldyBUZXJyYWZvcm1Qcm92aWRlckdlbmVyYXRvcihcbiAgICAgICAgbmV3IENvZGVNYWtlcigpLFxuICAgICAgICBwcm92aWRlclNjaGVtYVxuICAgICAgKTtcbiAgICAgIHByb3ZpZGVyR2VuZXJhdG9yLmJ1aWxkUmVzb3VyY2VNb2RlbHMoZnFwbiBhcyBGUVBOKTsgLy8gY2FuJ3QgdXNlIHRoYXQgdHlwZSBvbiB0aGUga2V5cyB5ZXQsIHNpbmNlIHdlIGFyZSBub3Qgb24gVFMgPj00LjQgeWV0IDpzYWRjYXQ6XG4gICAgICByZXR1cm4geyAuLi5jYXJyeSwgW2ZxcG5dOiBwcm92aWRlckdlbmVyYXRvciB9O1xuICAgIH0sIHt9KSxcbiAgICBjb25zdHJ1Y3RzOiBuZXcgU2V0PHN0cmluZz4oKSxcbiAgICB2YXJpYWJsZXM6IHt9LFxuICAgIGhhc1Rva2VuQmFzZWRUeXBlQ29lcmNpb246IGZhbHNlLFxuICAgIG5vZGVJZHM6IFtdLFxuICAgIGltcG9ydGFibGVzOiBbXSxcbiAgICB0b3BMZXZlbENvbmZpZzoge30sXG4gIH07XG5cbiAgY29uc3QgZ3JhcGggPSBuZXcgRGlyZWN0ZWRHcmFwaDx7XG4gICAgY29kZTogKFxuICAgICAgZzogRGlyZWN0ZWRHcmFwaDxhbnk+XG4gICAgKSA9PiBQcm9taXNlPEFycmF5PHQuU3RhdGVtZW50IHwgdC5WYXJpYWJsZURlY2xhcmF0aW9uPj47XG4gIH0+KCk7XG5cbiAgLy8gR2V0IGFsbCBpdGVtcyBpbiB0aGUgSlNPTiBhcyBhIG1hcCBvZiBpZCB0byBmdW5jdGlvbiB0aGF0IGdlbmVyYXRlcyB0aGUgQVNUXG4gIC8vIFdlIHdpbGwgdXNlIHRoaXMgdG8gY29uc3RydWN0IHRoZSBub2RlcyBmb3IgYSBkZXBlbmRlbmN5IGdyYXBoXG4gIC8vIFdlIG5lZWQgdG8gdXNlIGEgZnVuY3Rpb24gaGVyZSBiZWNhdXNlIHRoZSBzYW1lIG5vZGUgaGFzIGRpZmZlcmVudCByZXByZXNlbnRhdGlvbiBiYXNlZCBvbiBpZiBpdCdzIHJlZmVyZW5jZWQgYnkgYW5vdGhlciBvbmVcbiAgY29uc3Qgbm9kZU1hcDogUmVjb3JkPFxuICAgIHN0cmluZyxcbiAgICAoZzogdHlwZW9mIGdyYXBoKSA9PiBQcm9taXNlPEFycmF5PHQuU3RhdGVtZW50IHwgdC5WYXJpYWJsZURlY2xhcmF0aW9uPj5cbiAgPiA9IHtcbiAgICAuLi5mb3JFYWNoUHJvdmlkZXIoc2NvcGUsIHBsYW4ucHJvdmlkZXIsIHByb3ZpZGVyKSxcbiAgICAuLi5mb3JFYWNoR2xvYmFsKHNjb3BlLCBcInZhclwiLCBwbGFuLnZhcmlhYmxlLCB2YXJpYWJsZSksXG4gICAgLy8gbG9jYWxzIGFyZSBhIHNwZWNpYWwgY2FzZVxuICAgIC4uLmZvckVhY2hHbG9iYWwoXG4gICAgICBzY29wZSxcbiAgICAgIFwibG9jYWxcIixcbiAgICAgIEFycmF5LmlzQXJyYXkocGxhbi5sb2NhbHMpXG4gICAgICAgID8gcGxhbi5sb2NhbHMucmVkdWNlKChjYXJyeSwgbG9jYWxzKSA9PiAoeyAuLi5jYXJyeSwgLi4ubG9jYWxzIH0pLCB7fSlcbiAgICAgICAgOiB7fSxcbiAgICAgIGxvY2FsXG4gICAgKSxcbiAgICAuLi5mb3JFYWNoR2xvYmFsKHNjb3BlLCBcIm91dFwiLCBwbGFuLm91dHB1dCwgb3V0cHV0KSxcbiAgICAuLi5mb3JFYWNoR2xvYmFsKHNjb3BlLCBcIm1vZHVsZVwiLCBwbGFuLm1vZHVsZSwgbW9kdWxlcyksXG4gICAgLi4uZm9yRWFjaE5hbWVzcGFjZWQoc2NvcGUsIHBsYW4ucmVzb3VyY2UsIHJlc291cmNlKSxcbiAgICAuLi5mb3JFYWNoTmFtZXNwYWNlZChzY29wZSwgcGxhbi5kYXRhLCByZXNvdXJjZSwgXCJkYXRhXCIpLFxuICB9O1xuXG4gIC8vIEFkZCBhbGwgbm9kZXMgdG8gdGhlIGRlcGVuZGVuY3kgZ3JhcGggc28gd2UgY2FuIGRldGVjdCBpZiBhbiBlZGdlIGlzIGFkZGVkIGZvciBhbiB1bmtub3duIGxpbmtcbiAgT2JqZWN0LmVudHJpZXMobm9kZU1hcCkuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgbG9nZ2VyLmRlYnVnKGBBZGRpbmcgbm9kZSAnJHtrZXl9JyB0byBncmFwaGApO1xuICAgIGdyYXBoLmFkZE5vZGUoa2V5LCB7IGNvZGU6IHZhbHVlIH0pO1xuICB9KTtcblxuICAvLyBGaW5kaW5nIHJlZmVyZW5jZXMgYmVjb21lcyBlYXNpZXIgb2YgdGhlIHRvIGJlIHJlZmVyZW5jZWQgaWRzIGFyZSBhbHJlYWR5IGtub3duXG4gIGNvbnN0IG5vZGVJZHMgPSBPYmplY3Qua2V5cyhub2RlTWFwKTtcbiAgc2NvcGUubm9kZUlkcyA9IG5vZGVJZHM7XG4gIGFzeW5jIGZ1bmN0aW9uIGFkZEVkZ2VzKGlkOiBzdHJpbmcsIHZhbHVlOiBUZXJyYWZvcm1SZXNvdXJjZUJsb2NrKSB7XG4gICAgKGF3YWl0IGZpbmRVc2VkUmVmZXJlbmNlcyhub2RlSWRzLCB2YWx1ZSkpLmZvckVhY2goKHJlZikgPT4ge1xuICAgICAgaWYgKFxuICAgICAgICAhZ3JhcGguaGFzRGlyZWN0ZWRFZGdlKHJlZi5yZWZlcmVuY2VlLmlkLCBpZCkgJiZcbiAgICAgICAgZ3JhcGguaGFzTm9kZShyZWYucmVmZXJlbmNlZS5pZCkgLy8gaW4gY2FzZSB0aGUgcmVmZXJlbmNlZSBpcyBhIGR5bmFtaWMgdmFyaWFibGVcbiAgICAgICkge1xuICAgICAgICBpZiAoIWdyYXBoLmhhc05vZGUoaWQpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYFRoZSBkZXBlbmRlbmN5IGdyYXBoIGlzIGV4cGVjdGVkIHRvIGxpbmsgZnJvbSAke1xuICAgICAgICAgICAgICByZWYucmVmZXJlbmNlZS5pZFxuICAgICAgICAgICAgfSB0byAke2lkfSBidXQgJHtpZH0gZG9lcyBub3QgZXhpc3QuIFxuICAgICAgICAgICAgVGhlc2Ugbm9kZXMgZXhpc3Q6ICR7Z3JhcGgubm9kZXMoKS5qb2luKFwiXFxuXCIpfWBcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIGdyYXBoIHNob3VsZCBoYXZlIG5vIHNlbGYtcmVmZXJlbmNlc1xuICAgICAgICBpZiAoaWQgPT09IHJlZi5yZWZlcmVuY2VlLmlkKSB7XG4gICAgICAgICAgbG9nZ2VyLmRlYnVnKGBTa2lwcGluZyBzZWxmLXJlZmVyZW5jZSBmb3IgJHtpZH1gKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBsb2dnZXIuZGVidWcoYEFkZGluZyBlZGdlIGZyb20gJHtyZWYucmVmZXJlbmNlZS5pZH0gdG8gJHtpZH1gKTtcbiAgICAgICAgZ3JhcGguYWRkRGlyZWN0ZWRFZGdlKHJlZi5yZWZlcmVuY2VlLmlkLCBpZCwgeyByZWYgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvLyBXZSByZWN1cnNpdmVseSBpbnNwZWN0IGVhY2ggcmVzb3VyY2UgdmFsdWUgdG8gZmluZCByZWZlcmVuY2VzIHRvIG90aGVyIHZhbHVlc1xuICAvLyBXZSBhZGQgdGhlc2UgdG8gYSBkZXBlbmRlbmN5IGdyYXBoIHNvIHRoYXQgdGhlIHByb2dyYW1taW5nIGNvZGUgaGFzIHRoZSByaWdodCBvcmRlclxuICBhc3luYyBmdW5jdGlvbiBhZGRHbG9iYWxFZGdlcyhcbiAgICBfc2NvcGU6IFByb2dyYW1TY29wZSxcbiAgICBfa2V5OiBzdHJpbmcsXG4gICAgaWQ6IHN0cmluZyxcbiAgICB2YWx1ZTogVGVycmFmb3JtUmVzb3VyY2VCbG9ja1xuICApIHtcbiAgICBhd2FpdCBhZGRFZGdlcyhpZCwgdmFsdWUpO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGFkZFByb3ZpZGVyRWRnZXMoXG4gICAgX3Njb3BlOiBQcm9ncmFtU2NvcGUsXG4gICAgX2tleTogc3RyaW5nLFxuICAgIGlkOiBzdHJpbmcsXG4gICAgdmFsdWU6IFRlcnJhZm9ybVJlc291cmNlQmxvY2tcbiAgKSB7XG4gICAgYXdhaXQgYWRkRWRnZXMoaWQsIHZhbHVlKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBhZGROYW1lc3BhY2VkRWRnZXMoXG4gICAgX3Njb3BlOiBQcm9ncmFtU2NvcGUsXG4gICAgX3R5cGU6IHN0cmluZyxcbiAgICBfa2V5OiBzdHJpbmcsXG4gICAgaWQ6IHN0cmluZyxcbiAgICB2YWx1ZTogVGVycmFmb3JtUmVzb3VyY2VCbG9ja1xuICApIHtcbiAgICBhd2FpdCBhZGRFZGdlcyhpZCwgdmFsdWUpO1xuICB9XG5cbiAgYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgT2JqZWN0LnZhbHVlcyh7XG4gICAgICAuLi5mb3JFYWNoUHJvdmlkZXIoc2NvcGUsIHBsYW4ucHJvdmlkZXIsIGFkZFByb3ZpZGVyRWRnZXMpLFxuICAgICAgLi4uZm9yRWFjaEdsb2JhbChzY29wZSwgXCJ2YXJcIiwgcGxhbi52YXJpYWJsZSwgYWRkR2xvYmFsRWRnZXMpLFxuICAgICAgLy8gbG9jYWxzIGFyZSBhIHNwZWNpYWwgY2FzZVxuICAgICAgLi4uZm9yRWFjaEdsb2JhbChcbiAgICAgICAgc2NvcGUsXG4gICAgICAgIFwibG9jYWxcIixcbiAgICAgICAgQXJyYXkuaXNBcnJheShwbGFuLmxvY2FscylcbiAgICAgICAgICA/IHBsYW4ubG9jYWxzLnJlZHVjZSgoY2FycnksIGxvY2FscykgPT4gKHsgLi4uY2FycnksIC4uLmxvY2FscyB9KSwge30pXG4gICAgICAgICAgOiB7fSxcbiAgICAgICAgYWRkR2xvYmFsRWRnZXNcbiAgICAgICksXG4gICAgICAuLi5mb3JFYWNoR2xvYmFsKHNjb3BlLCBcIm91dFwiLCBwbGFuLm91dHB1dCwgYWRkR2xvYmFsRWRnZXMpLFxuICAgICAgLi4uZm9yRWFjaEdsb2JhbChzY29wZSwgXCJtb2R1bGVcIiwgcGxhbi5tb2R1bGUsIGFkZEdsb2JhbEVkZ2VzKSxcbiAgICAgIC4uLmZvckVhY2hOYW1lc3BhY2VkKHNjb3BlLCBwbGFuLnJlc291cmNlLCBhZGROYW1lc3BhY2VkRWRnZXMpLFxuICAgICAgLi4uZm9yRWFjaE5hbWVzcGFjZWQoc2NvcGUsIHBsYW4uZGF0YSwgYWRkTmFtZXNwYWNlZEVkZ2VzLCBcImRhdGFcIiksXG4gICAgfSkubWFwKChhZGRFZGdlc1RvR3JhcGgpID0+IGFkZEVkZ2VzVG9HcmFwaChncmFwaCkpXG4gICk7XG5cbiAgbG9nZ2VyLmRlYnVnKGBHcmFwaDogJHtKU09OLnN0cmluZ2lmeShncmFwaCwgbnVsbCwgMil9YCk7XG4gIGxvZ2dlci5kZWJ1ZyhgU3RhcnRpbmcgdG8gYXNzZW1ibGUgdGhlIHR5cGVzY3JpcHQgY29kZWApO1xuICAvLyBXZSB0cmF2ZXJzZSB0aGUgZGVwZW5kZW5jeSBncmFwaCB0byBnZXQgdGhlIHVub3JkZXJlZCBKU09OIG5vZGVzIGludG8gYW4gb3JkZXJlZCBhcnJheVxuICAvLyB3aGVyZSBubyBub2RlIGlzIHJlZmVyZW5jZWQgYmVmb3JlIGl0J3MgZGVmaW5lZFxuICAvLyBBcyB3ZSBjaGVjayB0aGF0IHRoZSBub2RlcyBvbiBib3RoIGVuZHMgb2YgYW4gZWRnZSBleGlzdCB3ZSBjYW4gYmUgc3VyZVxuICAvLyB0aGF0IG5vIGluZmluaXRlIGxvb3AgZXhpc3RzLCB0aGVyZSBjYW4gYmUgbm8gc3RyYXkgZGVwZW5kZW5jeSBvbiBhIG5vZGVcbiAgY29uc3QgZXhwcmVzc2lvbnM6IHQuU3RhdGVtZW50W10gPSBbXTtcbiAgbGV0IG5vZGVzVG9WaXNpdCA9IFsuLi5ub2RlSWRzXTtcbiAgLy8gVGhpcyBlbnN1cmVzIHdlIGRldGVjdCBjeWNsZXMgYW5kIGRvbid0IGVuZCB1cCBpbiBhbiBlbmRsZXNzIGxvb3BcbiAgbGV0IG5vZGVzVmlzaXRlZFRoaXNJdGVyYXRpb24gPSAwO1xuICBkbyB7XG4gICAgbm9kZXNWaXNpdGVkVGhpc0l0ZXJhdGlvbiA9IDA7XG5cbiAgICAvLyBGaW5kIG5leHQgbm9kZXMgdG8gdmlzaXRcbiAgICBjb25zdCBub2RlRXhwcmVzc2lvbkdlbmVyYXRvcnMgPSBncmFwaC5tYXBOb2Rlcygobm9kZUlkLCB7IGNvZGUgfSkgPT4ge1xuICAgICAgaWYgKCFub2Rlc1RvVmlzaXQuaW5jbHVkZXMobm9kZUlkKSkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB1bnJlc29sdmVkRGVwZW5kZW5jaWVzID0gZ3JhcGhcbiAgICAgICAgLmluTmVpZ2hib3JzKG5vZGVJZClcbiAgICAgICAgLmZpbHRlcigoaXRlbSkgPT4gbm9kZXNUb1Zpc2l0LmluY2x1ZGVzKGl0ZW0pKTtcblxuICAgICAgaWYgKHVucmVzb2x2ZWREZXBlbmRlbmNpZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIG5vZGVzVG9WaXNpdCA9IG5vZGVzVG9WaXNpdC5maWx0ZXIoKGlkKSA9PiBub2RlSWQgIT09IGlkKTtcbiAgICAgICAgbm9kZXNWaXNpdGVkVGhpc0l0ZXJhdGlvbiA9IG5vZGVzVmlzaXRlZFRoaXNJdGVyYXRpb24gKyAxO1xuXG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhgVmlzaXRpbmcgbm9kZSAke25vZGVJZH1gKTtcbiAgICAgICAgcmV0dXJuIGNvZGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0pO1xuXG4gICAgLy8gR2VuZXJhdGUgdGhlIGNvZGUgZm9yIHRoZSBub2Rlc1xuICAgIGZvciAoY29uc3QgY29kZSBvZiBub2RlRXhwcmVzc2lvbkdlbmVyYXRvcnMpIHtcbiAgICAgIGlmIChjb2RlKSB7XG4gICAgICAgIGV4cHJlc3Npb25zLnB1c2goLi4uKGF3YWl0IGNvZGUoZ3JhcGgpKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbG9nZ2VyLmRlYnVnKFxuICAgICAgYCR7bm9kZXNUb1Zpc2l0Lmxlbmd0aH0gdW52aXNpdGVkIG5vZGVzOiAke25vZGVzVG9WaXNpdC5qb2luKFwiLCBcIil9YFxuICAgICk7XG4gIH0gd2hpbGUgKG5vZGVzVG9WaXNpdC5sZW5ndGggPiAwICYmIG5vZGVzVmlzaXRlZFRoaXNJdGVyYXRpb24gIT0gMCk7XG5cbiAgaWYgKG5vZGVzVG9WaXNpdC5sZW5ndGggPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYFRoZXJlIGFyZSAke1xuICAgICAgICBub2Rlc1RvVmlzaXQubGVuZ3RoXG4gICAgICB9IHRlcnJhZm9ybSBlbGVtZW50cyB0aGF0IGNvdWxkIG5vdCBiZSB2aXNpdGVkLiBcbiAgICAgIFRoaXMgaXMgbGlrZWx5IGR1ZSB0byBhIGN5Y2xlIGluIHRoZSBkZXBlbmRlbmN5IGdyYXBoLiBcbiAgICAgIFRoZXNlIG5vZGVzIGFyZTogJHtub2Rlc1RvVmlzaXQuam9pbihcIiwgXCIpfWBcbiAgICApO1xuICB9XG5cbiAgbG9nZ2VyLmRlYnVnKFxuICAgIGAke25vZGVzVG9WaXNpdC5sZW5ndGh9IHVudmlzaXRlZCBub2RlczogJHtub2Rlc1RvVmlzaXQuam9pbihcIiwgXCIpfWBcbiAgKTtcblxuICBjb25zdCBiYWNrZW5kRXhwcmVzc2lvbnMgPSAoXG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICBwbGFuLnRlcnJhZm9ybT8ubWFwKCh0ZXJyYWZvcm0pID0+XG4gICAgICAgIGJhY2tlbmRUb0V4cHJlc3Npb24oc2NvcGUsIHRlcnJhZm9ybS5iYWNrZW5kKVxuICAgICAgKSB8fCBbUHJvbWlzZS5yZXNvbHZlKFtdKV1cbiAgICApXG4gICkucmVkdWNlKChjYXJyeSwgaXRlbSkgPT4gWy4uLmNhcnJ5LCAuLi5pdGVtXSwgW10pO1xuXG4gIGxvZ2dlci5kZWJ1ZyhcbiAgICBgVXNpbmcgdGhlc2UgYmFja2VuZCBleHByZXNzaW9uczogJHtKU09OLnN0cmluZ2lmeShcbiAgICAgIGJhY2tlbmRFeHByZXNzaW9ucyxcbiAgICAgIG51bGwsXG4gICAgICAyXG4gICAgKX1gXG4gICk7XG5cbiAgLy8gV2UgY29sbGVjdCBhbGwgbW9kdWxlIHNvdXJjZXNcbiAgY29uc3QgbW9kdWxlUmVxdWlyZW1lbnRzID0gW1xuICAgIC4uLm5ldyBTZXQoXG4gICAgICBPYmplY3QudmFsdWVzKHBsYW4ubW9kdWxlIHx8IHt9KS5yZWR1Y2UoXG4gICAgICAgIChjYXJyeSwgbW9kdWxlQmxvY2spID0+IFtcbiAgICAgICAgICAuLi5jYXJyeSxcbiAgICAgICAgICAuLi5tb2R1bGVCbG9jay5yZWR1Y2UoXG4gICAgICAgICAgICAoYXJyLCB7IHNvdXJjZSwgdmVyc2lvbiB9KSA9PiBbXG4gICAgICAgICAgICAgIC4uLmFycixcbiAgICAgICAgICAgICAgdmVyc2lvbiA/IGAke3NvdXJjZX1AJHt2ZXJzaW9ufWAgOiBzb3VyY2UsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgW10gYXMgc3RyaW5nW11cbiAgICAgICAgICApLFxuICAgICAgICBdLFxuICAgICAgICBbXSBhcyBzdHJpbmdbXVxuICAgICAgKSB8fCBbXVxuICAgICksXG4gIF07XG5cbiAgbG9nZ2VyLmRlYnVnKFxuICAgIGBGb3VuZCB0aGVzZSBtb2R1bGVzOiAke0pTT04uc3RyaW5naWZ5KG1vZHVsZVJlcXVpcmVtZW50cywgbnVsbCwgMil9YFxuICApO1xuXG4gIGlmIChPYmplY3Qua2V5cyhwbGFuLnZhcmlhYmxlIHx8IHt9KS5sZW5ndGggPiAwICYmIGV4cHJlc3Npb25zLmxlbmd0aCA+IDApIHtcbiAgICBleHByZXNzaW9uc1swXSA9IHQuYWRkQ29tbWVudChcbiAgICAgIGV4cHJlc3Npb25zWzBdLFxuICAgICAgXCJsZWFkaW5nXCIsXG4gICAgICBgVGVycmFmb3JtIFZhcmlhYmxlcyBhcmUgbm90IGFsd2F5cyB0aGUgYmVzdCBmaXQgZm9yIGdldHRpbmcgaW5wdXRzIGluIHRoZSBjb250ZXh0IG9mIFRlcnJhZm9ybSBDREsuXG5Zb3UgY2FuIHJlYWQgbW9yZSBhYm91dCB0aGlzIGF0IGh0dHBzOi8vY2RrLnRmL3ZhcmlhYmxlc2BcbiAgICApO1xuICB9XG5cbiAgY29uc3QgcHJvdmlkZXJSZXF1aXJlbWVudHMgPSBnZXRQcm92aWRlclJlcXVpcmVtZW50cyhwbGFuKTtcbiAgbG9nZ2VyLmRlYnVnKFxuICAgIGBGb3VuZCB0aGVzZSBwcm92aWRlciByZXF1aXJlbWVudHM6ICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICBwcm92aWRlclJlcXVpcmVtZW50cyxcbiAgICAgIG51bGwsXG4gICAgICAyXG4gICAgKX1gXG4gICk7XG5cbiAgLy8gV2UgYWRkIGEgY29tbWVudCBpZiB0aGVyZSBhcmUgcHJvdmlkZXJzIHdpdGggbWlzc2luZyBzY2hlbWEgaW5mb3JtYXRpb25cbiAgY29uc3QgcHJvdmlkZXJzTGFja2luZ1NjaGVtYSA9IE9iamVjdC5rZXlzKHByb3ZpZGVyUmVxdWlyZW1lbnRzKS5maWx0ZXIoXG4gICAgKHByb3ZpZGVyTmFtZSkgPT5cbiAgICAgIHByb3ZpZGVyTmFtZSAhPT0gXCJ0ZXJyYWZvcm1cIiAmJlxuICAgICAgIU9iamVjdC5rZXlzKHByb3ZpZGVyU2NoZW1hLnByb3ZpZGVyX3NjaGVtYXMgfHwge30pLnNvbWUoKHNjaGVtYU5hbWUpID0+XG4gICAgICAgIHNjaGVtYU5hbWUuZW5kc1dpdGgocHJvdmlkZXJOYW1lKVxuICAgICAgKVxuICApO1xuICBsb2dnZXIuZGVidWcoXG4gICAgYCR7XG4gICAgICBwcm92aWRlcnNMYWNraW5nU2NoZW1hLmxlbmd0aFxuICAgIH0gcHJvdmlkZXJzIGxhY2sgc2NoZW1hIGluZm9ybWF0aW9uOiAke3Byb3ZpZGVyc0xhY2tpbmdTY2hlbWEuam9pbihcIiwgXCIpfWBcbiAgKTtcblxuICBpZiAocHJvdmlkZXJzTGFja2luZ1NjaGVtYS5sZW5ndGggPiAwKSB7XG4gICAgZXhwcmVzc2lvbnNbMF0gPSB0LmFkZENvbW1lbnQoXG4gICAgICBleHByZXNzaW9uc1swXSxcbiAgICAgIFwibGVhZGluZ1wiLFxuICAgICAgYFRoZSBmb2xsb3dpbmcgcHJvdmlkZXJzIGFyZSBtaXNzaW5nIHNjaGVtYSBpbmZvcm1hdGlvbiBhbmQgbWlnaHQgbmVlZCBtYW51YWwgYWRqdXN0bWVudHMgdG8gc3ludGhlc2l6ZSBjb3JyZWN0bHk6ICR7cHJvdmlkZXJzTGFja2luZ1NjaGVtYS5qb2luKFxuICAgICAgICBcIiwgXCJcbiAgICAgICl9LlxuRm9yIGEgbW9yZSBwcmVjaXNlIGNvbnZlcnNpb24gcGxlYXNlIHVzZSB0aGUgLS1wcm92aWRlciBmbGFnIGluIGNvbnZlcnQuYFxuICAgICk7XG4gIH1cblxuICAvLyBBbHdheXMgYWRkIGNvbnN0cnVjdHNcbiAgc2NvcGUuaW1wb3J0YWJsZXMucHVzaCh7XG4gICAgY29uc3RydWN0TmFtZTogXCJDb25zdHJ1Y3RcIixcbiAgICBwcm92aWRlcjogXCJjb25zdHJ1Y3RzXCIsXG4gIH0pO1xuXG4gIGlmIChzY29wZS5oYXNUb2tlbkJhc2VkVHlwZUNvZXJjaW9uKSB7XG4gICAgc2NvcGUuaW1wb3J0YWJsZXMucHVzaCh7XG4gICAgICBjb25zdHJ1Y3ROYW1lOiBcIlRva2VuXCIsXG4gICAgICBwcm92aWRlcjogXCJjZGt0ZlwiLFxuICAgIH0pO1xuICB9XG5cbiAgLy8gQWRkIHNwZWNpZmljIGltcG9ydCBmb3IgY29kZUNvbnRhaW5lclxuICBhZGRJbXBvcnRGb3JDb2RlQ29udGFpbmVyKHNjb3BlLCBjb2RlQ29udGFpbmVyKTtcbiAgY29uc3QgY29uc3RydWN0SW1wb3J0cyA9IGJ1aWxkSW1wb3J0cyhzY29wZS5pbXBvcnRhYmxlcyk7XG5cbiAgY29uc3QgY29kZSA9IFsuLi4oYmFja2VuZEV4cHJlc3Npb25zIHx8IFtdKSwgLi4uZXhwcmVzc2lvbnNdO1xuICBjb25zdCBjb25maWdUeXBlTmFtZSA9XG4gICAgT2JqZWN0LmtleXMoc2NvcGUudG9wTGV2ZWxDb25maWcpLmxlbmd0aCA+IDAgPyBcIk15Q29uZmlnXCIgOiB1bmRlZmluZWQ7XG5cbiAgY29uc3QgY2xhc3NDb25maWcgPSBjb25maWdUeXBlTmFtZVxuICAgID8gW2dlbmVyYXRlQ29uZmlnVHlwZShjb25maWdUeXBlTmFtZSwgc2NvcGUudG9wTGV2ZWxDb25maWcpXVxuICAgIDogW107XG5cbiAgLy8gV2Ugc3BsaXQgdXAgdGhlIGdlbmVyYXRlZCBjb2RlIHNvIHRoYXQgdXNlcnMgY2FuIGhhdmUgbW9yZSBjb250cm9sIG92ZXIgd2hhdCB0byBpbnNlcnQgd2hlcmVcbiAgcmV0dXJuIHtcbiAgICAvLyBUT0RPOiBSZW1vdmUgaW1wb3J0cyBhbmQgY29kZSBiZWNhdXNlIHJvc2V0dGEgd29uJ3QgYmUgYWJsZSB0byB0cmFuc2xhdGUgdGhlbVxuICAgIGFsbDogYXdhaXQgZ2VuKFtcbiAgICAgIC4uLmNvbnN0cnVjdEltcG9ydHMsXG4gICAgICAuLi5tb2R1bGVJbXBvcnRzKHBsYW4ubW9kdWxlKSxcbiAgICAgIC4uLmNsYXNzQ29uZmlnLFxuICAgICAgd3JhcENvZGVJbkNvbnN0cnVjdG9yKFxuICAgICAgICBjb2RlQ29udGFpbmVyLFxuICAgICAgICBjb2RlLFxuICAgICAgICBcIk15Q29udmVydGVkQ29kZVwiLFxuICAgICAgICBjb25maWdUeXBlTmFtZVxuICAgICAgKSxcbiAgICBdKSxcbiAgICBpbXBvcnRzOiBhd2FpdCBnZW4oWy4uLmNvbnN0cnVjdEltcG9ydHMsIC4uLm1vZHVsZUltcG9ydHMocGxhbi5tb2R1bGUpXSksXG4gICAgY29kZTogYXdhaXQgZ2VuKGNvZGUpLFxuICAgIHByb3ZpZGVyczogT2JqZWN0LmVudHJpZXMocHJvdmlkZXJSZXF1aXJlbWVudHMpLm1hcCgoW3NvdXJjZSwgdmVyc2lvbl0pID0+XG4gICAgICB2ZXJzaW9uID09PSBcIipcIiA/IHNvdXJjZSA6IGAke3NvdXJjZX1AJHt2ZXJzaW9ufWBcbiAgICApLFxuICAgIG1vZHVsZXM6IG1vZHVsZVJlcXVpcmVtZW50cyxcbiAgICAvLyBXZSB0cmFjayBzb21lIHVzYWdlIGRhdGEgdG8gbWFrZSBpdCBlYXNpZXIgdG8gdW5kZXJzdGFuZCB3aGF0IGlzIHVzZWRcbiAgICBzdGF0czoge1xuICAgICAgbnVtYmVyT2ZNb2R1bGVzOiBtb2R1bGVSZXF1aXJlbWVudHMubGVuZ3RoLFxuICAgICAgbnVtYmVyT2ZQcm92aWRlcnM6IE9iamVjdC5rZXlzKHByb3ZpZGVyUmVxdWlyZW1lbnRzKS5sZW5ndGgsXG4gICAgICByZXNvdXJjZXM6IHJlc291cmNlU3RhdHMocGxhbi5yZXNvdXJjZSB8fCB7fSksXG4gICAgICBkYXRhOiByZXNvdXJjZVN0YXRzKHBsYW4uZGF0YSB8fCB7fSksXG4gICAgICBjb252ZXJ0ZWRMaW5lczogaGNsLnNwbGl0KFwiXFxuXCIpLmxlbmd0aCxcbiAgICB9LFxuICB9O1xufVxuXG50eXBlIEZpbGUgPSB7IGNvbnRlbnRzOiBzdHJpbmc7IGZpbGVOYW1lOiBzdHJpbmcgfTtcbmNvbnN0IHRyYW5zbGF0b3JzID0ge1xuICBweXRob246IHtcbiAgICB2aXNpdG9yOiAoKSA9PiBuZXcgcm9zZXR0YS5QeXRob25WaXNpdG9yKCksXG4gICAgcG9zdFRyYW5zbGF0aW9uTXV0YXRpb246IHJlcGxhY2VQeXRob25JbXBvcnRzLFxuICB9LFxuICBqYXZhOiB7XG4gICAgdmlzaXRvcjogKCkgPT4gbmV3IHJvc2V0dGEuSmF2YVZpc2l0b3IoKSxcbiAgICBwb3N0VHJhbnNsYXRpb25NdXRhdGlvbjogcmVwbGFjZUphdmFJbXBvcnRzLFxuICB9LFxuICBjc2hhcnA6IHtcbiAgICB2aXNpdG9yOiAoKSA9PiBuZXcgcm9zZXR0YS5DU2hhcnBWaXNpdG9yKCksXG4gICAgcG9zdFRyYW5zbGF0aW9uTXV0YXRpb246IHJlcGxhY2VDc2hhcnBJbXBvcnRzLFxuICB9LFxuICBnbzoge1xuICAgIHZpc2l0b3I6ICgpID0+IG5ldyByb3NldHRhLkdvVmlzaXRvcigpLFxuICAgIHBvc3RUcmFuc2xhdGlvbk11dGF0aW9uOiByZXBsYWNlR29JbXBvcnRzLFxuICB9LFxufTtcblxuZnVuY3Rpb24gdHJhbnNsYXRvckZvckxhbmd1YWdlKGxhbmd1YWdlOiBrZXlvZiB0eXBlb2YgdHJhbnNsYXRvcnMpIHtcbiAgcmV0dXJuIChmaWxlOiBGaWxlLCB0aHJvd09uVHJhbnNsYXRpb25FcnJvcjogYm9vbGVhbikgPT4ge1xuICAgIGNvbnN0IHsgdmlzaXRvciwgcG9zdFRyYW5zbGF0aW9uTXV0YXRpb24gfSA9IHRyYW5zbGF0b3JzW2xhbmd1YWdlXTtcbiAgICBjb25zdCB7IHRyYW5zbGF0aW9uLCBkaWFnbm9zdGljcyB9ID0gcm9zZXR0YS50cmFuc2xhdGVUeXBlU2NyaXB0KFxuICAgICAgZmlsZSxcbiAgICAgIHZpc2l0b3IoKSxcbiAgICAgIHRocm93T25UcmFuc2xhdGlvbkVycm9yID8geyBpbmNsdWRlQ29tcGlsZXJEaWFnbm9zdGljczogdHJ1ZSB9IDoge31cbiAgICApO1xuXG4gICAgaWYgKFxuICAgICAgdGhyb3dPblRyYW5zbGF0aW9uRXJyb3IgJiZcbiAgICAgIGRpYWdub3N0aWNzLmZpbHRlcigoZGlhZykgPT4gZGlhZy5pc0Vycm9yKS5sZW5ndGggPiAwXG4gICAgKSB7XG4gICAgICBsb2dnZXIuZGVidWcoYENvdWxkIG5vdCB0cmFuc2xhdGUgVFMgdG8gJHtsYW5ndWFnZX06XFxuJHtmaWxlLmNvbnRlbnRzfWApO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQ291bGQgbm90IHRyYW5zbGF0ZSBUUyB0byAke2xhbmd1YWdlfTogJHtkaWFnbm9zdGljc1xuICAgICAgICAgIC5tYXAoKGRpYWcpID0+IGRpYWcuZm9ybWF0dGVkTWVzc2FnZSlcbiAgICAgICAgICAuam9pbihcIlxcblwiKX1gXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBwb3N0VHJhbnNsYXRpb25NdXRhdGlvbih0cmFuc2xhdGlvbik7XG4gIH07XG59XG5cbnR5cGUgQ29udmVydE9wdGlvbnMgPSB7XG4gIC8qKlxuICAgKiBUaGUgbGFuZ3VhZ2UgdG8gY29udmVydCB0b1xuICAgKi9cbiAgbGFuZ3VhZ2U6IGtleW9mIHR5cGVvZiB0cmFuc2xhdG9ycyB8IFwidHlwZXNjcmlwdFwiO1xuICAvKipcbiAgICogVGhlIHByb3ZpZGVyIHNjaGVtYSB0byB1c2UgZm9yIGNvbnZlcnNpb25cbiAgICovXG4gIHByb3ZpZGVyU2NoZW1hOiBQcm92aWRlclNjaGVtYTtcbiAgLyoqXG4gICAqIFRoZSBiYXNlIGNsYXNzIHRvIGV4dGVuZCBmcm9tLiBEZWZhdWx0cyB0byBgY29uc3RydWN0cy5Db25zdHJ1Y3RgXG4gICAqL1xuICBjb2RlQ29udGFpbmVyPzogc3RyaW5nO1xuICAvKipcbiAgICogV2hldGhlciB0byB0aHJvdyBhbiBlcnJvciBpZiB0aGUgdHJhbnNsYXRpb24gZmFpbHNcbiAgICogRGVmYXVsdHMgdG8gZmFsc2VcbiAgICovXG4gIHRocm93T25UcmFuc2xhdGlvbkVycm9yPzogYm9vbGVhbjtcbn07XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjb252ZXJ0KFxuICBoY2w6IHN0cmluZyxcbiAge1xuICAgIGxhbmd1YWdlLFxuICAgIHByb3ZpZGVyU2NoZW1hLFxuICAgIHRocm93T25UcmFuc2xhdGlvbkVycm9yID0gZmFsc2UsXG4gICAgY29kZUNvbnRhaW5lciA9IFwiY2RrdGYuVGVycmFmb3JtU3RhY2tcIixcbiAgfTogQ29udmVydE9wdGlvbnNcbikge1xuICBjb25zdCBmaWxlTmFtZSA9IFwidGVycmFmb3JtLnRmXCI7XG4gIGNvbnN0IHRyYW5zbGF0ZXIgPVxuICAgIGxhbmd1YWdlID09PSBcInR5cGVzY3JpcHRcIlxuICAgICAgPyAoZmlsZTogRmlsZSwgX3Rocm93T25UcmFuc2xhdGlvbkVycm9yOiBib29sZWFuKSA9PiBmaWxlLmNvbnRlbnRzXG4gICAgICA6IHRyYW5zbGF0b3JGb3JMYW5ndWFnZShsYW5ndWFnZSk7XG5cbiAgaWYgKCF0cmFuc2xhdGVyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgbGFuZ3VhZ2UgdXNlZDogXCIgKyBsYW5ndWFnZSk7XG4gIH1cblxuICBjb25zdCB0c0NvZGUgPSBhd2FpdCBjb252ZXJ0VG9UeXBlc2NyaXB0KGhjbCwgcHJvdmlkZXJTY2hlbWEsIGNvZGVDb250YWluZXIpO1xuXG4gIHJldHVybiB7XG4gICAgLi4udHNDb2RlLFxuICAgIGFsbDogdHJhbnNsYXRlcihcbiAgICAgIHsgZmlsZU5hbWUsIGNvbnRlbnRzOiB0c0NvZGUuYWxsIH0sXG4gICAgICB0aHJvd09uVHJhbnNsYXRpb25FcnJvclxuICAgICksXG4gICAgaW1wb3J0czogdHJhbnNsYXRlcih7IGZpbGVOYW1lLCBjb250ZW50czogdHNDb2RlLmltcG9ydHMgfSwgZmFsc2UpLFxuICAgIGNvZGU6IHRyYW5zbGF0ZXIoeyBmaWxlTmFtZSwgY29udGVudHM6IHRzQ29kZS5jb2RlIH0sIGZhbHNlKSxcbiAgICBzdGF0czogeyAuLi50c0NvZGUuc3RhdHMsIGxhbmd1YWdlIH0sXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRUZXJyYWZvcm1Db25maWdGcm9tRGlyKGltcG9ydFBhdGg6IHN0cmluZykge1xuICBjb25zdCBhYnNQYXRoID0gcGF0aC5yZXNvbHZlKGltcG9ydFBhdGgpO1xuICBjb25zdCBmaWxlQ29udGVudHMgPSBnbG9iXG4gICAgLnN5bmMoXCIuLyoudGZcIiwgeyBjd2Q6IGFic1BhdGggfSlcbiAgICAubWFwKChwKSA9PiBmcy5yZWFkRmlsZVN5bmMocGF0aC5yZXNvbHZlKGFic1BhdGgsIHApLCBcInV0ZjhcIikpO1xuXG4gIHJldHVybiBmaWxlQ29udGVudHMuam9pbihcIlxcblwiKTtcbn1cblxudHlwZSBDZGt0Zkpzb24gPSBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiAmIHtcbiAgdGVycmFmb3JtUHJvdmlkZXJzOiBhbnlbXTtcbiAgdGVycmFmb3JtTW9kdWxlczogYW55W107XG59O1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNvbnZlcnRQcm9qZWN0KFxuICBjb21iaW5lZEhjbDogc3RyaW5nLFxuICB7IGxhbmd1YWdlLCBwcm92aWRlclNjaGVtYSB9OiBDb252ZXJ0T3B0aW9uc1xuKSB7XG4gIGlmIChsYW5ndWFnZSAhPT0gXCJ0eXBlc2NyaXB0XCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBsYW5ndWFnZSB1c2VkOiBcIiArIGxhbmd1YWdlKTtcbiAgfVxuXG4gIGNvbnN0IHtcbiAgICBpbXBvcnRzLFxuICAgIGNvZGUsXG4gICAgcHJvdmlkZXJzLFxuICAgIG1vZHVsZXM6IHRmTW9kdWxlcyxcbiAgICBzdGF0cyxcbiAgfSA9IGF3YWl0IGNvbnZlcnQoY29tYmluZWRIY2wsIHtcbiAgICBsYW5ndWFnZSxcbiAgICBwcm92aWRlclNjaGVtYSxcbiAgfSk7XG5cbiAgcmV0dXJuIHtcbiAgICBjb2RlOiAoaW5wdXRNYWluRmlsZTogc3RyaW5nKSA9PiB7XG4gICAgICBjb25zdCBpbXBvcnRNYWluRmlsZSA9IFtpbXBvcnRzLCBpbnB1dE1haW5GaWxlXS5qb2luKFwiXFxuXCIpO1xuICAgICAgY29uc3Qgb3V0cHV0TWFpbkZpbGUgPSBpbXBvcnRNYWluRmlsZS5yZXBsYWNlKENPREVfTUFSS0VSLCBjb2RlKTtcbiAgICAgIHJldHVybiBwcmV0dGllci5mb3JtYXQob3V0cHV0TWFpbkZpbGUsIHsgcGFyc2VyOiBcImJhYmVsXCIgfSk7XG4gICAgfSxcbiAgICBjZGt0Zkpzb246IChpbnB1dENka3RmSnNvbjogQ2RrdGZKc29uKSA9PiB7XG4gICAgICBjb25zdCBjZGt0Zkpzb24gPSB7IC4uLmlucHV0Q2RrdGZKc29uIH07XG4gICAgICBjZGt0Zkpzb24udGVycmFmb3JtUHJvdmlkZXJzID0gcHJvdmlkZXJzO1xuICAgICAgY2RrdGZKc29uLnRlcnJhZm9ybU1vZHVsZXMgPSB0Zk1vZHVsZXM7XG4gICAgICByZXR1cm4gY2RrdGZKc29uO1xuICAgIH0sXG4gICAgc3RhdHMsXG4gIH07XG59XG5cbmV4cG9ydCB7IGlzUmVnaXN0cnlNb2R1bGUsIGF0dHJpYnV0ZU5hbWVUb0Nka3RmTmFtZSB9O1xuIl19