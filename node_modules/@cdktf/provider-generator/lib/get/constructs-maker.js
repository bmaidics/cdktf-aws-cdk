"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.determineGoModuleName = exports.ConstructsMaker = exports.generateJsiiLanguage = void 0;
// Copyright (c) HashiCorp, Inc
// SPDX-License-Identifier: MPL-2.0
const fs = __importStar(require("fs-extra"));
const path = __importStar(require("path"));
const codemaker_1 = require("codemaker");
const commons_1 = require("@cdktf/commons");
const srcmak = __importStar(require("jsii-srcmak"));
const commons_2 = require("@cdktf/commons");
const commons_3 = require("@cdktf/commons");
const provider_generator_1 = require("./generator/provider-generator");
const module_generator_1 = require("./generator/module-generator");
const glob_1 = require("glob");
const provider_schema_1 = require("@cdktf/provider-schema");
async function generateJsiiLanguage(code, opts, outputPath, disallowedFileGlobs = []) {
    await (0, commons_1.mkdtemp)(async (staging) => {
        // this is not typescript, so we generate in a staging directory and
        // use jsii-srcmak to compile and extract the language-specific source
        // into our project.
        await code.save(staging);
        // as the above generated the Typescript code for all providers and modules,
        // we need to filter out the ones we don't need so they don't end up in the JSII bundle over and over again.
        const filesToDelete = disallowedFileGlobs.flatMap((pattern) => glob_1.glob.sync(pattern, { cwd: staging }));
        await Promise.all(filesToDelete.map((file) => fs.remove(path.join(staging, file))));
        await srcmak.srcmak(staging, opts);
        ["versions.json", "constraints.json"].forEach((file) => {
            try {
                fs.copySync(path.resolve(staging, file), path.resolve(outputPath, file));
            }
            catch (e) {
                commons_2.logger.debug(`Failed to copy ${file}: ${e}`);
            }
        });
    });
}
exports.generateJsiiLanguage = generateJsiiLanguage;
class ConstructsMaker {
    constructor(options, schemaCachePath, reportTelemetry = async () => { }) {
        this.options = options;
        this.schemaCachePath = schemaCachePath;
        this.reportTelemetry = reportTelemetry;
        this.codeMakerOutdir = path.resolve(this.options.codeMakerOutput);
        fs.mkdirpSync(this.codeMakerOutdir);
        this.code = new codemaker_1.CodeMaker();
        this.versions = {};
    }
    async generateTypescriptProvider(target, schema) {
        const endTSTimer = (0, commons_2.logTimespan)(`Generate Typescript for ${target.name}`);
        const generator = new provider_generator_1.TerraformProviderGenerator(this.code, schema);
        generator.generate(target);
        this.versions = { ...this.versions, ...generator.versions };
        endTSTimer();
    }
    async filterAlreadyGenerated(constraints) {
        let constraintsFile = "{}";
        try {
            constraintsFile = await fs.readFile(path.join(this.codeMakerOutdir, "constraints.json"), "utf8");
        }
        catch (e) {
            commons_2.logger.debug(`Could not find constraints.json file while filtering: ${e}. This means no providers were generated, so all constraints need to be generated.`);
            return constraints;
        }
        commons_2.logger.debug(`Found constraints.json file: ${constraintsFile}`);
        let previousConstraints = {};
        try {
            previousConstraints = JSON.parse(constraintsFile);
        }
        catch (e) {
            commons_2.logger.info(`Could not parse constraints.json file while filtering: ${e}. Generating all constraints.`);
            return constraints;
        }
        commons_2.logger.debug(`Found previous constraints: ${JSON.stringify(previousConstraints, null, 2)}`);
        if (!previousConstraints.providers ||
            typeof previousConstraints.providers !== "object") {
            commons_2.logger.info(`Could not find providers in constraints.json file, generating all constraints. The constraints file was ${JSON.stringify(previousConstraints, null, 2)}`);
            return constraints;
        }
        if (previousConstraints.cdktf !== commons_3.DISPLAY_VERSION) {
            commons_2.logger.info(`The CDKTF version has changed, generating all constraints. The previous version was ${previousConstraints.cdktf}, the current version is ${commons_3.DISPLAY_VERSION}`);
            return constraints;
        }
        const constraintsToGenerate = constraints.filter((constraint) => {
            const constraintMatches = previousConstraints.providers[constraint.fqn] === constraint.version;
            let providerFolderExists = false;
            switch (this.options.targetLanguage) {
                case commons_3.Language.TYPESCRIPT:
                    providerFolderExists = fs.existsSync(path.join(this.codeMakerOutdir, "providers", constraint.name));
                    break;
                case commons_3.Language.PYTHON:
                case commons_3.Language.JAVA:
                case commons_3.Language.CSHARP:
                    providerFolderExists = fs.existsSync(path.join(this.codeMakerOutdir, constraint.name));
                    break;
                case commons_3.Language.GO:
                    providerFolderExists = fs.existsSync(path.join(this.codeMakerOutdir, constraint.namespace || "hashicorp", constraint.name));
                    break;
            }
            const providerExists = constraintMatches && providerFolderExists;
            return !providerExists;
        });
        commons_2.logger.debug(`Constraints to generate: ${JSON.stringify(constraintsToGenerate, null, 2)}`);
        return constraintsToGenerate;
    }
    async generateTypescriptModule(target, schema) {
        const endTSTimer = (0, commons_2.logTimespan)(`Generate Typescript for ${target.name}`);
        target.spec = schema;
        new module_generator_1.ModuleGenerator(this.code, [target]);
        endTSTimer();
    }
    async generateTypescript(target, schemas) {
        var _a;
        if (target.isModule) {
            const schema = (_a = schemas.moduleSchema) === null || _a === void 0 ? void 0 : _a[target.moduleKey];
            if (!schema) {
                throw commons_2.Errors.Internal(`Could not generate schema for module ${target.moduleKey}`);
            }
            await this.generateTypescriptModule(target, schema);
        }
        else if (target.isProvider) {
            if (!schemas.providerSchema) {
                throw commons_2.Errors.Internal(`Could not generate schema for providers`);
            }
            await this.generateTypescriptProvider(target, schemas.providerSchema);
        }
        else {
            throw new Error(`Unknown target type used to generate bindings: ${target.name}`);
        }
    }
    // emits a versions.json file with a map of the used version for each provider fqpn
    updateVersionsFile(allowedConstraints) {
        commons_2.logger.debug(`Updating versions file with generated versions ${JSON.stringify(this.versions, null, 2)} with allowed constraints ${JSON.stringify(allowedConstraints, null, 2)}`);
        const filePath = "versions.json";
        let previousVersions = {};
        try {
            previousVersions = JSON.parse(fs.readFileSync(path.resolve(this.codeMakerOutdir, filePath), "utf8"));
            commons_2.logger.debug(`Read existing versions file: ${JSON.stringify(previousVersions, null, 2)}`);
        }
        catch (e) {
            // ignore
            commons_2.logger.debug(`Could not read versions file, this is expected if there are no pre-existing local providers: ${e}`);
        }
        const versions = allowedConstraints.reduce((acc, constraint) => {
            const provider = Object.entries(previousVersions).find(([name]) => 
            // This could be more refined, but it's good enough for now
            name.endsWith(constraint.fqn));
            if (provider) {
                const [name, version] = provider;
                return { ...acc, [name]: version };
            }
            return acc;
        }, {});
        commons_2.logger.debug(`Writing versions file (${filePath}): ${JSON.stringify(versions, null, 2)}`);
        this.code.openFile(filePath);
        this.code.line(JSON.stringify({ ...versions, ...this.versions }, null, 2));
        this.code.closeFile(filePath);
        return filePath;
    }
    async removeFoldersThatShouldNotExist(constraintsThatShouldExist) {
        commons_2.logger.debug(`Removing providers except for ${JSON.stringify(constraintsThatShouldExist, null, 2)}`);
        // All languages besides TS keep their providers in the same folders as modules
        // this makes it impossible for us to distinguish a no longer required provider
        // from a manually written construct or a module
        if (!this.isJavascriptTarget) {
            return;
        }
        let filesInProviders = [];
        const providersFolder = path.resolve(this.codeMakerOutdir, "providers");
        try {
            filesInProviders = await fs.readdir(providersFolder);
        }
        catch (e) {
            commons_2.logger.debug(`Error listing files in providers folder '${providersFolder}': ${e}`);
        }
        const folders = filesInProviders.filter((file) => fs
            .statSync(path.resolve(this.codeMakerOutdir, "providers", file))
            .isDirectory());
        return folders.forEach((folder) => {
            const shouldExist = constraintsThatShouldExist.some((constraint) => constraint.name === folder);
            if (!shouldExist) {
                commons_2.logger.debug(`Removing folder ${folder} from providers`);
                fs.removeSync(path.resolve(this.codeMakerOutdir, "providers", folder));
            }
        });
    }
    // emits a constraints.json file with a map of the used provider fqpns and version constraints
    // this is used for caching purposes
    emitConstraintsFile(allowedConstraints) {
        const filePath = "constraints.json";
        const content = {
            cdktf: commons_3.DISPLAY_VERSION,
            providers: allowedConstraints
                .sort((a, b) => a.fqn.localeCompare(b.fqn))
                .reduce((carry, item) => ({
                ...carry,
                [item.fqn]: item.version,
            }), {}),
        };
        this.code.openFile(filePath);
        this.code.line(JSON.stringify(content, null, 2));
        this.code.closeFile(filePath);
        return filePath;
    }
    async generateJsiiLanguage(target) {
        var _a;
        // these are the module dependencies we compile against
        const deps = ["@types/node", "constructs", "cdktf"];
        const opts = {
            entrypoint: target.fileName,
            deps: deps.map((dep) => path.dirname(require.resolve(`${dep}/package.json`))),
            moduleKey: target.moduleKey,
            exports: target.isProvider // Modules are small enough that we don't need this optimization
                ? {
                    ".": {
                        import: `./providers/${target.name}/index.js`,
                        require: `./providers/${target.name}/lazy-index.js`,
                    },
                }
                : undefined,
        };
        // used for testing.
        if (this.options.outputJsii) {
            opts.jsii = { path: this.options.outputJsii };
        }
        if (this.isPythonTarget) {
            opts.python = {
                outdir: this.codeMakerOutdir,
                moduleName: target.srcMakName,
            };
        }
        if (this.isJavaTarget) {
            if (this.options.codeMakerOutput.includes("/") ||
                this.options.codeMakerOutput.includes("\\")) {
                throw commons_2.Errors.Usage(`When using Java the "codeMakerOutput" option in the cdktf.json must be the organization identifier for your project (e.g. com.my-company), not a path. The generated Java code will be placed in a subdirectory of the given directory. If you are migrating from a < 0.19 version of cdktf you want to change the codemakerOutput to "imports".`);
            }
            opts.java = {
                outdir: ".",
                package: `${this.options.codeMakerOutput}.${target.srcMakName}`,
            };
        }
        if (this.isCsharpTarget) {
            opts.csharp = {
                outdir: this.codeMakerOutdir,
                namespace: target.srcMakName,
            };
        }
        if (this.isGoTarget) {
            // TODO: check if needed for modules somehow
            // const targetType = target.isProvider ? 'provider' : 'module';
            // jsii-srcmac will produce a folder inside this dir named after "packageName"
            // so this results in e.g. .gen/hashicorp/random
            const outdir = path.join(this.codeMakerOutdir, (_a = target.namespace) !== null && _a !== void 0 ? _a : "");
            opts.golang = {
                outdir,
                moduleName: await (0, exports.determineGoModuleName)(outdir),
                packageName: target.srcMakName, // package will be named e.g. random for hashicorp/random
            };
        }
        if (process.env.NODE_OPTIONS &&
            !process.env.NODE_OPTIONS.includes(`--max-old-space-size`)) {
            commons_2.logger.warn(`found NODE_OPTIONS environment variable without a setting for --max-old-space-size.
The provider generation needs a substantial amount of memory (~13GB) for some providers and languages.
So cdktf-cli sets it to NODE_OPTIONS="--max-old-space-size=16384" by default. As your environment already contains
a NODE_OPTIONS variable, we won't override it. Hence, the provider generation might fail with an out of memory error.`);
        }
        else {
            // increase memory to allow generating large providers (i.e. aws or azurerm for Go)
            // srcmak is going to spawn a childprocess (for jsii-pacmak) which is going to be affected by this env var
            process.env.NODE_OPTIONS = "--max-old-space-size=16384";
        }
        const jsiiTimer = (0, commons_2.logTimespan)("JSII");
        await generateJsiiLanguage(this.code, opts, this.codeMakerOutdir, [
            target.isModule ? "providers/**" : "modules/**",
        ]);
        jsiiTimer();
    }
    async getSchemas(targets) {
        return await (0, provider_schema_1.readSchema)(targets, this.schemaCachePath);
    }
    async generate(allConstraints, constraintsToGenerate = allConstraints) {
        const targets = constraintsToGenerate.map((constraint) => commons_2.ConstructsMakerTarget.from(constraint, this.options.targetLanguage));
        const endSchemaTimer = (0, commons_2.logTimespan)("Gathering schema");
        const schemas = await this.getSchemas(constraintsToGenerate);
        endSchemaTimer();
        const endGenerateTimer = (0, commons_2.logTimespan)("Generate TS");
        await Promise.all(targets.map((target) => this.generateTypescript(target, schemas)));
        endGenerateTimer();
        this.updateVersionsFile(allConstraints);
        this.emitConstraintsFile(allConstraints);
        if (this.isJavascriptTarget) {
            await this.save();
        }
        if (!this.isJavascriptTarget || this.options.outputJsii) {
            const numberOfWorkers = Math.max(1, this.options.jsiiParallelism === -1
                ? targets.length
                : this.options.jsiiParallelism || 1);
            const work = [...targets];
            const workers = new Array(numberOfWorkers).fill(async () => {
                let target;
                while ((target = work.pop())) {
                    const endJsiiTarget = (0, commons_2.logTimespan)(`Generating JSII bindings for ${target.name}`);
                    await this.generateJsiiLanguage(target);
                    endJsiiTarget();
                }
            });
            await Promise.all(workers.map((fn) => fn()));
        }
        for (const target of targets) {
            await this.reportTelemetry({
                trackingPayload: target.trackingPayload,
                targetLanguage: target.targetLanguage,
            });
        }
        if (this.isPythonTarget) {
            const endPythonTimer = (0, commons_2.logTimespan)("Python post-processing");
            // Remove from . import ... statements from root level __init__.py
            // This removes root-level imports of namespaces, but saves 25s synth time for the aws provider alone
            const allInitPyPaths = glob_1.glob
                .sync("**/__init__.py", {
                cwd: this.codeMakerOutdir,
            })
                // sort by depth, so we start with the shallowest files
                .sort((a, b) => a.split("/").length - b.split("/").length);
            const visitedDirectories = [];
            for (const initPyPath of allInitPyPaths) {
                const directoryPath = path.dirname(initPyPath);
                if (visitedDirectories.some((dir) => directoryPath.startsWith(dir))) {
                    // we already processed this directory
                    continue;
                }
                visitedDirectories.push(directoryPath);
                const absoluteInitPyPath = path.join(this.codeMakerOutdir, initPyPath);
                const initPy = await fs.readFile(absoluteInitPyPath, "utf8");
                const initPyWithoutImports = initPy.replace(/from \. import .*\n/g, "");
                await fs.writeFile(absoluteInitPyPath, initPyWithoutImports);
            }
            endPythonTimer();
        }
    }
    async save(outdir = this.codeMakerOutdir) {
        await this.code.save(outdir);
    }
    get isJavascriptTarget() {
        return this.options.targetLanguage === commons_3.Language.TYPESCRIPT;
    }
    get isPythonTarget() {
        return this.options.targetLanguage === commons_3.Language.PYTHON;
    }
    get isJavaTarget() {
        return this.options.targetLanguage === commons_3.Language.JAVA;
    }
    get isCsharpTarget() {
        return this.options.targetLanguage === commons_3.Language.CSHARP;
    }
    get isGoTarget() {
        return this.options.targetLanguage === commons_3.Language.GO;
    }
}
exports.ConstructsMaker = ConstructsMaker;
/**
 * searches for the closest `go.mod` file and returns the nested go module name for `dir`
 * e.g. (/dir/.gen/) => cdk.tf/stack/.gen if the parent dir of .gen has a go.mod for "module cdk.tf/stack"
 *
 * @param dir the directory to start the search from (searches upwards)
 * @returns the package name for `dir`
 * @throws an Error if no go.mod was found
 */
const determineGoModuleName = async (dir) => {
    let previousDir;
    let currentDir = path.resolve(dir);
    do {
        let files = [];
        try {
            files = await fs.readdir(currentDir);
        }
        catch (e) {
            // directory might not exist yet, but we still walk upwards from there, so ignore 'ENOENT'
            if (e.code !== "ENOENT") {
                throw e;
            }
        }
        if (files.includes("go.mod")) {
            const file = path.resolve(currentDir, "go.mod");
            const gomod = await fs.readFile(file);
            const match = /^module\s*(\S*)\s*$/m.exec(gomod.toString());
            if (match && match[1]) {
                const childdir = path.relative(currentDir, dir).replace(/\\/g, "/"); // replace '\' with '/' for windows paths
                return childdir.length > 0 ? `${match[1]}/${childdir}` : match[1];
            }
            throw new Error(`Could not determine the root Go module name. Found ${file} but failed to regex match the module name directive`);
        }
        // go up one directory. As dirname('/') will return '/' we cancel the loop
        // as soon as the dir does not change anymore.
        previousDir = currentDir;
        currentDir = path.dirname(currentDir);
    } while (currentDir !== previousDir);
    throw new Error(`Could not determine the root Go module name. No go.mod found in ${dir} and any parent directories`);
};
exports.determineGoModuleName = determineGoModuleName;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29uc3RydWN0cy1tYWtlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvbnN0cnVjdHMtbWFrZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSwrQkFBK0I7QUFDL0IsbUNBQW1DO0FBQ25DLDZDQUErQjtBQUMvQiwyQ0FBNkI7QUFDN0IseUNBQXNDO0FBQ3RDLDRDQUF5QztBQUN6QyxvREFBc0M7QUFDdEMsNENBVXdCO0FBQ3hCLDRDQUEyRDtBQUMzRCx1RUFBNEU7QUFDNUUsbUVBQStEO0FBQy9ELCtCQUE0QjtBQUM1Qiw0REFBb0Q7QUFFN0MsS0FBSyxVQUFVLG9CQUFvQixDQUN4QyxJQUFlLEVBQ2YsSUFBb0IsRUFDcEIsVUFBa0IsRUFDbEIsc0JBQWdDLEVBQUU7SUFFbEMsTUFBTSxJQUFBLGlCQUFPLEVBQUMsS0FBSyxFQUFFLE9BQU8sRUFBRSxFQUFFO1FBQzlCLG9FQUFvRTtRQUNwRSxzRUFBc0U7UUFDdEUsb0JBQW9CO1FBQ3BCLE1BQU0sSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUV6Qiw0RUFBNEU7UUFDNUUsNEdBQTRHO1FBQzVHLE1BQU0sYUFBYSxHQUFHLG1CQUFtQixDQUFDLE9BQU8sQ0FBQyxDQUFDLE9BQU8sRUFBRSxFQUFFLENBQzVELFdBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLEVBQUUsR0FBRyxFQUFFLE9BQU8sRUFBRSxDQUFDLENBQ3JDLENBQUM7UUFDRixNQUFNLE9BQU8sQ0FBQyxHQUFHLENBQ2YsYUFBYSxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQ2pFLENBQUM7UUFFRixNQUFNLE1BQU0sQ0FBQyxNQUFNLENBQUMsT0FBTyxFQUFFLElBQUksQ0FBQyxDQUFDO1FB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QUFDLENBQUM7S0FDdkMsUUFBUSxVQUFVLEtBQUssV0FBVyxFQUFFO0lBRXJDLE1BQU0sSUFBSSxLQUFLLENBQ2IsbUVBQW1FLEdBQUcsNkJBQTZCLENBQ3BHLENBQUM7QUFDSixDQUFDLENBQUM7QUFuQ1csUUFBQSxxQkFBcUIseUJBbUNoQyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgSGFzaGlDb3JwLCBJbmNcbi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBNUEwtMi4wXG5pbXBvcnQgKiBhcyBmcyBmcm9tIFwiZnMtZXh0cmFcIjtcbmltcG9ydCAqIGFzIHBhdGggZnJvbSBcInBhdGhcIjtcbmltcG9ydCB7IENvZGVNYWtlciB9IGZyb20gXCJjb2RlbWFrZXJcIjtcbmltcG9ydCB7IG1rZHRlbXAgfSBmcm9tIFwiQGNka3RmL2NvbW1vbnNcIjtcbmltcG9ydCAqIGFzIHNyY21hayBmcm9tIFwianNpaS1zcmNtYWtcIjtcbmltcG9ydCB7XG4gIFRlcnJhZm9ybURlcGVuZGVuY3lDb25zdHJhaW50LFxuICBsb2dnZXIsXG4gIGxvZ1RpbWVzcGFuLFxuICBDb25zdHJ1Y3RzTWFrZXJQcm92aWRlclRhcmdldCxcbiAgQ29uc3RydWN0c01ha2VyTW9kdWxlVGFyZ2V0LFxuICBDb25zdHJ1Y3RzTWFrZXJUYXJnZXQsXG4gIFByb3ZpZGVyU2NoZW1hLFxuICBNb2R1bGVTY2hlbWEsXG4gIEVycm9ycyxcbn0gZnJvbSBcIkBjZGt0Zi9jb21tb25zXCI7XG5pbXBvcnQgeyBESVNQTEFZX1ZFUlNJT04sIExhbmd1YWdlIH0gZnJvbSBcIkBjZGt0Zi9jb21tb25zXCI7XG5pbXBvcnQgeyBUZXJyYWZvcm1Qcm92aWRlckdlbmVyYXRvciB9IGZyb20gXCIuL2dlbmVyYXRvci9wcm92aWRlci1nZW5lcmF0b3JcIjtcbmltcG9ydCB7IE1vZHVsZUdlbmVyYXRvciB9IGZyb20gXCIuL2dlbmVyYXRvci9tb2R1bGUtZ2VuZXJhdG9yXCI7XG5pbXBvcnQgeyBnbG9iIH0gZnJvbSBcImdsb2JcIjtcbmltcG9ydCB7IHJlYWRTY2hlbWEgfSBmcm9tIFwiQGNka3RmL3Byb3ZpZGVyLXNjaGVtYVwiO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVKc2lpTGFuZ3VhZ2UoXG4gIGNvZGU6IENvZGVNYWtlcixcbiAgb3B0czogc3JjbWFrLk9wdGlvbnMsXG4gIG91dHB1dFBhdGg6IHN0cmluZyxcbiAgZGlzYWxsb3dlZEZpbGVHbG9iczogc3RyaW5nW10gPSBbXVxuKSB7XG4gIGF3YWl0IG1rZHRlbXAoYXN5bmMgKHN0YWdpbmcpID0+IHtcbiAgICAvLyB0aGlzIGlzIG5vdCB0eXBlc2NyaXB0LCBzbyB3ZSBnZW5lcmF0ZSBpbiBhIHN0YWdpbmcgZGlyZWN0b3J5IGFuZFxuICAgIC8vIHVzZSBqc2lpLXNyY21hayB0byBjb21waWxlIGFuZCBleHRyYWN0IHRoZSBsYW5ndWFnZS1zcGVjaWZpYyBzb3VyY2VcbiAgICAvLyBpbnRvIG91ciBwcm9qZWN0LlxuICAgIGF3YWl0IGNvZGUuc2F2ZShzdGFnaW5nKTtcblxuICAgIC8vIGFzIHRoZSBhYm92ZSBnZW5lcmF0ZWQgdGhlIFR5cGVzY3JpcHQgY29kZSBmb3IgYWxsIHByb3ZpZGVycyBhbmQgbW9kdWxlcyxcbiAgICAvLyB3ZSBuZWVkIHRvIGZpbHRlciBvdXQgdGhlIG9uZXMgd2UgZG9uJ3QgbmVlZCBzbyB0aGV5IGRvbid0IGVuZCB1cCBpbiB0aGUgSlNJSSBidW5kbGUgb3ZlciBhbmQgb3ZlciBhZ2Fpbi5cbiAgICBjb25zdCBmaWxlc1RvRGVsZXRlID0gZGlzYWxsb3dlZEZpbGVHbG9icy5mbGF0TWFwKChwYXR0ZXJuKSA9PlxuICAgICAgZ2xvYi5zeW5jKHBhdHRlcm4sIHsgY3dkOiBzdGFnaW5nIH0pXG4gICAgKTtcbiAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgIGZpbGVzVG9EZWxldGUubWFwKChmaWxlKSA9PiBmcy5yZW1vdmUocGF0aC5qb2luKHN0YWdpbmcsIGZpbGUpKSlcbiAgICApO1xuXG4gICAgYXdhaXQgc3JjbWFrLnNyY21hayhzdGFnaW5nLCBvcHRzKTtcbiAgICBbXCJ2ZXJzaW9ucy5qc29uXCIsIFwiY29uc3RyYWludHMuanNvblwiXS5mb3JFYWNoKChmaWxlKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBmcy5jb3B5U3luYyhcbiAgICAgICAgICBwYXRoLnJlc29sdmUoc3RhZ2luZywgZmlsZSksXG4gICAgICAgICAgcGF0aC5yZXNvbHZlKG91dHB1dFBhdGgsIGZpbGUpXG4gICAgICAgICk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhgRmFpbGVkIHRvIGNvcHkgJHtmaWxlfTogJHtlfWApO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxudHlwZSBDb25zdHJhaW50RmlsZSA9IHsgcHJvdmlkZXJzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+OyBjZGt0Zjogc3RyaW5nIH07XG5cbmV4cG9ydCBpbnRlcmZhY2UgR2V0T3B0aW9ucyB7XG4gIHJlYWRvbmx5IHRhcmdldExhbmd1YWdlOiBMYW5ndWFnZTtcbiAgcmVhZG9ubHkgY29kZU1ha2VyT3V0cHV0OiBzdHJpbmc7XG4gIHJlYWRvbmx5IGpzaWlQYXJhbGxlbGlzbT86IG51bWJlcjtcbiAgLyoqXG4gICAqIFBhdGggdG8gY29weSB0aGUgb3V0cHV0IC5qc2lpIGZpbGUuXG4gICAqIEBkZWZhdWx0IC0ganNpaSBmaWxlIGlzIG5vdCBlbWl0dGVkXG4gICAqL1xuICByZWFkb25seSBvdXRwdXRKc2lpPzogc3RyaW5nO1xufVxuXG5leHBvcnQgY2xhc3MgQ29uc3RydWN0c01ha2VyIHtcbiAgcHJpdmF0ZSByZWFkb25seSBjb2RlTWFrZXJPdXRkaXI6IHN0cmluZztcbiAgcHJpdmF0ZSByZWFkb25seSBjb2RlOiBDb2RlTWFrZXI7XG4gIHByaXZhdGUgdmVyc2lvbnM6IHsgW3Byb3ZpZGVyTmFtZTogc3RyaW5nXTogc3RyaW5nIHwgdW5kZWZpbmVkIH07XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSByZWFkb25seSBvcHRpb25zOiBHZXRPcHRpb25zLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgc2NoZW1hQ2FjaGVQYXRoPzogc3RyaW5nLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgcmVwb3J0VGVsZW1ldHJ5OiAocGF5bG9hZDoge1xuICAgICAgdGFyZ2V0TGFuZ3VhZ2U6IHN0cmluZztcbiAgICAgIHRyYWNraW5nUGF5bG9hZDogUmVjb3JkPHN0cmluZywgYW55PjtcbiAgICB9KSA9PiBQcm9taXNlPHZvaWQ+ID0gYXN5bmMgKCkgPT4ge31cbiAgKSB7XG4gICAgdGhpcy5jb2RlTWFrZXJPdXRkaXIgPSBwYXRoLnJlc29sdmUodGhpcy5vcHRpb25zLmNvZGVNYWtlck91dHB1dCk7XG4gICAgZnMubWtkaXJwU3luYyh0aGlzLmNvZGVNYWtlck91dGRpcik7XG4gICAgdGhpcy5jb2RlID0gbmV3IENvZGVNYWtlcigpO1xuICAgIHRoaXMudmVyc2lvbnMgPSB7fTtcbiAgfVxuICBwcml2YXRlIGFzeW5jIGdlbmVyYXRlVHlwZXNjcmlwdFByb3ZpZGVyKFxuICAgIHRhcmdldDogQ29uc3RydWN0c01ha2VyUHJvdmlkZXJUYXJnZXQsXG4gICAgc2NoZW1hOiBQcm92aWRlclNjaGVtYVxuICApIHtcbiAgICBjb25zdCBlbmRUU1RpbWVyID0gbG9nVGltZXNwYW4oYEdlbmVyYXRlIFR5cGVzY3JpcHQgZm9yICR7dGFyZ2V0Lm5hbWV9YCk7XG4gICAgY29uc3QgZ2VuZXJhdG9yID0gbmV3IFRlcnJhZm9ybVByb3ZpZGVyR2VuZXJhdG9yKHRoaXMuY29kZSwgc2NoZW1hKTtcbiAgICBnZW5lcmF0b3IuZ2VuZXJhdGUodGFyZ2V0KTtcblxuICAgIHRoaXMudmVyc2lvbnMgPSB7IC4uLnRoaXMudmVyc2lvbnMsIC4uLmdlbmVyYXRvci52ZXJzaW9ucyB9O1xuICAgIGVuZFRTVGltZXIoKTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBmaWx0ZXJBbHJlYWR5R2VuZXJhdGVkKFxuICAgIGNvbnN0cmFpbnRzOiBUZXJyYWZvcm1EZXBlbmRlbmN5Q29uc3RyYWludFtdXG4gICkge1xuICAgIGxldCBjb25zdHJhaW50c0ZpbGUgPSBcInt9XCI7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0cmFpbnRzRmlsZSA9IGF3YWl0IGZzLnJlYWRGaWxlKFxuICAgICAgICBwYXRoLmpvaW4odGhpcy5jb2RlTWFrZXJPdXRkaXIsIFwiY29uc3RyYWludHMuanNvblwiKSxcbiAgICAgICAgXCJ1dGY4XCJcbiAgICAgICk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgbG9nZ2VyLmRlYnVnKFxuICAgICAgICBgQ291bGQgbm90IGZpbmQgY29uc3RyYWludHMuanNvbiBmaWxlIHdoaWxlIGZpbHRlcmluZzogJHtlfS4gVGhpcyBtZWFucyBubyBwcm92aWRlcnMgd2VyZSBnZW5lcmF0ZWQsIHNvIGFsbCBjb25zdHJhaW50cyBuZWVkIHRvIGJlIGdlbmVyYXRlZC5gXG4gICAgICApO1xuICAgICAgcmV0dXJuIGNvbnN0cmFpbnRzO1xuICAgIH1cbiAgICBsb2dnZXIuZGVidWcoYEZvdW5kIGNvbnN0cmFpbnRzLmpzb24gZmlsZTogJHtjb25zdHJhaW50c0ZpbGV9YCk7XG5cbiAgICBsZXQgcHJldmlvdXNDb25zdHJhaW50czogUGFydGlhbDxDb25zdHJhaW50RmlsZT4gPSB7fTtcbiAgICB0cnkge1xuICAgICAgcHJldmlvdXNDb25zdHJhaW50cyA9IEpTT04ucGFyc2UoY29uc3RyYWludHNGaWxlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBsb2dnZXIuaW5mbyhcbiAgICAgICAgYENvdWxkIG5vdCBwYXJzZSBjb25zdHJhaW50cy5qc29uIGZpbGUgd2hpbGUgZmlsdGVyaW5nOiAke2V9LiBHZW5lcmF0aW5nIGFsbCBjb25zdHJhaW50cy5gXG4gICAgICApO1xuICAgICAgcmV0dXJuIGNvbnN0cmFpbnRzO1xuICAgIH1cblxuICAgIGxvZ2dlci5kZWJ1ZyhcbiAgICAgIGBGb3VuZCBwcmV2aW91cyBjb25zdHJhaW50czogJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgcHJldmlvdXNDb25zdHJhaW50cyxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgMlxuICAgICAgKX1gXG4gICAgKTtcblxuICAgIGlmIChcbiAgICAgICFwcmV2aW91c0NvbnN0cmFpbnRzLnByb3ZpZGVycyB8fFxuICAgICAgdHlwZW9mIHByZXZpb3VzQ29uc3RyYWludHMucHJvdmlkZXJzICE9PSBcIm9iamVjdFwiXG4gICAgKSB7XG4gICAgICBsb2dnZXIuaW5mbyhcbiAgICAgICAgYENvdWxkIG5vdCBmaW5kIHByb3ZpZGVycyBpbiBjb25zdHJhaW50cy5qc29uIGZpbGUsIGdlbmVyYXRpbmcgYWxsIGNvbnN0cmFpbnRzLiBUaGUgY29uc3RyYWludHMgZmlsZSB3YXMgJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICBwcmV2aW91c0NvbnN0cmFpbnRzLFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgMlxuICAgICAgICApfWBcbiAgICAgICk7XG4gICAgICByZXR1cm4gY29uc3RyYWludHM7XG4gICAgfVxuXG4gICAgaWYgKHByZXZpb3VzQ29uc3RyYWludHMuY2RrdGYgIT09IERJU1BMQVlfVkVSU0lPTikge1xuICAgICAgbG9nZ2VyLmluZm8oXG4gICAgICAgIGBUaGUgQ0RLVEYgdmVyc2lvbiBoYXMgY2hhbmdlZCwgZ2VuZXJhdGluZyBhbGwgY29uc3RyYWludHMuIFRoZSBwcmV2aW91cyB2ZXJzaW9uIHdhcyAke3ByZXZpb3VzQ29uc3RyYWludHMuY2RrdGZ9LCB0aGUgY3VycmVudCB2ZXJzaW9uIGlzICR7RElTUExBWV9WRVJTSU9OfWBcbiAgICAgICk7XG4gICAgICByZXR1cm4gY29uc3RyYWludHM7XG4gICAgfVxuXG4gICAgY29uc3QgY29uc3RyYWludHNUb0dlbmVyYXRlID0gY29uc3RyYWludHMuZmlsdGVyKChjb25zdHJhaW50KSA9PiB7XG4gICAgICBjb25zdCBjb25zdHJhaW50TWF0Y2hlcyA9XG4gICAgICAgIHByZXZpb3VzQ29uc3RyYWludHMucHJvdmlkZXJzIVtjb25zdHJhaW50LmZxbl0gPT09IGNvbnN0cmFpbnQudmVyc2lvbjtcbiAgICAgIGxldCBwcm92aWRlckZvbGRlckV4aXN0cyA9IGZhbHNlO1xuXG4gICAgICBzd2l0Y2ggKHRoaXMub3B0aW9ucy50YXJnZXRMYW5ndWFnZSkge1xuICAgICAgICBjYXNlIExhbmd1YWdlLlRZUEVTQ1JJUFQ6XG4gICAgICAgICAgcHJvdmlkZXJGb2xkZXJFeGlzdHMgPSBmcy5leGlzdHNTeW5jKFxuICAgICAgICAgICAgcGF0aC5qb2luKHRoaXMuY29kZU1ha2VyT3V0ZGlyLCBcInByb3ZpZGVyc1wiLCBjb25zdHJhaW50Lm5hbWUpXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBMYW5ndWFnZS5QWVRIT046XG4gICAgICAgIGNhc2UgTGFuZ3VhZ2UuSkFWQTpcbiAgICAgICAgY2FzZSBMYW5ndWFnZS5DU0hBUlA6XG4gICAgICAgICAgcHJvdmlkZXJGb2xkZXJFeGlzdHMgPSBmcy5leGlzdHNTeW5jKFxuICAgICAgICAgICAgcGF0aC5qb2luKHRoaXMuY29kZU1ha2VyT3V0ZGlyLCBjb25zdHJhaW50Lm5hbWUpXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBMYW5ndWFnZS5HTzpcbiAgICAgICAgICBwcm92aWRlckZvbGRlckV4aXN0cyA9IGZzLmV4aXN0c1N5bmMoXG4gICAgICAgICAgICBwYXRoLmpvaW4oXG4gICAgICAgICAgICAgIHRoaXMuY29kZU1ha2VyT3V0ZGlyLFxuICAgICAgICAgICAgICBjb25zdHJhaW50Lm5hbWVzcGFjZSB8fCBcImhhc2hpY29ycFwiLFxuICAgICAgICAgICAgICBjb25zdHJhaW50Lm5hbWVcbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBwcm92aWRlckV4aXN0cyA9IGNvbnN0cmFpbnRNYXRjaGVzICYmIHByb3ZpZGVyRm9sZGVyRXhpc3RzO1xuICAgICAgcmV0dXJuICFwcm92aWRlckV4aXN0cztcbiAgICB9KTtcblxuICAgIGxvZ2dlci5kZWJ1ZyhcbiAgICAgIGBDb25zdHJhaW50cyB0byBnZW5lcmF0ZTogJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgY29uc3RyYWludHNUb0dlbmVyYXRlLFxuICAgICAgICBudWxsLFxuICAgICAgICAyXG4gICAgICApfWBcbiAgICApO1xuXG4gICAgcmV0dXJuIGNvbnN0cmFpbnRzVG9HZW5lcmF0ZTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgZ2VuZXJhdGVUeXBlc2NyaXB0TW9kdWxlKFxuICAgIHRhcmdldDogQ29uc3RydWN0c01ha2VyTW9kdWxlVGFyZ2V0LFxuICAgIHNjaGVtYTogTW9kdWxlU2NoZW1hXG4gICkge1xuICAgIGNvbnN0IGVuZFRTVGltZXIgPSBsb2dUaW1lc3BhbihgR2VuZXJhdGUgVHlwZXNjcmlwdCBmb3IgJHt0YXJnZXQubmFtZX1gKTtcbiAgICB0YXJnZXQuc3BlYyA9IHNjaGVtYTtcbiAgICBuZXcgTW9kdWxlR2VuZXJhdG9yKHRoaXMuY29kZSwgW3RhcmdldF0pO1xuICAgIGVuZFRTVGltZXIoKTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgZ2VuZXJhdGVUeXBlc2NyaXB0KFxuICAgIHRhcmdldDogQ29uc3RydWN0c01ha2VyVGFyZ2V0LFxuICAgIHNjaGVtYXM6IEF3YWl0ZWQ8UmV0dXJuVHlwZTx0eXBlb2YgcmVhZFNjaGVtYT4+XG4gICkge1xuICAgIGlmICh0YXJnZXQuaXNNb2R1bGUpIHtcbiAgICAgIGNvbnN0IHNjaGVtYSA9IHNjaGVtYXMubW9kdWxlU2NoZW1hPy5bdGFyZ2V0Lm1vZHVsZUtleV07XG4gICAgICBpZiAoIXNjaGVtYSkge1xuICAgICAgICB0aHJvdyBFcnJvcnMuSW50ZXJuYWwoXG4gICAgICAgICAgYENvdWxkIG5vdCBnZW5lcmF0ZSBzY2hlbWEgZm9yIG1vZHVsZSAke3RhcmdldC5tb2R1bGVLZXl9YFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBhd2FpdCB0aGlzLmdlbmVyYXRlVHlwZXNjcmlwdE1vZHVsZShcbiAgICAgICAgdGFyZ2V0IGFzIENvbnN0cnVjdHNNYWtlck1vZHVsZVRhcmdldCxcbiAgICAgICAgc2NoZW1hXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAodGFyZ2V0LmlzUHJvdmlkZXIpIHtcbiAgICAgIGlmICghc2NoZW1hcy5wcm92aWRlclNjaGVtYSkge1xuICAgICAgICB0aHJvdyBFcnJvcnMuSW50ZXJuYWwoYENvdWxkIG5vdCBnZW5lcmF0ZSBzY2hlbWEgZm9yIHByb3ZpZGVyc2ApO1xuICAgICAgfVxuXG4gICAgICBhd2FpdCB0aGlzLmdlbmVyYXRlVHlwZXNjcmlwdFByb3ZpZGVyKFxuICAgICAgICB0YXJnZXQgYXMgQ29uc3RydWN0c01ha2VyUHJvdmlkZXJUYXJnZXQsXG4gICAgICAgIHNjaGVtYXMucHJvdmlkZXJTY2hlbWFcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYFVua25vd24gdGFyZ2V0IHR5cGUgdXNlZCB0byBnZW5lcmF0ZSBiaW5kaW5nczogJHt0YXJnZXQubmFtZX1gXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8vIGVtaXRzIGEgdmVyc2lvbnMuanNvbiBmaWxlIHdpdGggYSBtYXAgb2YgdGhlIHVzZWQgdmVyc2lvbiBmb3IgZWFjaCBwcm92aWRlciBmcXBuXG4gIHByaXZhdGUgdXBkYXRlVmVyc2lvbnNGaWxlKFxuICAgIGFsbG93ZWRDb25zdHJhaW50czogVGVycmFmb3JtRGVwZW5kZW5jeUNvbnN0cmFpbnRbXVxuICApIHtcbiAgICBsb2dnZXIuZGVidWcoXG4gICAgICBgVXBkYXRpbmcgdmVyc2lvbnMgZmlsZSB3aXRoIGdlbmVyYXRlZCB2ZXJzaW9ucyAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICB0aGlzLnZlcnNpb25zLFxuICAgICAgICBudWxsLFxuICAgICAgICAyXG4gICAgICApfSB3aXRoIGFsbG93ZWQgY29uc3RyYWludHMgJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgYWxsb3dlZENvbnN0cmFpbnRzLFxuICAgICAgICBudWxsLFxuICAgICAgICAyXG4gICAgICApfWBcbiAgICApO1xuICAgIGNvbnN0IGZpbGVQYXRoID0gXCJ2ZXJzaW9ucy5qc29uXCI7XG4gICAgbGV0IHByZXZpb3VzVmVyc2lvbnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7fTtcbiAgICB0cnkge1xuICAgICAgcHJldmlvdXNWZXJzaW9ucyA9IEpTT04ucGFyc2UoXG4gICAgICAgIGZzLnJlYWRGaWxlU3luYyhwYXRoLnJlc29sdmUodGhpcy5jb2RlTWFrZXJPdXRkaXIsIGZpbGVQYXRoKSwgXCJ1dGY4XCIpXG4gICAgICApO1xuXG4gICAgICBsb2dnZXIuZGVidWcoXG4gICAgICAgIGBSZWFkIGV4aXN0aW5nIHZlcnNpb25zIGZpbGU6ICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgcHJldmlvdXNWZXJzaW9ucyxcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIDJcbiAgICAgICAgKX1gXG4gICAgICApO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIGlnbm9yZVxuICAgICAgbG9nZ2VyLmRlYnVnKFxuICAgICAgICBgQ291bGQgbm90IHJlYWQgdmVyc2lvbnMgZmlsZSwgdGhpcyBpcyBleHBlY3RlZCBpZiB0aGVyZSBhcmUgbm8gcHJlLWV4aXN0aW5nIGxvY2FsIHByb3ZpZGVyczogJHtlfWBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3QgdmVyc2lvbnMgPSBhbGxvd2VkQ29uc3RyYWludHMucmVkdWNlKChhY2MsIGNvbnN0cmFpbnQpID0+IHtcbiAgICAgIGNvbnN0IHByb3ZpZGVyID0gT2JqZWN0LmVudHJpZXMocHJldmlvdXNWZXJzaW9ucykuZmluZCgoW25hbWVdKSA9PlxuICAgICAgICAvLyBUaGlzIGNvdWxkIGJlIG1vcmUgcmVmaW5lZCwgYnV0IGl0J3MgZ29vZCBlbm91Z2ggZm9yIG5vd1xuICAgICAgICBuYW1lLmVuZHNXaXRoKGNvbnN0cmFpbnQuZnFuKVxuICAgICAgKTtcblxuICAgICAgaWYgKHByb3ZpZGVyKSB7XG4gICAgICAgIGNvbnN0IFtuYW1lLCB2ZXJzaW9uXSA9IHByb3ZpZGVyO1xuICAgICAgICByZXR1cm4geyAuLi5hY2MsIFtuYW1lXTogdmVyc2lvbiB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHt9KTtcblxuICAgIGxvZ2dlci5kZWJ1ZyhcbiAgICAgIGBXcml0aW5nIHZlcnNpb25zIGZpbGUgKCR7ZmlsZVBhdGh9KTogJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgdmVyc2lvbnMsXG4gICAgICAgIG51bGwsXG4gICAgICAgIDJcbiAgICAgICl9YFxuICAgICk7XG5cbiAgICB0aGlzLmNvZGUub3BlbkZpbGUoZmlsZVBhdGgpO1xuICAgIHRoaXMuY29kZS5saW5lKEpTT04uc3RyaW5naWZ5KHsgLi4udmVyc2lvbnMsIC4uLnRoaXMudmVyc2lvbnMgfSwgbnVsbCwgMikpO1xuICAgIHRoaXMuY29kZS5jbG9zZUZpbGUoZmlsZVBhdGgpO1xuICAgIHJldHVybiBmaWxlUGF0aDtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyByZW1vdmVGb2xkZXJzVGhhdFNob3VsZE5vdEV4aXN0KFxuICAgIGNvbnN0cmFpbnRzVGhhdFNob3VsZEV4aXN0OiBUZXJyYWZvcm1EZXBlbmRlbmN5Q29uc3RyYWludFtdXG4gICkge1xuICAgIGxvZ2dlci5kZWJ1ZyhcbiAgICAgIGBSZW1vdmluZyBwcm92aWRlcnMgZXhjZXB0IGZvciAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICBjb25zdHJhaW50c1RoYXRTaG91bGRFeGlzdCxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgMlxuICAgICAgKX1gXG4gICAgKTtcblxuICAgIC8vIEFsbCBsYW5ndWFnZXMgYmVzaWRlcyBUUyBrZWVwIHRoZWlyIHByb3ZpZGVycyBpbiB0aGUgc2FtZSBmb2xkZXJzIGFzIG1vZHVsZXNcbiAgICAvLyB0aGlzIG1ha2VzIGl0IGltcG9zc2libGUgZm9yIHVzIHRvIGRpc3Rpbmd1aXNoIGEgbm8gbG9uZ2VyIHJlcXVpcmVkIHByb3ZpZGVyXG4gICAgLy8gZnJvbSBhIG1hbnVhbGx5IHdyaXR0ZW4gY29uc3RydWN0IG9yIGEgbW9kdWxlXG4gICAgaWYgKCF0aGlzLmlzSmF2YXNjcmlwdFRhcmdldCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBmaWxlc0luUHJvdmlkZXJzOiBzdHJpbmdbXSA9IFtdO1xuICAgIGNvbnN0IHByb3ZpZGVyc0ZvbGRlciA9IHBhdGgucmVzb2x2ZSh0aGlzLmNvZGVNYWtlck91dGRpciwgXCJwcm92aWRlcnNcIik7XG4gICAgdHJ5IHtcbiAgICAgIGZpbGVzSW5Qcm92aWRlcnMgPSBhd2FpdCBmcy5yZWFkZGlyKHByb3ZpZGVyc0ZvbGRlcik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgbG9nZ2VyLmRlYnVnKFxuICAgICAgICBgRXJyb3IgbGlzdGluZyBmaWxlcyBpbiBwcm92aWRlcnMgZm9sZGVyICcke3Byb3ZpZGVyc0ZvbGRlcn0nOiAke2V9YFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCBmb2xkZXJzID0gZmlsZXNJblByb3ZpZGVycy5maWx0ZXIoKGZpbGUpID0+XG4gICAgICBmc1xuICAgICAgICAuc3RhdFN5bmMocGF0aC5yZXNvbHZlKHRoaXMuY29kZU1ha2VyT3V0ZGlyLCBcInByb3ZpZGVyc1wiLCBmaWxlKSlcbiAgICAgICAgLmlzRGlyZWN0b3J5KClcbiAgICApO1xuXG4gICAgcmV0dXJuIGZvbGRlcnMuZm9yRWFjaCgoZm9sZGVyKSA9PiB7XG4gICAgICBjb25zdCBzaG91bGRFeGlzdCA9IGNvbnN0cmFpbnRzVGhhdFNob3VsZEV4aXN0LnNvbWUoXG4gICAgICAgIChjb25zdHJhaW50KSA9PiBjb25zdHJhaW50Lm5hbWUgPT09IGZvbGRlclxuICAgICAgKTtcblxuICAgICAgaWYgKCFzaG91bGRFeGlzdCkge1xuICAgICAgICBsb2dnZXIuZGVidWcoYFJlbW92aW5nIGZvbGRlciAke2ZvbGRlcn0gZnJvbSBwcm92aWRlcnNgKTtcbiAgICAgICAgZnMucmVtb3ZlU3luYyhwYXRoLnJlc29sdmUodGhpcy5jb2RlTWFrZXJPdXRkaXIsIFwicHJvdmlkZXJzXCIsIGZvbGRlcikpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLy8gZW1pdHMgYSBjb25zdHJhaW50cy5qc29uIGZpbGUgd2l0aCBhIG1hcCBvZiB0aGUgdXNlZCBwcm92aWRlciBmcXBucyBhbmQgdmVyc2lvbiBjb25zdHJhaW50c1xuICAvLyB0aGlzIGlzIHVzZWQgZm9yIGNhY2hpbmcgcHVycG9zZXNcbiAgcHJpdmF0ZSBlbWl0Q29uc3RyYWludHNGaWxlKFxuICAgIGFsbG93ZWRDb25zdHJhaW50czogVGVycmFmb3JtRGVwZW5kZW5jeUNvbnN0cmFpbnRbXVxuICApIHtcbiAgICBjb25zdCBmaWxlUGF0aCA9IFwiY29uc3RyYWludHMuanNvblwiO1xuXG4gICAgY29uc3QgY29udGVudDogQ29uc3RyYWludEZpbGUgPSB7XG4gICAgICBjZGt0ZjogRElTUExBWV9WRVJTSU9OLFxuICAgICAgcHJvdmlkZXJzOiBhbGxvd2VkQ29uc3RyYWludHNcbiAgICAgICAgLnNvcnQoKGEsIGIpID0+IGEuZnFuLmxvY2FsZUNvbXBhcmUoYi5mcW4pKVxuICAgICAgICAucmVkdWNlKFxuICAgICAgICAgIChjYXJyeSwgaXRlbSkgPT4gKHtcbiAgICAgICAgICAgIC4uLmNhcnJ5LFxuICAgICAgICAgICAgW2l0ZW0uZnFuXTogaXRlbS52ZXJzaW9uLFxuICAgICAgICAgIH0pLFxuICAgICAgICAgIHt9XG4gICAgICAgICksXG4gICAgfTtcblxuICAgIHRoaXMuY29kZS5vcGVuRmlsZShmaWxlUGF0aCk7XG4gICAgdGhpcy5jb2RlLmxpbmUoSlNPTi5zdHJpbmdpZnkoY29udGVudCwgbnVsbCwgMikpO1xuICAgIHRoaXMuY29kZS5jbG9zZUZpbGUoZmlsZVBhdGgpO1xuICAgIHJldHVybiBmaWxlUGF0aDtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgZ2VuZXJhdGVKc2lpTGFuZ3VhZ2UodGFyZ2V0OiBDb25zdHJ1Y3RzTWFrZXJUYXJnZXQpIHtcbiAgICAvLyB0aGVzZSBhcmUgdGhlIG1vZHVsZSBkZXBlbmRlbmNpZXMgd2UgY29tcGlsZSBhZ2FpbnN0XG4gICAgY29uc3QgZGVwcyA9IFtcIkB0eXBlcy9ub2RlXCIsIFwiY29uc3RydWN0c1wiLCBcImNka3RmXCJdO1xuICAgIGNvbnN0IG9wdHM6IHNyY21hay5PcHRpb25zID0ge1xuICAgICAgZW50cnlwb2ludDogdGFyZ2V0LmZpbGVOYW1lLFxuICAgICAgZGVwczogZGVwcy5tYXAoKGRlcCkgPT5cbiAgICAgICAgcGF0aC5kaXJuYW1lKHJlcXVpcmUucmVzb2x2ZShgJHtkZXB9L3BhY2thZ2UuanNvbmApKVxuICAgICAgKSxcbiAgICAgIG1vZHVsZUtleTogdGFyZ2V0Lm1vZHVsZUtleSxcbiAgICAgIGV4cG9ydHM6IHRhcmdldC5pc1Byb3ZpZGVyIC8vIE1vZHVsZXMgYXJlIHNtYWxsIGVub3VnaCB0aGF0IHdlIGRvbid0IG5lZWQgdGhpcyBvcHRpbWl6YXRpb25cbiAgICAgICAgPyB7XG4gICAgICAgICAgICBcIi5cIjoge1xuICAgICAgICAgICAgICBpbXBvcnQ6IGAuL3Byb3ZpZGVycy8ke3RhcmdldC5uYW1lfS9pbmRleC5qc2AsXG4gICAgICAgICAgICAgIHJlcXVpcmU6IGAuL3Byb3ZpZGVycy8ke3RhcmdldC5uYW1lfS9sYXp5LWluZGV4LmpzYCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfVxuICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICB9O1xuXG4gICAgLy8gdXNlZCBmb3IgdGVzdGluZy5cbiAgICBpZiAodGhpcy5vcHRpb25zLm91dHB1dEpzaWkpIHtcbiAgICAgIG9wdHMuanNpaSA9IHsgcGF0aDogdGhpcy5vcHRpb25zLm91dHB1dEpzaWkgfTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc1B5dGhvblRhcmdldCkge1xuICAgICAgb3B0cy5weXRob24gPSB7XG4gICAgICAgIG91dGRpcjogdGhpcy5jb2RlTWFrZXJPdXRkaXIsXG4gICAgICAgIG1vZHVsZU5hbWU6IHRhcmdldC5zcmNNYWtOYW1lLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc0phdmFUYXJnZXQpIHtcbiAgICAgIGlmIChcbiAgICAgICAgdGhpcy5vcHRpb25zLmNvZGVNYWtlck91dHB1dC5pbmNsdWRlcyhcIi9cIikgfHxcbiAgICAgICAgdGhpcy5vcHRpb25zLmNvZGVNYWtlck91dHB1dC5pbmNsdWRlcyhcIlxcXFxcIilcbiAgICAgICkge1xuICAgICAgICB0aHJvdyBFcnJvcnMuVXNhZ2UoXG4gICAgICAgICAgYFdoZW4gdXNpbmcgSmF2YSB0aGUgXCJjb2RlTWFrZXJPdXRwdXRcIiBvcHRpb24gaW4gdGhlIGNka3RmLmpzb24gbXVzdCBiZSB0aGUgb3JnYW5pemF0aW9uIGlkZW50aWZpZXIgZm9yIHlvdXIgcHJvamVjdCAoZS5nLiBjb20ubXktY29tcGFueSksIG5vdCBhIHBhdGguIFRoZSBnZW5lcmF0ZWQgSmF2YSBjb2RlIHdpbGwgYmUgcGxhY2VkIGluIGEgc3ViZGlyZWN0b3J5IG9mIHRoZSBnaXZlbiBkaXJlY3RvcnkuIElmIHlvdSBhcmUgbWlncmF0aW5nIGZyb20gYSA8IDAuMTkgdmVyc2lvbiBvZiBjZGt0ZiB5b3Ugd2FudCB0byBjaGFuZ2UgdGhlIGNvZGVtYWtlck91dHB1dCB0byBcImltcG9ydHNcIi5gXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIG9wdHMuamF2YSA9IHtcbiAgICAgICAgb3V0ZGlyOiBcIi5cIiwgLy8gZ2VuZXJhdGVkIGphdmEgZmlsZXMgYXJlbid0IHBhY2thZ2VkLCBzbyBqdXN0IGluY2x1ZGUgZGlyZWN0bHkgaW4gYXBwXG4gICAgICAgIHBhY2thZ2U6IGAke3RoaXMub3B0aW9ucy5jb2RlTWFrZXJPdXRwdXR9LiR7dGFyZ2V0LnNyY01ha05hbWV9YCxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNDc2hhcnBUYXJnZXQpIHtcbiAgICAgIG9wdHMuY3NoYXJwID0ge1xuICAgICAgICBvdXRkaXI6IHRoaXMuY29kZU1ha2VyT3V0ZGlyLFxuICAgICAgICBuYW1lc3BhY2U6IHRhcmdldC5zcmNNYWtOYW1lLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc0dvVGFyZ2V0KSB7XG4gICAgICAvLyBUT0RPOiBjaGVjayBpZiBuZWVkZWQgZm9yIG1vZHVsZXMgc29tZWhvd1xuICAgICAgLy8gY29uc3QgdGFyZ2V0VHlwZSA9IHRhcmdldC5pc1Byb3ZpZGVyID8gJ3Byb3ZpZGVyJyA6ICdtb2R1bGUnO1xuXG4gICAgICAvLyBqc2lpLXNyY21hYyB3aWxsIHByb2R1Y2UgYSBmb2xkZXIgaW5zaWRlIHRoaXMgZGlyIG5hbWVkIGFmdGVyIFwicGFja2FnZU5hbWVcIlxuICAgICAgLy8gc28gdGhpcyByZXN1bHRzIGluIGUuZy4gLmdlbi9oYXNoaWNvcnAvcmFuZG9tXG4gICAgICBjb25zdCBvdXRkaXIgPSBwYXRoLmpvaW4odGhpcy5jb2RlTWFrZXJPdXRkaXIsIHRhcmdldC5uYW1lc3BhY2UgPz8gXCJcIik7XG5cbiAgICAgIG9wdHMuZ29sYW5nID0ge1xuICAgICAgICBvdXRkaXIsXG4gICAgICAgIG1vZHVsZU5hbWU6IGF3YWl0IGRldGVybWluZUdvTW9kdWxlTmFtZShvdXRkaXIpLCAvLyBlLmcuIGBnaXRodWIuY29tL29yZy91c2VycHJvamVjdC8uZ2VuL2hhc2hpY29ycGBcbiAgICAgICAgcGFja2FnZU5hbWU6IHRhcmdldC5zcmNNYWtOYW1lLCAvLyBwYWNrYWdlIHdpbGwgYmUgbmFtZWQgZS5nLiByYW5kb20gZm9yIGhhc2hpY29ycC9yYW5kb21cbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9PUFRJT05TICYmXG4gICAgICAhcHJvY2Vzcy5lbnYuTk9ERV9PUFRJT05TLmluY2x1ZGVzKGAtLW1heC1vbGQtc3BhY2Utc2l6ZWApXG4gICAgKSB7XG4gICAgICBsb2dnZXIud2FybihgZm91bmQgTk9ERV9PUFRJT05TIGVudmlyb25tZW50IHZhcmlhYmxlIHdpdGhvdXQgYSBzZXR0aW5nIGZvciAtLW1heC1vbGQtc3BhY2Utc2l6ZS5cblRoZSBwcm92aWRlciBnZW5lcmF0aW9uIG5lZWRzIGEgc3Vic3RhbnRpYWwgYW1vdW50IG9mIG1lbW9yeSAofjEzR0IpIGZvciBzb21lIHByb3ZpZGVycyBhbmQgbGFuZ3VhZ2VzLlxuU28gY2RrdGYtY2xpIHNldHMgaXQgdG8gTk9ERV9PUFRJT05TPVwiLS1tYXgtb2xkLXNwYWNlLXNpemU9MTYzODRcIiBieSBkZWZhdWx0LiBBcyB5b3VyIGVudmlyb25tZW50IGFscmVhZHkgY29udGFpbnNcbmEgTk9ERV9PUFRJT05TIHZhcmlhYmxlLCB3ZSB3b24ndCBvdmVycmlkZSBpdC4gSGVuY2UsIHRoZSBwcm92aWRlciBnZW5lcmF0aW9uIG1pZ2h0IGZhaWwgd2l0aCBhbiBvdXQgb2YgbWVtb3J5IGVycm9yLmApO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpbmNyZWFzZSBtZW1vcnkgdG8gYWxsb3cgZ2VuZXJhdGluZyBsYXJnZSBwcm92aWRlcnMgKGkuZS4gYXdzIG9yIGF6dXJlcm0gZm9yIEdvKVxuICAgICAgLy8gc3JjbWFrIGlzIGdvaW5nIHRvIHNwYXduIGEgY2hpbGRwcm9jZXNzIChmb3IganNpaS1wYWNtYWspIHdoaWNoIGlzIGdvaW5nIHRvIGJlIGFmZmVjdGVkIGJ5IHRoaXMgZW52IHZhclxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9PUFRJT05TID0gXCItLW1heC1vbGQtc3BhY2Utc2l6ZT0xNjM4NFwiO1xuICAgIH1cblxuICAgIGNvbnN0IGpzaWlUaW1lciA9IGxvZ1RpbWVzcGFuKFwiSlNJSVwiKTtcbiAgICBhd2FpdCBnZW5lcmF0ZUpzaWlMYW5ndWFnZSh0aGlzLmNvZGUsIG9wdHMsIHRoaXMuY29kZU1ha2VyT3V0ZGlyLCBbXG4gICAgICB0YXJnZXQuaXNNb2R1bGUgPyBcInByb3ZpZGVycy8qKlwiIDogXCJtb2R1bGVzLyoqXCIsXG4gICAgXSk7XG4gICAganNpaVRpbWVyKCk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgZ2V0U2NoZW1hcyh0YXJnZXRzOiBUZXJyYWZvcm1EZXBlbmRlbmN5Q29uc3RyYWludFtdKSB7XG4gICAgcmV0dXJuIGF3YWl0IHJlYWRTY2hlbWEodGFyZ2V0cywgdGhpcy5zY2hlbWFDYWNoZVBhdGgpO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGdlbmVyYXRlKFxuICAgIGFsbENvbnN0cmFpbnRzOiBUZXJyYWZvcm1EZXBlbmRlbmN5Q29uc3RyYWludFtdLFxuICAgIGNvbnN0cmFpbnRzVG9HZW5lcmF0ZSA9IGFsbENvbnN0cmFpbnRzXG4gICkge1xuICAgIGNvbnN0IHRhcmdldHMgPSBjb25zdHJhaW50c1RvR2VuZXJhdGUubWFwKChjb25zdHJhaW50KSA9PlxuICAgICAgQ29uc3RydWN0c01ha2VyVGFyZ2V0LmZyb20oY29uc3RyYWludCwgdGhpcy5vcHRpb25zLnRhcmdldExhbmd1YWdlKVxuICAgICk7XG5cbiAgICBjb25zdCBlbmRTY2hlbWFUaW1lciA9IGxvZ1RpbWVzcGFuKFwiR2F0aGVyaW5nIHNjaGVtYVwiKTtcbiAgICBjb25zdCBzY2hlbWFzID0gYXdhaXQgdGhpcy5nZXRTY2hlbWFzKGNvbnN0cmFpbnRzVG9HZW5lcmF0ZSk7XG4gICAgZW5kU2NoZW1hVGltZXIoKTtcblxuICAgIGNvbnN0IGVuZEdlbmVyYXRlVGltZXIgPSBsb2dUaW1lc3BhbihcIkdlbmVyYXRlIFRTXCIpO1xuICAgIGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgdGFyZ2V0cy5tYXAoKHRhcmdldCkgPT4gdGhpcy5nZW5lcmF0ZVR5cGVzY3JpcHQodGFyZ2V0LCBzY2hlbWFzKSlcbiAgICApO1xuICAgIGVuZEdlbmVyYXRlVGltZXIoKTtcblxuICAgIHRoaXMudXBkYXRlVmVyc2lvbnNGaWxlKGFsbENvbnN0cmFpbnRzKTtcbiAgICB0aGlzLmVtaXRDb25zdHJhaW50c0ZpbGUoYWxsQ29uc3RyYWludHMpO1xuXG4gICAgaWYgKHRoaXMuaXNKYXZhc2NyaXB0VGFyZ2V0KSB7XG4gICAgICBhd2FpdCB0aGlzLnNhdmUoKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuaXNKYXZhc2NyaXB0VGFyZ2V0IHx8IHRoaXMub3B0aW9ucy5vdXRwdXRKc2lpKSB7XG4gICAgICBjb25zdCBudW1iZXJPZldvcmtlcnMgPSBNYXRoLm1heChcbiAgICAgICAgMSxcbiAgICAgICAgdGhpcy5vcHRpb25zLmpzaWlQYXJhbGxlbGlzbSA9PT0gLTFcbiAgICAgICAgICA/IHRhcmdldHMubGVuZ3RoXG4gICAgICAgICAgOiB0aGlzLm9wdGlvbnMuanNpaVBhcmFsbGVsaXNtIHx8IDFcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IHdvcmsgPSBbLi4udGFyZ2V0c107XG4gICAgICBjb25zdCB3b3JrZXJzID0gbmV3IEFycmF5KG51bWJlck9mV29ya2VycykuZmlsbChhc3luYyAoKSA9PiB7XG4gICAgICAgIGxldCB0YXJnZXQ6IENvbnN0cnVjdHNNYWtlclRhcmdldCB8IHVuZGVmaW5lZDtcbiAgICAgICAgd2hpbGUgKCh0YXJnZXQgPSB3b3JrLnBvcCgpKSkge1xuICAgICAgICAgIGNvbnN0IGVuZEpzaWlUYXJnZXQgPSBsb2dUaW1lc3BhbihcbiAgICAgICAgICAgIGBHZW5lcmF0aW5nIEpTSUkgYmluZGluZ3MgZm9yICR7dGFyZ2V0Lm5hbWV9YFxuICAgICAgICAgICk7XG4gICAgICAgICAgYXdhaXQgdGhpcy5nZW5lcmF0ZUpzaWlMYW5ndWFnZSh0YXJnZXQpO1xuICAgICAgICAgIGVuZEpzaWlUYXJnZXQoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKHdvcmtlcnMubWFwKChmbikgPT4gZm4oKSkpO1xuICAgIH1cblxuICAgIGZvciAoY29uc3QgdGFyZ2V0IG9mIHRhcmdldHMpIHtcbiAgICAgIGF3YWl0IHRoaXMucmVwb3J0VGVsZW1ldHJ5KHtcbiAgICAgICAgdHJhY2tpbmdQYXlsb2FkOiB0YXJnZXQudHJhY2tpbmdQYXlsb2FkLFxuICAgICAgICB0YXJnZXRMYW5ndWFnZTogdGFyZ2V0LnRhcmdldExhbmd1YWdlLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNQeXRob25UYXJnZXQpIHtcbiAgICAgIGNvbnN0IGVuZFB5dGhvblRpbWVyID0gbG9nVGltZXNwYW4oXCJQeXRob24gcG9zdC1wcm9jZXNzaW5nXCIpO1xuICAgICAgLy8gUmVtb3ZlIGZyb20gLiBpbXBvcnQgLi4uIHN0YXRlbWVudHMgZnJvbSByb290IGxldmVsIF9faW5pdF9fLnB5XG4gICAgICAvLyBUaGlzIHJlbW92ZXMgcm9vdC1sZXZlbCBpbXBvcnRzIG9mIG5hbWVzcGFjZXMsIGJ1dCBzYXZlcyAyNXMgc3ludGggdGltZSBmb3IgdGhlIGF3cyBwcm92aWRlciBhbG9uZVxuICAgICAgY29uc3QgYWxsSW5pdFB5UGF0aHMgPSBnbG9iXG4gICAgICAgIC5zeW5jKFwiKiovX19pbml0X18ucHlcIiwge1xuICAgICAgICAgIGN3ZDogdGhpcy5jb2RlTWFrZXJPdXRkaXIsXG4gICAgICAgIH0pXG4gICAgICAgIC8vIHNvcnQgYnkgZGVwdGgsIHNvIHdlIHN0YXJ0IHdpdGggdGhlIHNoYWxsb3dlc3QgZmlsZXNcbiAgICAgICAgLnNvcnQoKGEsIGIpID0+IGEuc3BsaXQoXCIvXCIpLmxlbmd0aCAtIGIuc3BsaXQoXCIvXCIpLmxlbmd0aCk7XG5cbiAgICAgIGNvbnN0IHZpc2l0ZWREaXJlY3Rvcmllczogc3RyaW5nW10gPSBbXTtcbiAgICAgIGZvciAoY29uc3QgaW5pdFB5UGF0aCBvZiBhbGxJbml0UHlQYXRocykge1xuICAgICAgICBjb25zdCBkaXJlY3RvcnlQYXRoID0gcGF0aC5kaXJuYW1lKGluaXRQeVBhdGgpO1xuICAgICAgICBpZiAodmlzaXRlZERpcmVjdG9yaWVzLnNvbWUoKGRpcikgPT4gZGlyZWN0b3J5UGF0aC5zdGFydHNXaXRoKGRpcikpKSB7XG4gICAgICAgICAgLy8gd2UgYWxyZWFkeSBwcm9jZXNzZWQgdGhpcyBkaXJlY3RvcnlcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2aXNpdGVkRGlyZWN0b3JpZXMucHVzaChkaXJlY3RvcnlQYXRoKTtcblxuICAgICAgICBjb25zdCBhYnNvbHV0ZUluaXRQeVBhdGggPSBwYXRoLmpvaW4odGhpcy5jb2RlTWFrZXJPdXRkaXIsIGluaXRQeVBhdGgpO1xuICAgICAgICBjb25zdCBpbml0UHkgPSBhd2FpdCBmcy5yZWFkRmlsZShhYnNvbHV0ZUluaXRQeVBhdGgsIFwidXRmOFwiKTtcbiAgICAgICAgY29uc3QgaW5pdFB5V2l0aG91dEltcG9ydHMgPSBpbml0UHkucmVwbGFjZSgvZnJvbSBcXC4gaW1wb3J0IC4qXFxuL2csIFwiXCIpO1xuICAgICAgICBhd2FpdCBmcy53cml0ZUZpbGUoYWJzb2x1dGVJbml0UHlQYXRoLCBpbml0UHlXaXRob3V0SW1wb3J0cyk7XG4gICAgICB9XG5cbiAgICAgIGVuZFB5dGhvblRpbWVyKCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBzYXZlKG91dGRpciA9IHRoaXMuY29kZU1ha2VyT3V0ZGlyKSB7XG4gICAgYXdhaXQgdGhpcy5jb2RlLnNhdmUob3V0ZGlyKTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0IGlzSmF2YXNjcmlwdFRhcmdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLnRhcmdldExhbmd1YWdlID09PSBMYW5ndWFnZS5UWVBFU0NSSVBUO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXQgaXNQeXRob25UYXJnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy50YXJnZXRMYW5ndWFnZSA9PT0gTGFuZ3VhZ2UuUFlUSE9OO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXQgaXNKYXZhVGFyZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMudGFyZ2V0TGFuZ3VhZ2UgPT09IExhbmd1YWdlLkpBVkE7XG4gIH1cblxuICBwcml2YXRlIGdldCBpc0NzaGFycFRhcmdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLnRhcmdldExhbmd1YWdlID09PSBMYW5ndWFnZS5DU0hBUlA7XG4gIH1cblxuICBwcml2YXRlIGdldCBpc0dvVGFyZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMudGFyZ2V0TGFuZ3VhZ2UgPT09IExhbmd1YWdlLkdPO1xuICB9XG59XG5cbi8qKlxuICogc2VhcmNoZXMgZm9yIHRoZSBjbG9zZXN0IGBnby5tb2RgIGZpbGUgYW5kIHJldHVybnMgdGhlIG5lc3RlZCBnbyBtb2R1bGUgbmFtZSBmb3IgYGRpcmBcbiAqIGUuZy4gKC9kaXIvLmdlbi8pID0+IGNkay50Zi9zdGFjay8uZ2VuIGlmIHRoZSBwYXJlbnQgZGlyIG9mIC5nZW4gaGFzIGEgZ28ubW9kIGZvciBcIm1vZHVsZSBjZGsudGYvc3RhY2tcIlxuICpcbiAqIEBwYXJhbSBkaXIgdGhlIGRpcmVjdG9yeSB0byBzdGFydCB0aGUgc2VhcmNoIGZyb20gKHNlYXJjaGVzIHVwd2FyZHMpXG4gKiBAcmV0dXJucyB0aGUgcGFja2FnZSBuYW1lIGZvciBgZGlyYFxuICogQHRocm93cyBhbiBFcnJvciBpZiBubyBnby5tb2Qgd2FzIGZvdW5kXG4gKi9cbmV4cG9ydCBjb25zdCBkZXRlcm1pbmVHb01vZHVsZU5hbWUgPSBhc3luYyAoZGlyOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4gPT4ge1xuICBsZXQgcHJldmlvdXNEaXI7XG4gIGxldCBjdXJyZW50RGlyID0gcGF0aC5yZXNvbHZlKGRpcik7XG5cbiAgZG8ge1xuICAgIGxldCBmaWxlczogc3RyaW5nW10gPSBbXTtcbiAgICB0cnkge1xuICAgICAgZmlsZXMgPSBhd2FpdCBmcy5yZWFkZGlyKGN1cnJlbnREaXIpO1xuICAgIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgICAgLy8gZGlyZWN0b3J5IG1pZ2h0IG5vdCBleGlzdCB5ZXQsIGJ1dCB3ZSBzdGlsbCB3YWxrIHVwd2FyZHMgZnJvbSB0aGVyZSwgc28gaWdub3JlICdFTk9FTlQnXG4gICAgICBpZiAoZS5jb2RlICE9PSBcIkVOT0VOVFwiKSB7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChmaWxlcy5pbmNsdWRlcyhcImdvLm1vZFwiKSkge1xuICAgICAgY29uc3QgZmlsZSA9IHBhdGgucmVzb2x2ZShjdXJyZW50RGlyLCBcImdvLm1vZFwiKTtcbiAgICAgIGNvbnN0IGdvbW9kID0gYXdhaXQgZnMucmVhZEZpbGUoZmlsZSk7XG4gICAgICBjb25zdCBtYXRjaCA9IC9ebW9kdWxlXFxzKihcXFMqKVxccyokL20uZXhlYyhnb21vZC50b1N0cmluZygpKTtcbiAgICAgIGlmIChtYXRjaCAmJiBtYXRjaFsxXSkge1xuICAgICAgICBjb25zdCBjaGlsZGRpciA9IHBhdGgucmVsYXRpdmUoY3VycmVudERpciwgZGlyKS5yZXBsYWNlKC9cXFxcL2csIFwiL1wiKTsgLy8gcmVwbGFjZSAnXFwnIHdpdGggJy8nIGZvciB3aW5kb3dzIHBhdGhzXG4gICAgICAgIHJldHVybiBjaGlsZGRpci5sZW5ndGggPiAwID8gYCR7bWF0Y2hbMV19LyR7Y2hpbGRkaXJ9YCA6IG1hdGNoWzFdO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQ291bGQgbm90IGRldGVybWluZSB0aGUgcm9vdCBHbyBtb2R1bGUgbmFtZS4gRm91bmQgJHtmaWxlfSBidXQgZmFpbGVkIHRvIHJlZ2V4IG1hdGNoIHRoZSBtb2R1bGUgbmFtZSBkaXJlY3RpdmVgXG4gICAgICApO1xuICAgIH1cbiAgICAvLyBnbyB1cCBvbmUgZGlyZWN0b3J5LiBBcyBkaXJuYW1lKCcvJykgd2lsbCByZXR1cm4gJy8nIHdlIGNhbmNlbCB0aGUgbG9vcFxuICAgIC8vIGFzIHNvb24gYXMgdGhlIGRpciBkb2VzIG5vdCBjaGFuZ2UgYW55bW9yZS5cbiAgICBwcmV2aW91c0RpciA9IGN1cnJlbnREaXI7XG4gICAgY3VycmVudERpciA9IHBhdGguZGlybmFtZShjdXJyZW50RGlyKTtcbiAgfSB3aGlsZSAoY3VycmVudERpciAhPT0gcHJldmlvdXNEaXIpO1xuXG4gIHRocm93IG5ldyBFcnJvcihcbiAgICBgQ291bGQgbm90IGRldGVybWluZSB0aGUgcm9vdCBHbyBtb2R1bGUgbmFtZS4gTm8gZ28ubW9kIGZvdW5kIGluICR7ZGlyfSBhbmQgYW55IHBhcmVudCBkaXJlY3Rvcmllc2BcbiAgKTtcbn07XG4iXX0=