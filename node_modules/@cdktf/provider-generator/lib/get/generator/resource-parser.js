"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ResourceParser = exports.sanitizeClassOrNamespaceName = void 0;
// Copyright (c) HashiCorp, Inc
// SPDX-License-Identifier: MPL-2.0
const codemaker_1 = require("codemaker");
const commons_1 = require("@cdktf/commons");
const provider_schema_1 = require("@cdktf/provider-schema");
const models_1 = require("./models");
const loop_detection_1 = require("./loop-detection");
const skipped_attributes_1 = require("./skipped-attributes");
const commons_2 = require("@cdktf/commons");
// Can't be used in expressions like "export * as <keyword> from ... "
// filtered from all keywords from: https://github.com/microsoft/TypeScript/blob/503604c884bd0557c851b11b699ef98cdb65b93b/src/compiler/types.ts#L114-L197
const RESERVED_KEYWORDS_FOR_NAMESPACES = [
    "implements",
    "interface",
    "let",
    "package",
    "private",
    "protected",
    "public",
    "static",
    "yield",
    "await",
];
const COLLIDING_NAMESPACE_NAMES = [
    // e.g. hashicorp/consul – collides with the LICENSE file on case-insensitive filesystems in the Go package (#2627)
    "license",
];
const isReservedClassOrNamespaceName = (className) => {
    return [
        "string",
        "object",
        "function",
        ...RESERVED_KEYWORDS_FOR_NAMESPACES,
        ...COLLIDING_NAMESPACE_NAMES,
    ].includes(className.toLowerCase());
};
const isReservedStructClassName = (className) => {
    return className.toLowerCase().endsWith("list");
};
const getFileName = (provider, baseName) => {
    if (baseName === "index") {
        return "index-resource/index.ts";
    }
    if (baseName === `${provider}_provider`) {
        return "provider/index.ts";
    }
    return `${(0, codemaker_1.toSnakeCase)(baseName).replace(/_/g, "-")}/index.ts`;
};
function sanitizeClassOrNamespaceName(baseName, isProvider = false) {
    const resourceIsNamedProvider = !isProvider && baseName === "provider";
    if (isReservedClassOrNamespaceName(baseName) || resourceIsNamedProvider) {
        return `${baseName}_resource`;
    }
    else {
        return baseName;
    }
}
exports.sanitizeClassOrNamespaceName = sanitizeClassOrNamespaceName;
/**
 * Remove attributes that may conflict after being snake cased
 * Example: oci_core_ipsec_connection_tunnel_management (hashicorp/oci@=5.21.0) has bgp_ipv6_state and bgp_ipv6state
 * (which both result in "bgpIpv6State" when camel-cased, with the second one being deprecated: true)
 * As we currently don't handle any deprecated ones at all, we'll just delete one of the two attributes for now
 * @param attributes
 */
function deduplicateAttributesWithSameName(attributes) {
    return attributes.filter((attr, idx) => {
        const hasOtherWithSameName = attributes
            .slice(idx + 1) // only search after the index of the current attribute to avoid deleting both
            .some((other) => other.name === attr.name && other !== attr);
        return !hasOtherWithSameName;
    });
}
class Parser {
    constructor(classNames) {
        this.classNames = classNames;
        this.structs = new Array();
    }
    uniqueClassName(className) {
        if (this.classNames.includes(className)) {
            className = `${className}A`;
        }
        this.classNames.push(className);
        return className;
    }
    resourceFrom(fqpn, type, schema, terraformSchemaType, constraint) {
        let baseName = type;
        const providerNameFromConstraint = constraint
            ? constraint.name
            : undefined;
        const providerNameFromFQPN = (0, provider_schema_1.parseFQPN)(fqpn).name;
        if (baseName.startsWith(`${providerNameFromFQPN}_`)) {
            baseName = baseName.substr(providerNameFromFQPN.length + 1);
        }
        const providerName = providerNameFromConstraint
            ? providerNameFromConstraint
            : providerNameFromFQPN;
        const isProvider = terraformSchemaType === "provider";
        if (isProvider) {
            baseName = `${providerName}_${baseName}`;
            if (!("attributes" in schema.block)) {
                schema.block = {
                    attributes: {},
                    block_types: schema.block.block_types || {},
                };
            }
            // somehow missing from provider schema
            schema.block.attributes["alias"] = {
                type: "string",
                description: "Alias name",
                optional: true,
                computed: false,
            };
        }
        baseName = sanitizeClassOrNamespaceName(baseName, isProvider);
        const className = this.uniqueClassName((0, codemaker_1.toPascalCase)(baseName));
        // avoid naming collision - see https://github.com/hashicorp/terraform-cdk/issues/299
        const configStructName = this.uniqueClassName(`${className}Config`);
        const fileName = getFileName(providerName, baseName);
        const filePath = `providers/${(0, codemaker_1.toSnakeCase)(providerName)}/${fileName}`;
        let attributes = this.renderAttributesForBlock(new models_1.Scope({
            name: baseName,
            isProvider,
            parent: isProvider
                ? undefined
                : new models_1.Scope({ name: providerName, isProvider: true }),
        }), schema.block);
        function getStructAttribute(attributes, path) {
            const [first, ...rest] = path.split(".");
            const attribute = attributes.find((att) => {
                return att.terraformName === first;
            });
            if (!attribute)
                throw new Error(`Expected to find recursive attribute at path: ${path}`);
            if (!attribute.type.struct)
                throw new Error(`Expected to find struct type attribute at path: ${path} but got ${attribute.type.storedClassType}`);
            if (rest.length === 0)
                return attribute;
            return getStructAttribute(attribute.type.struct.attributes, rest.join("."));
        }
        // Introduce recursion for some attributes
        const recursiveAttributePaths = (0, loop_detection_1.detectAttributeLoops)(attributes);
        Object.entries(recursiveAttributePaths).forEach(([attributePath, structPath]) => {
            // TODO: build this to be a bit more defensive (e.g. remove ! operator)
            const recursionTargetStructAttribute = getStructAttribute(attributes, structPath);
            const parts = attributePath.split(".");
            const attributeName = parts.pop();
            const parentAttribute = getStructAttribute(attributes, parts.join("."));
            const indexToReplace = parentAttribute.type.struct.attributes.findIndex((att) => att.terraformName === attributeName);
            if (indexToReplace === -1)
                throw new Error("Can't find attribute at path " + attributePath);
            const previousAttribute = parentAttribute.type.struct.attributes[indexToReplace];
            parentAttribute.type.struct.attributes[indexToReplace] =
                recursionTargetStructAttribute; // introduce recursion
            // ugly, pls c̶a̶l̶l̶ refactor me maybe
            // we store all structs in this.structs – now we need to dispose all structs that are part of previousAttribute
            const disposeStructs = (attr) => {
                if (attr.type.struct) {
                    attr.type.struct.attributes.forEach(disposeStructs);
                    this.structs = this.structs.filter((s) => s !== attr.type.struct);
                }
            };
            disposeStructs(previousAttribute);
        });
        attributes = deduplicateAttributesWithSameName(attributes);
        const resourceModel = new models_1.ResourceModel({
            terraformType: type,
            baseName,
            fileName,
            filePath,
            className,
            schema,
            fqpn,
            attributes,
            terraformSchemaType,
            structs: this.structs,
            configStructName,
        });
        return resourceModel;
    }
    renderAttributeType(scope, attributeType, parentKind) {
        const parent = scope[scope.length - 1];
        if ((0, skipped_attributes_1.shouldSkipAttribute)(parent.baseName)) {
            return new models_1.MapAttributeTypeModel(new models_1.SimpleAttributeTypeModel("any"));
        }
        if (typeof attributeType === "string") {
            switch (attributeType) {
                case "bool":
                    return new models_1.SimpleAttributeTypeModel("boolean");
                case "string":
                    return new models_1.SimpleAttributeTypeModel("string");
                case "number":
                    return new models_1.SimpleAttributeTypeModel("number");
                case "dynamic":
                    return new models_1.MapAttributeTypeModel(new models_1.SimpleAttributeTypeModel("any"));
                default:
                    throw new Error(`invalid primitive type ${attributeType}`);
            }
        }
        if (Array.isArray(attributeType)) {
            if (attributeType.length !== 2) {
                throw new Error(`unexpected array`);
            }
            const [kind, type] = attributeType;
            if (kind === "set" || kind === "list") {
                const elementType = this.renderAttributeType(scope, type, [kind, parentKind].join(""));
                return kind === "list"
                    ? new models_1.ListAttributeTypeModel(elementType, false, false)
                    : new models_1.SetAttributeTypeModel(elementType, false, false);
            }
            if (kind === "map") {
                const valueType = this.renderAttributeType(scope, type, [kind, parentKind].join(""));
                return new models_1.MapAttributeTypeModel(valueType);
            }
            if (kind === "object") {
                const objAttributes = type;
                const attributes = {};
                for (const [name, type] of Object.entries(objAttributes)) {
                    attributes[name] = { type };
                }
                const struct = this.addAnonymousStruct(scope, attributes, parentKind !== null && parentKind !== void 0 ? parentKind : kind);
                return new models_1.StructAttributeTypeModel(struct);
            }
        }
        if ((0, commons_1.isAttributeNestedType)(attributeType)) {
            let struct = undefined;
            let typeModel = undefined;
            switch (attributeType.nesting_mode) {
                case "list":
                    struct = this.addAnonymousStruct(scope, attributeType.attributes, attributeType.nesting_mode);
                    typeModel = new models_1.ListAttributeTypeModel(new models_1.StructAttributeTypeModel(struct), false, false);
                    break;
                case "set":
                    struct = this.addAnonymousStruct(scope, attributeType.attributes, attributeType.nesting_mode);
                    typeModel = new models_1.SetAttributeTypeModel(new models_1.StructAttributeTypeModel(struct), false, false);
                    break;
                case "map":
                    struct = this.addAnonymousStruct(scope, attributeType.attributes, attributeType.nesting_mode);
                    typeModel = new models_1.MapAttributeTypeModel(new models_1.StructAttributeTypeModel(struct));
                    break;
                case "single":
                    struct = this.addAnonymousStruct(scope, attributeType.attributes, attributeType.nesting_mode);
                    typeModel = new models_1.StructAttributeTypeModel(struct);
                    break;
                default: {
                    throw new Error(`nested_type with nesting_mode "${attributeType.nesting_mode}" not supported (attribute scope: ${scope
                        .map((s) => s.fullName)
                        .join(",")}`);
                }
            }
            return typeModel;
        }
        throw new Error(`unknown type ${JSON.stringify(attributeType)}`);
    }
    renderAttributesForBlock(parentType, block) {
        const attributes = new Array();
        for (const [terraformAttributeName, att] of Object.entries(block.attributes || {})) {
            if ((0, skipped_attributes_1.shouldSkipAttribute)(parentType.fullName(terraformAttributeName))) {
                throw commons_2.Errors.Internal(`Skipping attribute ${parentType.fullName(terraformAttributeName)} is not implemented since it's an attribute and not a block type`);
            }
            const type = this.renderAttributeType([
                parentType,
                new models_1.Scope({
                    name: terraformAttributeName,
                    parent: parentType,
                    isProvider: parentType.isProvider,
                    isComputed: !!att.computed,
                    isOptional: !!att.optional,
                    isRequired: !!att.required,
                    isNestedType: (0, commons_1.isNestedTypeAttribute)(att),
                }),
            ], att.type || att.nested_type);
            const name = (0, codemaker_1.toCamelCase)(terraformAttributeName);
            attributes.push(new models_1.AttributeModel({
                terraformFullName: parentType.fullName(terraformAttributeName),
                description: att.description,
                name,
                storageName: `_${name}`,
                computed: !!att.computed,
                optional: !!att.optional,
                terraformName: terraformAttributeName,
                type,
                provider: parentType.isProvider,
                required: !!att.required,
            }));
        }
        for (const [blockTypeName, blockType] of Object.entries(block.block_types || {})) {
            if ((0, skipped_attributes_1.shouldSkipAttribute)(parentType.fullName(blockTypeName))) {
                const name = (0, codemaker_1.toCamelCase)(blockTypeName);
                const parent = new models_1.Scope({
                    name: blockTypeName,
                    parent: parentType,
                    isProvider: parentType.isProvider,
                });
                attributes.push(new models_1.AttributeModel({
                    name,
                    terraformName: blockTypeName,
                    terraformFullName: parent.fullName(blockTypeName),
                    type: new models_1.SkippedAttributeTypeModel(),
                    description: `${blockTypeName} block`,
                    storageName: `_${name}`,
                    optional: true,
                    computed: false,
                    provider: parentType.isProvider,
                    required: false,
                }));
                continue;
            }
            // create a struct for this block
            let blockAttributes = this.renderAttributesForBlock(new models_1.Scope({
                name: `${parentType.name}_${blockTypeName}`,
                parent: parentType,
                isProvider: parentType.isProvider,
                inBlockType: true,
            }), blockType.block);
            blockAttributes = deduplicateAttributesWithSameName(blockAttributes);
            const blockStruct = this.addStruct([
                parentType,
                new models_1.Scope({
                    name: blockTypeName,
                    parent: parentType,
                    isProvider: parentType.isProvider,
                }),
            ], blockAttributes, blockType.nesting_mode, (blockType.nesting_mode === "list" ||
                blockType.nesting_mode === "set") &&
                blockType.max_items === 1);
            // define the attribute
            attributes.push(attributeForBlockType(blockTypeName, blockType, blockStruct, parentType.isProvider, parentType));
        }
        return attributes;
        function attributeForBlockType(terraformName, blockType, struct, isProvider, parent) {
            const name = (0, codemaker_1.toCamelCase)(terraformName);
            let optional;
            let required;
            switch (blockType.nesting_mode) {
                case "single":
                    optional = !struct.attributes.some((x) => !x.optional);
                    required = !struct.attributes.some((x) => !x.required);
                    return new models_1.AttributeModel({
                        name,
                        terraformName,
                        terraformFullName: parent.fullName(terraformName),
                        type: new models_1.StructAttributeTypeModel(struct),
                        description: `${terraformName} block`,
                        storageName: `_${name}`,
                        optional,
                        computed: false,
                        provider: isProvider,
                        required,
                    });
                case "map":
                    return new models_1.AttributeModel({
                        name,
                        terraformName,
                        terraformFullName: parent.fullName(terraformName),
                        type: new models_1.MapAttributeTypeModel(new models_1.StructAttributeTypeModel(struct)),
                        description: `${terraformName} block`,
                        storageName: `_${name}`,
                        optional: false,
                        computed: false,
                        provider: isProvider,
                        required: false,
                    });
                case "list":
                case "set":
                    optional =
                        blockType.min_items === undefined ? true : blockType.min_items < 1;
                    required =
                        blockType.min_items === undefined ? false : blockType.min_items > 0;
                    return new models_1.AttributeModel({
                        name,
                        terraformName: terraformName,
                        terraformFullName: parent.fullName(terraformName),
                        type: blockType.nesting_mode === "list"
                            ? new models_1.ListAttributeTypeModel(new models_1.StructAttributeTypeModel(struct), blockType.max_items === 1, true)
                            : new models_1.SetAttributeTypeModel(new models_1.StructAttributeTypeModel(struct), blockType.max_items === 1, true),
                        description: `${terraformName} block`,
                        storageName: `_${name}`,
                        optional,
                        computed: false,
                        provider: isProvider,
                        required,
                    });
            }
        }
    }
    addAnonymousStruct(scope, attrs, nesting_mode) {
        let attributes = new Array();
        const parent = scope[scope.length - 1];
        if (attrs) {
            for (const [terraformName, att] of Object.entries(attrs || {})) {
                // nested types support computed, optional and required on attribute level
                // if parent is computed, child always is computed as well
                const computed = !!parent.isComputed || (parent.isNestedType && !!att.computed);
                const optional = parent.isNestedType
                    ? !!att.optional
                    : !!parent.isOptional;
                const required = parent.isNestedType
                    ? !!att.required
                    : !!parent.isRequired;
                const name = (0, codemaker_1.toCamelCase)(terraformName);
                const type = this.renderAttributeType([
                    ...scope,
                    new models_1.Scope({
                        name: terraformName,
                        parent,
                        isProvider: parent.isProvider,
                        isComputed: computed,
                        isOptional: optional,
                        isRequired: required,
                        isNestedType: parent.isNestedType,
                    }),
                ], att.type || att.nested_type);
                attributes.push(new models_1.AttributeModel({
                    name,
                    storageName: `_${name}`,
                    computed: computed,
                    description: att.description,
                    optional: optional,
                    terraformName,
                    terraformFullName: parent.fullName(terraformName),
                    type,
                    provider: parent.isProvider,
                    required: required,
                }));
            }
        }
        attributes = deduplicateAttributesWithSameName(attributes);
        return this.addStruct(scope, attributes, nesting_mode);
    }
    addStruct(scope, attributes, nesting_mode, isSingleItem = false) {
        const possibleName = (0, codemaker_1.toPascalCase)(scope.map((x) => (0, codemaker_1.toSnakeCase)(x.name)).join("_"));
        const name = this.uniqueClassName(isReservedStructClassName(possibleName)
            ? `${possibleName}Struct`
            : possibleName);
        const parent = scope[scope.length - 1];
        // blockType.nesting_mode => list/set & blockType.max_items === 1,
        const isClass = (parent.isComputed && !parent.isOptional) || isSingleItem;
        const isAnonymous = true;
        const s = new models_1.Struct(name, attributes, isClass, isAnonymous, isSingleItem, nesting_mode);
        this.structs.push(s);
        return s;
    }
}
class ResourceParser {
    constructor() {
        this.uniqueClassnames = [];
        this.resources = {};
    }
    parse(fqpn, type, schema, terraformType, constraint) {
        if (this.resources[type]) {
            return this.resources[type];
        }
        const parser = new Parser(this.uniqueClassnames);
        const resource = parser.resourceFrom(fqpn, type, schema, terraformType, constraint);
        this.resources[type] = resource;
        return resource;
    }
    // Used by convert to determine the right name for a class
    getClassNameForResource(terraformType) {
        const resource = this.resources[terraformType];
        return resource ? resource.className : "";
    }
    // Used by convert to determine the right name for a namespace
    getNamespaceNameForResource(terraformType) {
        // Special case external provider since the name of resource doesn't have a prefix
        if (terraformType === "data_external_") {
            terraformType = "data_external";
        }
        const resource = this.resources[terraformType];
        if (!resource) {
            return "";
        }
        const folder = `providers/${resource.provider}`;
        return resource.filePath.replace(`${folder}/`, "").replace("/index.ts", "");
    }
}
exports.ResourceParser = ResourceParser;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVzb3VyY2UtcGFyc2VyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsicmVzb3VyY2UtcGFyc2VyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLCtCQUErQjtBQUMvQixtQ0FBbUM7QUFDbkMseUNBQW1FO0FBQ25FLDRDQVV3QjtBQUN4Qiw0REFBdUU7QUFDdkUscUNBWWtCO0FBQ2xCLHFEQUF3RDtBQUN4RCw2REFBMkQ7QUFDM0QsNENBQXdDO0FBRXhDLHNFQUFzRTtBQUN0RSx5SkFBeUo7QUFDekosTUFBTSxnQ0FBZ0MsR0FBRztJQUN2QyxZQUFZO0lBQ1osV0FBVztJQUNYLEtBQUs7SUFDTCxTQUFTO0lBQ1QsU0FBUztJQUNULFdBQVc7SUFDWCxRQUFRO0lBQ1IsUUFBUTtJQUNSLE9BQU87SUFDUCxPQUFPO0NBQ1IsQ0FBQztBQUVGLE1BQU0seUJBQXlCLEdBQUc7SUFDaEMsbUhBQW1IO0lBQ25ILFNBQVM7Q0FDVixDQUFDO0FBRUYsTUFBTSw4QkFBOEIsR0FBRyxDQUFDLFNBQWlCLEVBQVcsRUFBRTtJQUNwRSxPQUFPO1FBQ0wsUUFBUTtRQUNSLFFBQVE7UUFDUixVQUFVO1FBQ1YsR0FBRyxnQ0FBZ0M7UUFDbkMsR0FBRyx5QkFBeUI7S0FDN0IsQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDLFdBQVcsRUFBRSxDQUFDLENBQUM7QUFDdEMsQ0FBQyxDQUFDO0FBRUYsTUFBTSx5QkFBeUIsR0FBRyxDQUFDLFNBQWlCLEVBQVcsRUFBRTtJQUMvRCxPQUFPLFNBQVMsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLENBQUM7QUFDbEQsQ0FBQyxDQUFDO0FBRUYsTUFBTSxXQUFXLEdBQUcsQ0FBQyxRQUFzQixFQUFFLFFBQWdCLEVBQVUsRUFBRTtJQUN2RSxJQUFJLFFBQVEsS0FBSyxPQUFPLEVBQUU7UUFDeEIsT0FBTyx5QkFBeUIsQ0FBQztLQUNsQztJQUVELElBQUksUUFBUSxLQUFLLEdBQUcsUUFBUSxXQUFX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QUMsT0FBTyxDQUFDLFdBQVcsRUFBRSxFQUFFLENBQUMsQ0FBQztJQUM5RSxDQUFDO0NBQ0Y7QUEvQ0Qsd0NBK0NDIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSBIYXNoaUNvcnAsIEluY1xuLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1QTC0yLjBcbmltcG9ydCB7IHRvQ2FtZWxDYXNlLCB0b1Bhc2NhbENhc2UsIHRvU25ha2VDYXNlIH0gZnJvbSBcImNvZGVtYWtlclwiO1xuaW1wb3J0IHtcbiAgQXR0cmlidXRlLFxuICBBdHRyaWJ1dGVOZXN0ZWRUeXBlLFxuICBBdHRyaWJ1dGVUeXBlLFxuICBCbG9jayxcbiAgQmxvY2tUeXBlLFxuICBDb25zdHJ1Y3RzTWFrZXJUYXJnZXQsXG4gIGlzQXR0cmlidXRlTmVzdGVkVHlwZSxcbiAgaXNOZXN0ZWRUeXBlQXR0cmlidXRlLFxuICBTY2hlbWEsXG59IGZyb20gXCJAY2RrdGYvY29tbW9uc1wiO1xuaW1wb3J0IHsgUHJvdmlkZXJOYW1lLCBGUVBOLCBwYXJzZUZRUE4gfSBmcm9tIFwiQGNka3RmL3Byb3ZpZGVyLXNjaGVtYVwiO1xuaW1wb3J0IHtcbiAgUmVzb3VyY2VNb2RlbCxcbiAgQXR0cmlidXRlVHlwZU1vZGVsLFxuICBTdHJ1Y3QsXG4gIFNjb3BlLFxuICBBdHRyaWJ1dGVNb2RlbCxcbiAgU2ltcGxlQXR0cmlidXRlVHlwZU1vZGVsLFxuICBMaXN0QXR0cmlidXRlVHlwZU1vZGVsLFxuICBTZXRBdHRyaWJ1dGVUeXBlTW9kZWwsXG4gIE1hcEF0dHJpYnV0ZVR5cGVNb2RlbCxcbiAgU3RydWN0QXR0cmlidXRlVHlwZU1vZGVsLFxuICBTa2lwcGVkQXR0cmlidXRlVHlwZU1vZGVsLFxufSBmcm9tIFwiLi9tb2RlbHNcIjtcbmltcG9ydCB7IGRldGVjdEF0dHJpYnV0ZUxvb3BzIH0gZnJvbSBcIi4vbG9vcC1kZXRlY3Rpb25cIjtcbmltcG9ydCB7IHNob3VsZFNraXBBdHRyaWJ1dGUgfSBmcm9tIFwiLi9za2lwcGVkLWF0dHJpYnV0ZXNcIjtcbmltcG9ydCB7IEVycm9ycyB9IGZyb20gXCJAY2RrdGYvY29tbW9uc1wiO1xuXG4vLyBDYW4ndCBiZSB1c2VkIGluIGV4cHJlc3Npb25zIGxpa2UgXCJleHBvcnQgKiBhcyA8a2V5d29yZD4gZnJvbSAuLi4gXCJcbi8vIGZpbHRlcmVkIGZyb20gYWxsIGtleXdvcmRzIGZyb206IGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvVHlwZVNjcmlwdC9ibG9iLzUwMzYwNGM4ODRiZDA1NTdjODUxYjExYjY5OWVmOThjZGI2NWI5M2Ivc3JjL2NvbXBpbGVyL3R5cGVzLnRzI0wxMTQtTDE5N1xuY29uc3QgUkVTRVJWRURfS0VZV09SRFNfRk9SX05BTUVTUEFDRVMgPSBbXG4gIFwiaW1wbGVtZW50c1wiLFxuICBcImludGVyZmFjZVwiLFxuICBcImxldFwiLFxuICBcInBhY2thZ2VcIixcbiAgXCJwcml2YXRlXCIsXG4gIFwicHJvdGVjdGVkXCIsXG4gIFwicHVibGljXCIsXG4gIFwic3RhdGljXCIsXG4gIFwieWllbGRcIixcbiAgXCJhd2FpdFwiLFxuXTtcblxuY29uc3QgQ09MTElESU5HX05BTUVTUEFDRV9OQU1FUyA9IFtcbiAgLy8gZS5nLiBoYXNoaWNvcnAvY29uc3VsIOKAkyBjb2xsaWRlcyB3aXRoIHRoZSBMSUNFTlNFIGZpbGUgb24gY2FzZS1pbnNlbnNpdGl2ZSBmaWxlc3lzdGVtcyBpbiB0aGUgR28gcGFja2FnZSAoIzI2MjcpXG4gIFwibGljZW5zZVwiLFxuXTtcblxuY29uc3QgaXNSZXNlcnZlZENsYXNzT3JOYW1lc3BhY2VOYW1lID0gKGNsYXNzTmFtZTogc3RyaW5nKTogYm9vbGVhbiA9PiB7XG4gIHJldHVybiBbXG4gICAgXCJzdHJpbmdcIixcbiAgICBcIm9iamVjdFwiLFxuICAgIFwiZnVuY3Rpb25cIixcbiAgICAuLi5SRVNFUlZFRF9LRVlXT1JEU19GT1JfTkFNRVNQQUNFUyxcbiAgICAuLi5DT0xMSURJTkdfTkFNRVNQQUNFX05BTUVTLFxuICBdLmluY2x1ZGVzKGNsYXNzTmFtZS50b0xvd2VyQ2FzZSgpKTtcbn07XG5cbmNvbnN0IGlzUmVzZXJ2ZWRTdHJ1Y3RDbGFzc05hbWUgPSAoY2xhc3NOYW1lOiBzdHJpbmcpOiBib29sZWFuID0+IHtcbiAgcmV0dXJuIGNsYXNzTmFtZS50b0xvd2VyQ2FzZSgpLmVuZHNXaXRoKFwibGlzdFwiKTtcbn07XG5cbmNvbnN0IGdldEZpbGVOYW1lID0gKHByb3ZpZGVyOiBQcm92aWRlck5hbWUsIGJhc2VOYW1lOiBzdHJpbmcpOiBzdHJpbmcgPT4ge1xuICBpZiAoYmFzZU5hbWUgPT09IFwiaW5kZXhcIikge1xuICAgIHJldHVybiBcImluZGV4LXJlc291cmNlL2luZGV4LnRzXCI7XG4gIH1cblxuICBpZiAoYmFzZU5hbWUgPT09IGAke3Byb3ZpZGVyfV9wcm92aWRlcmApIHtcbiAgICByZXR1cm4gXCJwcm92aWRlci9pbmRleC50c1wiO1xuICB9XG5cbiAgcmV0dXJuIGAke3RvU25ha2VDYXNlKGJhc2VOYW1lKS5yZXBsYWNlKC9fL2csIFwiLVwiKX0vaW5kZXgudHNgO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIHNhbml0aXplQ2xhc3NPck5hbWVzcGFjZU5hbWUoXG4gIGJhc2VOYW1lOiBzdHJpbmcsXG4gIGlzUHJvdmlkZXIgPSBmYWxzZVxuKSB7XG4gIGNvbnN0IHJlc291cmNlSXNOYW1lZFByb3ZpZGVyID0gIWlzUHJvdmlkZXIgJiYgYmFzZU5hbWUgPT09IFwicHJvdmlkZXJcIjtcblxuICBpZiAoaXNSZXNlcnZlZENsYXNzT3JOYW1lc3BhY2VOYW1lKGJhc2VOYW1lKSB8fCByZXNvdXJjZUlzTmFtZWRQcm92aWRlcikge1xuICAgIHJldHVybiBgJHtiYXNlTmFtZX1fcmVzb3VyY2VgO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlTmFtZTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZSBhdHRyaWJ1dGVzIHRoYXQgbWF5IGNvbmZsaWN0IGFmdGVyIGJlaW5nIHNuYWtlIGNhc2VkXG4gKiBFeGFtcGxlOiBvY2lfY29yZV9pcHNlY19jb25uZWN0aW9uX3R1bm5lbF9tYW5hZ2VtZW50IChoYXNoaWNvcnAvb2NpQD01LjIxLjApIGhhcyBiZ3BfaXB2Nl9zdGF0ZSBhbmQgYmdwX2lwdjZzdGF0ZVxuICogKHdoaWNoIGJvdGggcmVzdWx0IGluIFwiYmdwSXB2NlN0YXRlXCIgd2hlbiBjYW1lbC1jYXNlZCwgd2l0aCB0aGUgc2Vjb25kIG9uZSBiZWluZyBkZXByZWNhdGVkOiB0cnVlKVxuICogQXMgd2UgY3VycmVudGx5IGRvbid0IGhhbmRsZSBhbnkgZGVwcmVjYXRlZCBvbmVzIGF0IGFsbCwgd2UnbGwganVzdCBkZWxldGUgb25lIG9mIHRoZSB0d28gYXR0cmlidXRlcyBmb3Igbm93XG4gKiBAcGFyYW0gYXR0cmlidXRlc1xuICovXG5mdW5jdGlvbiBkZWR1cGxpY2F0ZUF0dHJpYnV0ZXNXaXRoU2FtZU5hbWUoXG4gIGF0dHJpYnV0ZXM6IEF0dHJpYnV0ZU1vZGVsW11cbik6IEF0dHJpYnV0ZU1vZGVsW10ge1xuICByZXR1cm4gYXR0cmlidXRlcy5maWx0ZXIoKGF0dHIsIGlkeCkgPT4ge1xuICAgIGNvbnN0IGhhc090aGVyV2l0aFNhbWVOYW1lID0gYXR0cmlidXRlc1xuICAgICAgLnNsaWNlKGlkeCArIDEpIC8vIG9ubHkgc2VhcmNoIGFmdGVyIHRoZSBpbmRleCBvZiB0aGUgY3VycmVudCBhdHRyaWJ1dGUgdG8gYXZvaWQgZGVsZXRpbmcgYm90aFxuICAgICAgLnNvbWUoKG90aGVyKSA9PiBvdGhlci5uYW1lID09PSBhdHRyLm5hbWUgJiYgb3RoZXIgIT09IGF0dHIpO1xuICAgIHJldHVybiAhaGFzT3RoZXJXaXRoU2FtZU5hbWU7XG4gIH0pO1xufVxuXG5jbGFzcyBQYXJzZXIge1xuICBwcml2YXRlIHN0cnVjdHMgPSBuZXcgQXJyYXk8U3RydWN0PigpO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgY2xhc3NOYW1lczogc3RyaW5nW10pIHt9XG5cbiAgcHJpdmF0ZSB1bmlxdWVDbGFzc05hbWUoY2xhc3NOYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGlmICh0aGlzLmNsYXNzTmFtZXMuaW5jbHVkZXMoY2xhc3NOYW1lKSkge1xuICAgICAgY2xhc3NOYW1lID0gYCR7Y2xhc3NOYW1lfUFgO1xuICAgIH1cbiAgICB0aGlzLmNsYXNzTmFtZXMucHVzaChjbGFzc05hbWUpO1xuICAgIHJldHVybiBjbGFzc05hbWU7XG4gIH1cblxuICBwdWJsaWMgcmVzb3VyY2VGcm9tKFxuICAgIGZxcG46IEZRUE4sXG4gICAgdHlwZTogc3RyaW5nLFxuICAgIHNjaGVtYTogU2NoZW1hLFxuICAgIHRlcnJhZm9ybVNjaGVtYVR5cGU6IHN0cmluZyxcbiAgICBjb25zdHJhaW50PzogQ29uc3RydWN0c01ha2VyVGFyZ2V0XG4gICk6IFJlc291cmNlTW9kZWwge1xuICAgIGxldCBiYXNlTmFtZSA9IHR5cGU7XG5cbiAgICBjb25zdCBwcm92aWRlck5hbWVGcm9tQ29uc3RyYWludCA9IGNvbnN0cmFpbnRcbiAgICAgID8gKGNvbnN0cmFpbnQubmFtZSBhcyBQcm92aWRlck5hbWUpXG4gICAgICA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBwcm92aWRlck5hbWVGcm9tRlFQTiA9IHBhcnNlRlFQTihmcXBuKS5uYW1lO1xuXG4gICAgaWYgKGJhc2VOYW1lLnN0YXJ0c1dpdGgoYCR7cHJvdmlkZXJOYW1lRnJvbUZRUE59X2ApKSB7XG4gICAgICBiYXNlTmFtZSA9IGJhc2VOYW1lLnN1YnN0cihwcm92aWRlck5hbWVGcm9tRlFQTi5sZW5ndGggKyAxKTtcbiAgICB9XG5cbiAgICBjb25zdCBwcm92aWRlck5hbWUgPSBwcm92aWRlck5hbWVGcm9tQ29uc3RyYWludFxuICAgICAgPyBwcm92aWRlck5hbWVGcm9tQ29uc3RyYWludFxuICAgICAgOiBwcm92aWRlck5hbWVGcm9tRlFQTjtcblxuICAgIGNvbnN0IGlzUHJvdmlkZXIgPSB0ZXJyYWZvcm1TY2hlbWFUeXBlID09PSBcInByb3ZpZGVyXCI7XG4gICAgaWYgKGlzUHJvdmlkZXIpIHtcbiAgICAgIGJhc2VOYW1lID0gYCR7cHJvdmlkZXJOYW1lfV8ke2Jhc2VOYW1lfWA7XG4gICAgICBpZiAoIShcImF0dHJpYnV0ZXNcIiBpbiBzY2hlbWEuYmxvY2spKSB7XG4gICAgICAgIHNjaGVtYS5ibG9jayA9IHtcbiAgICAgICAgICBhdHRyaWJ1dGVzOiB7fSxcbiAgICAgICAgICBibG9ja190eXBlczogKHNjaGVtYS5ibG9jayBhcyBCbG9jaykuYmxvY2tfdHlwZXMgfHwge30sXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICAvLyBzb21laG93IG1pc3NpbmcgZnJvbSBwcm92aWRlciBzY2hlbWFcbiAgICAgIHNjaGVtYS5ibG9jay5hdHRyaWJ1dGVzW1wiYWxpYXNcIl0gPSB7XG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIkFsaWFzIG5hbWVcIixcbiAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgIGNvbXB1dGVkOiBmYWxzZSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgYmFzZU5hbWUgPSBzYW5pdGl6ZUNsYXNzT3JOYW1lc3BhY2VOYW1lKGJhc2VOYW1lLCBpc1Byb3ZpZGVyKTtcblxuICAgIGNvbnN0IGNsYXNzTmFtZSA9IHRoaXMudW5pcXVlQ2xhc3NOYW1lKHRvUGFzY2FsQ2FzZShiYXNlTmFtZSkpO1xuICAgIC8vIGF2b2lkIG5hbWluZyBjb2xsaXNpb24gLSBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2hhc2hpY29ycC90ZXJyYWZvcm0tY2RrL2lzc3Vlcy8yOTlcbiAgICBjb25zdCBjb25maWdTdHJ1Y3ROYW1lID0gdGhpcy51bmlxdWVDbGFzc05hbWUoYCR7Y2xhc3NOYW1lfUNvbmZpZ2ApO1xuICAgIGNvbnN0IGZpbGVOYW1lID0gZ2V0RmlsZU5hbWUocHJvdmlkZXJOYW1lLCBiYXNlTmFtZSk7XG5cbiAgICBjb25zdCBmaWxlUGF0aCA9IGBwcm92aWRlcnMvJHt0b1NuYWtlQ2FzZShwcm92aWRlck5hbWUpfS8ke2ZpbGVOYW1lfWA7XG4gICAgbGV0IGF0dHJpYnV0ZXMgPSB0aGlzLnJlbmRlckF0dHJpYnV0ZXNGb3JCbG9jayhcbiAgICAgIG5ldyBTY29wZSh7XG4gICAgICAgIG5hbWU6IGJhc2VOYW1lLFxuICAgICAgICBpc1Byb3ZpZGVyLFxuICAgICAgICBwYXJlbnQ6IGlzUHJvdmlkZXJcbiAgICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICAgIDogbmV3IFNjb3BlKHsgbmFtZTogcHJvdmlkZXJOYW1lLCBpc1Byb3ZpZGVyOiB0cnVlIH0pLFxuICAgICAgfSksXG4gICAgICBzY2hlbWEuYmxvY2tcbiAgICApO1xuXG4gICAgZnVuY3Rpb24gZ2V0U3RydWN0QXR0cmlidXRlKFxuICAgICAgYXR0cmlidXRlczogQXR0cmlidXRlTW9kZWxbXSxcbiAgICAgIHBhdGg6IHN0cmluZ1xuICAgICk6IEF0dHJpYnV0ZU1vZGVsIHtcbiAgICAgIGNvbnN0IFtmaXJzdCwgLi4ucmVzdF0gPSBwYXRoLnNwbGl0KFwiLlwiKTtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXMuZmluZCgoYXR0KSA9PiB7XG4gICAgICAgIHJldHVybiBhdHQudGVycmFmb3JtTmFtZSA9PT0gZmlyc3Q7XG4gICAgICB9KTtcbiAgICAgIGlmICghYXR0cmlidXRlKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYEV4cGVjdGVkIHRvIGZpbmQgcmVjdXJzaXZlIGF0dHJpYnV0ZSBhdCBwYXRoOiAke3BhdGh9YFxuICAgICAgICApO1xuICAgICAgaWYgKCFhdHRyaWJ1dGUudHlwZS5zdHJ1Y3QpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgRXhwZWN0ZWQgdG8gZmluZCBzdHJ1Y3QgdHlwZSBhdHRyaWJ1dGUgYXQgcGF0aDogJHtwYXRofSBidXQgZ290ICR7YXR0cmlidXRlLnR5cGUuc3RvcmVkQ2xhc3NUeXBlfWBcbiAgICAgICAgKTtcbiAgICAgIGlmIChyZXN0Lmxlbmd0aCA9PT0gMCkgcmV0dXJuIGF0dHJpYnV0ZTtcbiAgICAgIHJldHVybiBnZXRTdHJ1Y3RBdHRyaWJ1dGUoXG4gICAgICAgIGF0dHJpYnV0ZS50eXBlLnN0cnVjdC5hdHRyaWJ1dGVzLFxuICAgICAgICByZXN0LmpvaW4oXCIuXCIpXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIEludHJvZHVjZSByZWN1cnNpb24gZm9yIHNvbWUgYXR0cmlidXRlc1xuICAgIGNvbnN0IHJlY3Vyc2l2ZUF0dHJpYnV0ZVBhdGhzID0gZGV0ZWN0QXR0cmlidXRlTG9vcHMoYXR0cmlidXRlcyk7XG5cbiAgICBPYmplY3QuZW50cmllcyhyZWN1cnNpdmVBdHRyaWJ1dGVQYXRocykuZm9yRWFjaChcbiAgICAgIChbYXR0cmlidXRlUGF0aCwgc3RydWN0UGF0aF0pID0+IHtcbiAgICAgICAgLy8gVE9ETzogYnVpbGQgdGhpcyB0byBiZSBhIGJpdCBtb3JlIGRlZmVuc2l2ZSAoZS5nLiByZW1vdmUgISBvcGVyYXRvcilcbiAgICAgICAgY29uc3QgcmVjdXJzaW9uVGFyZ2V0U3RydWN0QXR0cmlidXRlID0gZ2V0U3RydWN0QXR0cmlidXRlKFxuICAgICAgICAgIGF0dHJpYnV0ZXMsXG4gICAgICAgICAgc3RydWN0UGF0aFxuICAgICAgICApO1xuICAgICAgICBjb25zdCBwYXJ0cyA9IGF0dHJpYnV0ZVBhdGguc3BsaXQoXCIuXCIpO1xuICAgICAgICBjb25zdCBhdHRyaWJ1dGVOYW1lID0gcGFydHMucG9wKCk7XG4gICAgICAgIGNvbnN0IHBhcmVudEF0dHJpYnV0ZSA9IGdldFN0cnVjdEF0dHJpYnV0ZShhdHRyaWJ1dGVzLCBwYXJ0cy5qb2luKFwiLlwiKSk7XG4gICAgICAgIGNvbnN0IGluZGV4VG9SZXBsYWNlID1cbiAgICAgICAgICBwYXJlbnRBdHRyaWJ1dGUudHlwZS5zdHJ1Y3QhLmF0dHJpYnV0ZXMuZmluZEluZGV4KFxuICAgICAgICAgICAgKGF0dCkgPT4gYXR0LnRlcnJhZm9ybU5hbWUgPT09IGF0dHJpYnV0ZU5hbWVcbiAgICAgICAgICApO1xuICAgICAgICBpZiAoaW5kZXhUb1JlcGxhY2UgPT09IC0xKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IGZpbmQgYXR0cmlidXRlIGF0IHBhdGggXCIgKyBhdHRyaWJ1dGVQYXRoKTtcbiAgICAgICAgY29uc3QgcHJldmlvdXNBdHRyaWJ1dGUgPVxuICAgICAgICAgIHBhcmVudEF0dHJpYnV0ZS50eXBlLnN0cnVjdCEuYXR0cmlidXRlc1tpbmRleFRvUmVwbGFjZV07XG5cbiAgICAgICAgcGFyZW50QXR0cmlidXRlLnR5cGUuc3RydWN0IS5hdHRyaWJ1dGVzW2luZGV4VG9SZXBsYWNlXSA9XG4gICAgICAgICAgcmVjdXJzaW9uVGFyZ2V0U3RydWN0QXR0cmlidXRlOyAvLyBpbnRyb2R1Y2UgcmVjdXJzaW9uXG5cbiAgICAgICAgLy8gdWdseSwgcGxzIGPMtmHMtmzMtmzMtiByZWZhY3RvciBtZSBtYXliZVxuICAgICAgICAvLyB3ZSBzdG9yZSBhbGwgc3RydWN0cyBpbiB0aGlzLnN0cnVjdHMg4oCTIG5vdyB3ZSBuZWVkIHRvIGRpc3Bvc2UgYWxsIHN0cnVjdHMgdGhhdCBhcmUgcGFydCBvZiBwcmV2aW91c0F0dHJpYnV0ZVxuICAgICAgICBjb25zdCBkaXNwb3NlU3RydWN0cyA9IChhdHRyOiBBdHRyaWJ1dGVNb2RlbCkgPT4ge1xuICAgICAgICAgIGlmIChhdHRyLnR5cGUuc3RydWN0KSB7XG4gICAgICAgICAgICBhdHRyLnR5cGUuc3RydWN0LmF0dHJpYnV0ZXMuZm9yRWFjaChkaXNwb3NlU3RydWN0cyk7XG4gICAgICAgICAgICB0aGlzLnN0cnVjdHMgPSB0aGlzLnN0cnVjdHMuZmlsdGVyKChzKSA9PiBzICE9PSBhdHRyLnR5cGUuc3RydWN0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgZGlzcG9zZVN0cnVjdHMocHJldmlvdXNBdHRyaWJ1dGUpO1xuICAgICAgfVxuICAgICk7XG5cbiAgICBhdHRyaWJ1dGVzID0gZGVkdXBsaWNhdGVBdHRyaWJ1dGVzV2l0aFNhbWVOYW1lKGF0dHJpYnV0ZXMpO1xuXG4gICAgY29uc3QgcmVzb3VyY2VNb2RlbCA9IG5ldyBSZXNvdXJjZU1vZGVsKHtcbiAgICAgIHRlcnJhZm9ybVR5cGU6IHR5cGUsXG4gICAgICBiYXNlTmFtZSxcbiAgICAgIGZpbGVOYW1lLFxuICAgICAgZmlsZVBhdGgsXG4gICAgICBjbGFzc05hbWUsXG4gICAgICBzY2hlbWEsXG4gICAgICBmcXBuLFxuICAgICAgYXR0cmlidXRlcyxcbiAgICAgIHRlcnJhZm9ybVNjaGVtYVR5cGUsXG4gICAgICBzdHJ1Y3RzOiB0aGlzLnN0cnVjdHMsXG4gICAgICBjb25maWdTdHJ1Y3ROYW1lLFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlc291cmNlTW9kZWw7XG4gIH1cblxuICBwcml2YXRlIHJlbmRlckF0dHJpYnV0ZVR5cGUoXG4gICAgc2NvcGU6IFNjb3BlW10sXG4gICAgYXR0cmlidXRlVHlwZTogQXR0cmlidXRlVHlwZSB8IEF0dHJpYnV0ZU5lc3RlZFR5cGUsXG4gICAgcGFyZW50S2luZD86IHN0cmluZ1xuICApOiBBdHRyaWJ1dGVUeXBlTW9kZWwge1xuICAgIGNvbnN0IHBhcmVudCA9IHNjb3BlW3Njb3BlLmxlbmd0aCAtIDFdO1xuICAgIGlmIChzaG91bGRTa2lwQXR0cmlidXRlKHBhcmVudC5iYXNlTmFtZSkpIHtcbiAgICAgIHJldHVybiBuZXcgTWFwQXR0cmlidXRlVHlwZU1vZGVsKG5ldyBTaW1wbGVBdHRyaWJ1dGVUeXBlTW9kZWwoXCJhbnlcIikpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgYXR0cmlidXRlVHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgc3dpdGNoIChhdHRyaWJ1dGVUeXBlKSB7XG4gICAgICAgIGNhc2UgXCJib29sXCI6XG4gICAgICAgICAgcmV0dXJuIG5ldyBTaW1wbGVBdHRyaWJ1dGVUeXBlTW9kZWwoXCJib29sZWFuXCIpO1xuICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgcmV0dXJuIG5ldyBTaW1wbGVBdHRyaWJ1dGVUeXBlTW9kZWwoXCJzdHJpbmdcIik7XG4gICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICByZXR1cm4gbmV3IFNpbXBsZUF0dHJpYnV0ZVR5cGVNb2RlbChcIm51bWJlclwiKTtcbiAgICAgICAgY2FzZSBcImR5bmFtaWNcIjpcbiAgICAgICAgICByZXR1cm4gbmV3IE1hcEF0dHJpYnV0ZVR5cGVNb2RlbChuZXcgU2ltcGxlQXR0cmlidXRlVHlwZU1vZGVsKFwiYW55XCIpKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgcHJpbWl0aXZlIHR5cGUgJHthdHRyaWJ1dGVUeXBlfWApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KGF0dHJpYnV0ZVR5cGUpKSB7XG4gICAgICBpZiAoYXR0cmlidXRlVHlwZS5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmV4cGVjdGVkIGFycmF5YCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IFtraW5kLCB0eXBlXSA9IGF0dHJpYnV0ZVR5cGU7XG5cbiAgICAgIGlmIChraW5kID09PSBcInNldFwiIHx8IGtpbmQgPT09IFwibGlzdFwiKSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRUeXBlID0gdGhpcy5yZW5kZXJBdHRyaWJ1dGVUeXBlKFxuICAgICAgICAgIHNjb3BlLFxuICAgICAgICAgIHR5cGUgYXMgQXR0cmlidXRlVHlwZSxcbiAgICAgICAgICBba2luZCwgcGFyZW50S2luZF0uam9pbihcIlwiKVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4ga2luZCA9PT0gXCJsaXN0XCJcbiAgICAgICAgICA/IG5ldyBMaXN0QXR0cmlidXRlVHlwZU1vZGVsKGVsZW1lbnRUeXBlLCBmYWxzZSwgZmFsc2UpXG4gICAgICAgICAgOiBuZXcgU2V0QXR0cmlidXRlVHlwZU1vZGVsKGVsZW1lbnRUeXBlLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgfVxuXG4gICAgICBpZiAoa2luZCA9PT0gXCJtYXBcIikge1xuICAgICAgICBjb25zdCB2YWx1ZVR5cGUgPSB0aGlzLnJlbmRlckF0dHJpYnV0ZVR5cGUoXG4gICAgICAgICAgc2NvcGUsXG4gICAgICAgICAgdHlwZSBhcyBBdHRyaWJ1dGVUeXBlLFxuICAgICAgICAgIFtraW5kLCBwYXJlbnRLaW5kXS5qb2luKFwiXCIpXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBuZXcgTWFwQXR0cmlidXRlVHlwZU1vZGVsKHZhbHVlVHlwZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChraW5kID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGNvbnN0IG9iakF0dHJpYnV0ZXMgPSB0eXBlIGFzIHsgW25hbWU6IHN0cmluZ106IEF0dHJpYnV0ZVR5cGUgfTtcbiAgICAgICAgY29uc3QgYXR0cmlidXRlczogeyBbbmFtZTogc3RyaW5nXTogQXR0cmlidXRlIH0gPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBbbmFtZSwgdHlwZV0gb2YgT2JqZWN0LmVudHJpZXMob2JqQXR0cmlidXRlcykpIHtcbiAgICAgICAgICBhdHRyaWJ1dGVzW25hbWVdID0geyB0eXBlIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RydWN0ID0gdGhpcy5hZGRBbm9ueW1vdXNTdHJ1Y3QoXG4gICAgICAgICAgc2NvcGUsXG4gICAgICAgICAgYXR0cmlidXRlcyxcbiAgICAgICAgICBwYXJlbnRLaW5kID8/IGtpbmRcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJ1Y3RBdHRyaWJ1dGVUeXBlTW9kZWwoc3RydWN0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaXNBdHRyaWJ1dGVOZXN0ZWRUeXBlKGF0dHJpYnV0ZVR5cGUpKSB7XG4gICAgICBsZXQgc3RydWN0ID0gdW5kZWZpbmVkO1xuICAgICAgbGV0IHR5cGVNb2RlbCA9IHVuZGVmaW5lZDtcbiAgICAgIHN3aXRjaCAoYXR0cmlidXRlVHlwZS5uZXN0aW5nX21vZGUpIHtcbiAgICAgICAgY2FzZSBcImxpc3RcIjpcbiAgICAgICAgICBzdHJ1Y3QgPSB0aGlzLmFkZEFub255bW91c1N0cnVjdChcbiAgICAgICAgICAgIHNjb3BlLFxuICAgICAgICAgICAgYXR0cmlidXRlVHlwZS5hdHRyaWJ1dGVzLFxuICAgICAgICAgICAgYXR0cmlidXRlVHlwZS5uZXN0aW5nX21vZGVcbiAgICAgICAgICApO1xuICAgICAgICAgIHR5cGVNb2RlbCA9IG5ldyBMaXN0QXR0cmlidXRlVHlwZU1vZGVsKFxuICAgICAgICAgICAgbmV3IFN0cnVjdEF0dHJpYnV0ZVR5cGVNb2RlbChzdHJ1Y3QpLFxuICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICBmYWxzZVxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJzZXRcIjpcbiAgICAgICAgICBzdHJ1Y3QgPSB0aGlzLmFkZEFub255bW91c1N0cnVjdChcbiAgICAgICAgICAgIHNjb3BlLFxuICAgICAgICAgICAgYXR0cmlidXRlVHlwZS5hdHRyaWJ1dGVzLFxuICAgICAgICAgICAgYXR0cmlidXRlVHlwZS5uZXN0aW5nX21vZGVcbiAgICAgICAgICApO1xuICAgICAgICAgIHR5cGVNb2RlbCA9IG5ldyBTZXRBdHRyaWJ1dGVUeXBlTW9kZWwoXG4gICAgICAgICAgICBuZXcgU3RydWN0QXR0cmlidXRlVHlwZU1vZGVsKHN0cnVjdCksXG4gICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm1hcFwiOlxuICAgICAgICAgIHN0cnVjdCA9IHRoaXMuYWRkQW5vbnltb3VzU3RydWN0KFxuICAgICAgICAgICAgc2NvcGUsXG4gICAgICAgICAgICBhdHRyaWJ1dGVUeXBlLmF0dHJpYnV0ZXMsXG4gICAgICAgICAgICBhdHRyaWJ1dGVUeXBlLm5lc3RpbmdfbW9kZVxuICAgICAgICAgICk7XG4gICAgICAgICAgdHlwZU1vZGVsID0gbmV3IE1hcEF0dHJpYnV0ZVR5cGVNb2RlbChcbiAgICAgICAgICAgIG5ldyBTdHJ1Y3RBdHRyaWJ1dGVUeXBlTW9kZWwoc3RydWN0KVxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJzaW5nbGVcIjpcbiAgICAgICAgICBzdHJ1Y3QgPSB0aGlzLmFkZEFub255bW91c1N0cnVjdChcbiAgICAgICAgICAgIHNjb3BlLFxuICAgICAgICAgICAgYXR0cmlidXRlVHlwZS5hdHRyaWJ1dGVzLFxuICAgICAgICAgICAgYXR0cmlidXRlVHlwZS5uZXN0aW5nX21vZGVcbiAgICAgICAgICApO1xuICAgICAgICAgIHR5cGVNb2RlbCA9IG5ldyBTdHJ1Y3RBdHRyaWJ1dGVUeXBlTW9kZWwoc3RydWN0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBuZXN0ZWRfdHlwZSB3aXRoIG5lc3RpbmdfbW9kZSBcIiR7XG4gICAgICAgICAgICAgIGF0dHJpYnV0ZVR5cGUubmVzdGluZ19tb2RlXG4gICAgICAgICAgICB9XCIgbm90IHN1cHBvcnRlZCAoYXR0cmlidXRlIHNjb3BlOiAke3Njb3BlXG4gICAgICAgICAgICAgIC5tYXAoKHMpID0+IHMuZnVsbE5hbWUpXG4gICAgICAgICAgICAgIC5qb2luKFwiLFwiKX1gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHR5cGVNb2RlbDtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoYHVua25vd24gdHlwZSAke0pTT04uc3RyaW5naWZ5KGF0dHJpYnV0ZVR5cGUpfWApO1xuICB9XG5cbiAgcHVibGljIHJlbmRlckF0dHJpYnV0ZXNGb3JCbG9jayhwYXJlbnRUeXBlOiBTY29wZSwgYmxvY2s6IEJsb2NrKSB7XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IG5ldyBBcnJheTxBdHRyaWJ1dGVNb2RlbD4oKTtcblxuICAgIGZvciAoY29uc3QgW3RlcnJhZm9ybUF0dHJpYnV0ZU5hbWUsIGF0dF0gb2YgT2JqZWN0LmVudHJpZXMoXG4gICAgICBibG9jay5hdHRyaWJ1dGVzIHx8IHt9XG4gICAgKSkge1xuICAgICAgaWYgKHNob3VsZFNraXBBdHRyaWJ1dGUocGFyZW50VHlwZS5mdWxsTmFtZSh0ZXJyYWZvcm1BdHRyaWJ1dGVOYW1lKSkpIHtcbiAgICAgICAgdGhyb3cgRXJyb3JzLkludGVybmFsKFxuICAgICAgICAgIGBTa2lwcGluZyBhdHRyaWJ1dGUgJHtwYXJlbnRUeXBlLmZ1bGxOYW1lKFxuICAgICAgICAgICAgdGVycmFmb3JtQXR0cmlidXRlTmFtZVxuICAgICAgICAgICl9IGlzIG5vdCBpbXBsZW1lbnRlZCBzaW5jZSBpdCdzIGFuIGF0dHJpYnV0ZSBhbmQgbm90IGEgYmxvY2sgdHlwZWBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHR5cGUgPSB0aGlzLnJlbmRlckF0dHJpYnV0ZVR5cGUoXG4gICAgICAgIFtcbiAgICAgICAgICBwYXJlbnRUeXBlLFxuICAgICAgICAgIG5ldyBTY29wZSh7XG4gICAgICAgICAgICBuYW1lOiB0ZXJyYWZvcm1BdHRyaWJ1dGVOYW1lLFxuICAgICAgICAgICAgcGFyZW50OiBwYXJlbnRUeXBlLFxuICAgICAgICAgICAgaXNQcm92aWRlcjogcGFyZW50VHlwZS5pc1Byb3ZpZGVyLFxuICAgICAgICAgICAgaXNDb21wdXRlZDogISFhdHQuY29tcHV0ZWQsXG4gICAgICAgICAgICBpc09wdGlvbmFsOiAhIWF0dC5vcHRpb25hbCxcbiAgICAgICAgICAgIGlzUmVxdWlyZWQ6ICEhYXR0LnJlcXVpcmVkLFxuICAgICAgICAgICAgaXNOZXN0ZWRUeXBlOiBpc05lc3RlZFR5cGVBdHRyaWJ1dGUoYXR0KSxcbiAgICAgICAgICB9KSxcbiAgICAgICAgXSxcbiAgICAgICAgYXR0LnR5cGUgfHwgYXR0Lm5lc3RlZF90eXBlXG4gICAgICApO1xuICAgICAgY29uc3QgbmFtZSA9IHRvQ2FtZWxDYXNlKHRlcnJhZm9ybUF0dHJpYnV0ZU5hbWUpO1xuXG4gICAgICBhdHRyaWJ1dGVzLnB1c2goXG4gICAgICAgIG5ldyBBdHRyaWJ1dGVNb2RlbCh7XG4gICAgICAgICAgdGVycmFmb3JtRnVsbE5hbWU6IHBhcmVudFR5cGUuZnVsbE5hbWUodGVycmFmb3JtQXR0cmlidXRlTmFtZSksXG4gICAgICAgICAgZGVzY3JpcHRpb246IGF0dC5kZXNjcmlwdGlvbixcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIHN0b3JhZ2VOYW1lOiBgXyR7bmFtZX1gLFxuICAgICAgICAgIGNvbXB1dGVkOiAhIWF0dC5jb21wdXRlZCxcbiAgICAgICAgICBvcHRpb25hbDogISFhdHQub3B0aW9uYWwsXG4gICAgICAgICAgdGVycmFmb3JtTmFtZTogdGVycmFmb3JtQXR0cmlidXRlTmFtZSxcbiAgICAgICAgICB0eXBlLFxuICAgICAgICAgIHByb3ZpZGVyOiBwYXJlbnRUeXBlLmlzUHJvdmlkZXIsXG4gICAgICAgICAgcmVxdWlyZWQ6ICEhYXR0LnJlcXVpcmVkLFxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IFtibG9ja1R5cGVOYW1lLCBibG9ja1R5cGVdIG9mIE9iamVjdC5lbnRyaWVzKFxuICAgICAgYmxvY2suYmxvY2tfdHlwZXMgfHwge31cbiAgICApKSB7XG4gICAgICBpZiAoc2hvdWxkU2tpcEF0dHJpYnV0ZShwYXJlbnRUeXBlLmZ1bGxOYW1lKGJsb2NrVHlwZU5hbWUpKSkge1xuICAgICAgICBjb25zdCBuYW1lID0gdG9DYW1lbENhc2UoYmxvY2tUeXBlTmFtZSk7XG4gICAgICAgIGNvbnN0IHBhcmVudCA9IG5ldyBTY29wZSh7XG4gICAgICAgICAgbmFtZTogYmxvY2tUeXBlTmFtZSxcbiAgICAgICAgICBwYXJlbnQ6IHBhcmVudFR5cGUsXG4gICAgICAgICAgaXNQcm92aWRlcjogcGFyZW50VHlwZS5pc1Byb3ZpZGVyLFxuICAgICAgICB9KTtcbiAgICAgICAgYXR0cmlidXRlcy5wdXNoKFxuICAgICAgICAgIG5ldyBBdHRyaWJ1dGVNb2RlbCh7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgdGVycmFmb3JtTmFtZTogYmxvY2tUeXBlTmFtZSxcbiAgICAgICAgICAgIHRlcnJhZm9ybUZ1bGxOYW1lOiBwYXJlbnQuZnVsbE5hbWUoYmxvY2tUeXBlTmFtZSksXG4gICAgICAgICAgICB0eXBlOiBuZXcgU2tpcHBlZEF0dHJpYnV0ZVR5cGVNb2RlbCgpLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IGAke2Jsb2NrVHlwZU5hbWV9IGJsb2NrYCxcbiAgICAgICAgICAgIHN0b3JhZ2VOYW1lOiBgXyR7bmFtZX1gLFxuICAgICAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgICAgICBjb21wdXRlZDogZmFsc2UsXG4gICAgICAgICAgICBwcm92aWRlcjogcGFyZW50VHlwZS5pc1Byb3ZpZGVyLFxuICAgICAgICAgICAgcmVxdWlyZWQ6IGZhbHNlLFxuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgLy8gY3JlYXRlIGEgc3RydWN0IGZvciB0aGlzIGJsb2NrXG4gICAgICBsZXQgYmxvY2tBdHRyaWJ1dGVzID0gdGhpcy5yZW5kZXJBdHRyaWJ1dGVzRm9yQmxvY2soXG4gICAgICAgIG5ldyBTY29wZSh7XG4gICAgICAgICAgbmFtZTogYCR7cGFyZW50VHlwZS5uYW1lfV8ke2Jsb2NrVHlwZU5hbWV9YCxcbiAgICAgICAgICBwYXJlbnQ6IHBhcmVudFR5cGUsXG4gICAgICAgICAgaXNQcm92aWRlcjogcGFyZW50VHlwZS5pc1Byb3ZpZGVyLFxuICAgICAgICAgIGluQmxvY2tUeXBlOiB0cnVlLFxuICAgICAgICB9KSxcbiAgICAgICAgYmxvY2tUeXBlLmJsb2NrXG4gICAgICApO1xuXG4gICAgICBibG9ja0F0dHJpYnV0ZXMgPSBkZWR1cGxpY2F0ZUF0dHJpYnV0ZXNXaXRoU2FtZU5hbWUoYmxvY2tBdHRyaWJ1dGVzKTtcblxuICAgICAgY29uc3QgYmxvY2tTdHJ1Y3QgPSB0aGlzLmFkZFN0cnVjdChcbiAgICAgICAgW1xuICAgICAgICAgIHBhcmVudFR5cGUsXG4gICAgICAgICAgbmV3IFNjb3BlKHtcbiAgICAgICAgICAgIG5hbWU6IGJsb2NrVHlwZU5hbWUsXG4gICAgICAgICAgICBwYXJlbnQ6IHBhcmVudFR5cGUsXG4gICAgICAgICAgICBpc1Byb3ZpZGVyOiBwYXJlbnRUeXBlLmlzUHJvdmlkZXIsXG4gICAgICAgICAgfSksXG4gICAgICAgIF0sXG4gICAgICAgIGJsb2NrQXR0cmlidXRlcyxcbiAgICAgICAgYmxvY2tUeXBlLm5lc3RpbmdfbW9kZSxcbiAgICAgICAgKGJsb2NrVHlwZS5uZXN0aW5nX21vZGUgPT09IFwibGlzdFwiIHx8XG4gICAgICAgICAgYmxvY2tUeXBlLm5lc3RpbmdfbW9kZSA9PT0gXCJzZXRcIikgJiZcbiAgICAgICAgICBibG9ja1R5cGUubWF4X2l0ZW1zID09PSAxXG4gICAgICApO1xuXG4gICAgICAvLyBkZWZpbmUgdGhlIGF0dHJpYnV0ZVxuICAgICAgYXR0cmlidXRlcy5wdXNoKFxuICAgICAgICBhdHRyaWJ1dGVGb3JCbG9ja1R5cGUoXG4gICAgICAgICAgYmxvY2tUeXBlTmFtZSxcbiAgICAgICAgICBibG9ja1R5cGUsXG4gICAgICAgICAgYmxvY2tTdHJ1Y3QsXG4gICAgICAgICAgcGFyZW50VHlwZS5pc1Byb3ZpZGVyLFxuICAgICAgICAgIHBhcmVudFR5cGVcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXR0cmlidXRlcztcblxuICAgIGZ1bmN0aW9uIGF0dHJpYnV0ZUZvckJsb2NrVHlwZShcbiAgICAgIHRlcnJhZm9ybU5hbWU6IHN0cmluZyxcbiAgICAgIGJsb2NrVHlwZTogQmxvY2tUeXBlLFxuICAgICAgc3RydWN0OiBTdHJ1Y3QsXG4gICAgICBpc1Byb3ZpZGVyOiBib29sZWFuLFxuICAgICAgcGFyZW50OiBTY29wZVxuICAgICk6IEF0dHJpYnV0ZU1vZGVsIHtcbiAgICAgIGNvbnN0IG5hbWUgPSB0b0NhbWVsQ2FzZSh0ZXJyYWZvcm1OYW1lKTtcbiAgICAgIGxldCBvcHRpb25hbDogYm9vbGVhbjtcbiAgICAgIGxldCByZXF1aXJlZDogYm9vbGVhbjtcbiAgICAgIHN3aXRjaCAoYmxvY2tUeXBlLm5lc3RpbmdfbW9kZSkge1xuICAgICAgICBjYXNlIFwic2luZ2xlXCI6XG4gICAgICAgICAgb3B0aW9uYWwgPSAhc3RydWN0LmF0dHJpYnV0ZXMuc29tZSgoeCkgPT4gIXgub3B0aW9uYWwpO1xuICAgICAgICAgIHJlcXVpcmVkID0gIXN0cnVjdC5hdHRyaWJ1dGVzLnNvbWUoKHgpID0+ICF4LnJlcXVpcmVkKTtcbiAgICAgICAgICByZXR1cm4gbmV3IEF0dHJpYnV0ZU1vZGVsKHtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICB0ZXJyYWZvcm1OYW1lLFxuICAgICAgICAgICAgdGVycmFmb3JtRnVsbE5hbWU6IHBhcmVudC5mdWxsTmFtZSh0ZXJyYWZvcm1OYW1lKSxcbiAgICAgICAgICAgIHR5cGU6IG5ldyBTdHJ1Y3RBdHRyaWJ1dGVUeXBlTW9kZWwoc3RydWN0KSxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBgJHt0ZXJyYWZvcm1OYW1lfSBibG9ja2AsXG4gICAgICAgICAgICBzdG9yYWdlTmFtZTogYF8ke25hbWV9YCxcbiAgICAgICAgICAgIG9wdGlvbmFsLFxuICAgICAgICAgICAgY29tcHV0ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgcHJvdmlkZXI6IGlzUHJvdmlkZXIsXG4gICAgICAgICAgICByZXF1aXJlZCxcbiAgICAgICAgICB9KTtcblxuICAgICAgICBjYXNlIFwibWFwXCI6XG4gICAgICAgICAgcmV0dXJuIG5ldyBBdHRyaWJ1dGVNb2RlbCh7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgdGVycmFmb3JtTmFtZSxcbiAgICAgICAgICAgIHRlcnJhZm9ybUZ1bGxOYW1lOiBwYXJlbnQuZnVsbE5hbWUodGVycmFmb3JtTmFtZSksXG4gICAgICAgICAgICB0eXBlOiBuZXcgTWFwQXR0cmlidXRlVHlwZU1vZGVsKFxuICAgICAgICAgICAgICBuZXcgU3RydWN0QXR0cmlidXRlVHlwZU1vZGVsKHN0cnVjdClcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogYCR7dGVycmFmb3JtTmFtZX0gYmxvY2tgLFxuICAgICAgICAgICAgc3RvcmFnZU5hbWU6IGBfJHtuYW1lfWAsXG4gICAgICAgICAgICBvcHRpb25hbDogZmFsc2UsXG4gICAgICAgICAgICBjb21wdXRlZDogZmFsc2UsXG4gICAgICAgICAgICBwcm92aWRlcjogaXNQcm92aWRlcixcbiAgICAgICAgICAgIHJlcXVpcmVkOiBmYWxzZSxcbiAgICAgICAgICB9KTtcblxuICAgICAgICBjYXNlIFwibGlzdFwiOlxuICAgICAgICBjYXNlIFwic2V0XCI6XG4gICAgICAgICAgb3B0aW9uYWwgPVxuICAgICAgICAgICAgYmxvY2tUeXBlLm1pbl9pdGVtcyA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGJsb2NrVHlwZS5taW5faXRlbXMgPCAxO1xuICAgICAgICAgIHJlcXVpcmVkID1cbiAgICAgICAgICAgIGJsb2NrVHlwZS5taW5faXRlbXMgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogYmxvY2tUeXBlLm1pbl9pdGVtcyA+IDA7XG4gICAgICAgICAgcmV0dXJuIG5ldyBBdHRyaWJ1dGVNb2RlbCh7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgdGVycmFmb3JtTmFtZTogdGVycmFmb3JtTmFtZSxcbiAgICAgICAgICAgIHRlcnJhZm9ybUZ1bGxOYW1lOiBwYXJlbnQuZnVsbE5hbWUodGVycmFmb3JtTmFtZSksXG4gICAgICAgICAgICB0eXBlOlxuICAgICAgICAgICAgICBibG9ja1R5cGUubmVzdGluZ19tb2RlID09PSBcImxpc3RcIlxuICAgICAgICAgICAgICAgID8gbmV3IExpc3RBdHRyaWJ1dGVUeXBlTW9kZWwoXG4gICAgICAgICAgICAgICAgICAgIG5ldyBTdHJ1Y3RBdHRyaWJ1dGVUeXBlTW9kZWwoc3RydWN0KSxcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tUeXBlLm1heF9pdGVtcyA9PT0gMSxcbiAgICAgICAgICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIDogbmV3IFNldEF0dHJpYnV0ZVR5cGVNb2RlbChcbiAgICAgICAgICAgICAgICAgICAgbmV3IFN0cnVjdEF0dHJpYnV0ZVR5cGVNb2RlbChzdHJ1Y3QpLFxuICAgICAgICAgICAgICAgICAgICBibG9ja1R5cGUubWF4X2l0ZW1zID09PSAxLFxuICAgICAgICAgICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IGAke3RlcnJhZm9ybU5hbWV9IGJsb2NrYCxcbiAgICAgICAgICAgIHN0b3JhZ2VOYW1lOiBgXyR7bmFtZX1gLFxuICAgICAgICAgICAgb3B0aW9uYWwsXG4gICAgICAgICAgICBjb21wdXRlZDogZmFsc2UsXG4gICAgICAgICAgICBwcm92aWRlcjogaXNQcm92aWRlcixcbiAgICAgICAgICAgIHJlcXVpcmVkLFxuICAgICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBwcml2YXRlIGFkZEFub255bW91c1N0cnVjdChcbiAgICBzY29wZTogU2NvcGVbXSxcbiAgICBhdHRyczogeyBbbmFtZTogc3RyaW5nXTogQXR0cmlidXRlIH0gfCB1bmRlZmluZWQsXG4gICAgbmVzdGluZ19tb2RlOiBzdHJpbmdcbiAgKSB7XG4gICAgbGV0IGF0dHJpYnV0ZXMgPSBuZXcgQXJyYXk8QXR0cmlidXRlTW9kZWw+KCk7XG4gICAgY29uc3QgcGFyZW50ID0gc2NvcGVbc2NvcGUubGVuZ3RoIC0gMV07XG4gICAgaWYgKGF0dHJzKSB7XG4gICAgICBmb3IgKGNvbnN0IFt0ZXJyYWZvcm1OYW1lLCBhdHRdIG9mIE9iamVjdC5lbnRyaWVzKGF0dHJzIHx8IHt9KSkge1xuICAgICAgICAvLyBuZXN0ZWQgdHlwZXMgc3VwcG9ydCBjb21wdXRlZCwgb3B0aW9uYWwgYW5kIHJlcXVpcmVkIG9uIGF0dHJpYnV0ZSBsZXZlbFxuICAgICAgICAvLyBpZiBwYXJlbnQgaXMgY29tcHV0ZWQsIGNoaWxkIGFsd2F5cyBpcyBjb21wdXRlZCBhcyB3ZWxsXG4gICAgICAgIGNvbnN0IGNvbXB1dGVkID1cbiAgICAgICAgICAhIXBhcmVudC5pc0NvbXB1dGVkIHx8IChwYXJlbnQuaXNOZXN0ZWRUeXBlICYmICEhYXR0LmNvbXB1dGVkKTtcbiAgICAgICAgY29uc3Qgb3B0aW9uYWwgPSBwYXJlbnQuaXNOZXN0ZWRUeXBlXG4gICAgICAgICAgPyAhIWF0dC5vcHRpb25hbFxuICAgICAgICAgIDogISFwYXJlbnQuaXNPcHRpb25hbDtcbiAgICAgICAgY29uc3QgcmVxdWlyZWQgPSBwYXJlbnQuaXNOZXN0ZWRUeXBlXG4gICAgICAgICAgPyAhIWF0dC5yZXF1aXJlZFxuICAgICAgICAgIDogISFwYXJlbnQuaXNSZXF1aXJlZDtcbiAgICAgICAgY29uc3QgbmFtZSA9IHRvQ2FtZWxDYXNlKHRlcnJhZm9ybU5hbWUpO1xuICAgICAgICBjb25zdCB0eXBlID0gdGhpcy5yZW5kZXJBdHRyaWJ1dGVUeXBlKFxuICAgICAgICAgIFtcbiAgICAgICAgICAgIC4uLnNjb3BlLFxuICAgICAgICAgICAgbmV3IFNjb3BlKHtcbiAgICAgICAgICAgICAgbmFtZTogdGVycmFmb3JtTmFtZSxcbiAgICAgICAgICAgICAgcGFyZW50LFxuICAgICAgICAgICAgICBpc1Byb3ZpZGVyOiBwYXJlbnQuaXNQcm92aWRlcixcbiAgICAgICAgICAgICAgaXNDb21wdXRlZDogY29tcHV0ZWQsXG4gICAgICAgICAgICAgIGlzT3B0aW9uYWw6IG9wdGlvbmFsLFxuICAgICAgICAgICAgICBpc1JlcXVpcmVkOiByZXF1aXJlZCxcbiAgICAgICAgICAgICAgaXNOZXN0ZWRUeXBlOiBwYXJlbnQuaXNOZXN0ZWRUeXBlLFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgXSxcbiAgICAgICAgICBhdHQudHlwZSB8fCBhdHQubmVzdGVkX3R5cGVcbiAgICAgICAgKTtcbiAgICAgICAgYXR0cmlidXRlcy5wdXNoKFxuICAgICAgICAgIG5ldyBBdHRyaWJ1dGVNb2RlbCh7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgc3RvcmFnZU5hbWU6IGBfJHtuYW1lfWAsXG4gICAgICAgICAgICBjb21wdXRlZDogY29tcHV0ZWQsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogYXR0LmRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgb3B0aW9uYWw6IG9wdGlvbmFsLFxuICAgICAgICAgICAgdGVycmFmb3JtTmFtZSxcbiAgICAgICAgICAgIHRlcnJhZm9ybUZ1bGxOYW1lOiBwYXJlbnQuZnVsbE5hbWUodGVycmFmb3JtTmFtZSksXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgcHJvdmlkZXI6IHBhcmVudC5pc1Byb3ZpZGVyLFxuICAgICAgICAgICAgcmVxdWlyZWQ6IHJlcXVpcmVkLFxuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgYXR0cmlidXRlcyA9IGRlZHVwbGljYXRlQXR0cmlidXRlc1dpdGhTYW1lTmFtZShhdHRyaWJ1dGVzKTtcblxuICAgIHJldHVybiB0aGlzLmFkZFN0cnVjdChzY29wZSwgYXR0cmlidXRlcywgbmVzdGluZ19tb2RlKTtcbiAgfVxuXG4gIHByaXZhdGUgYWRkU3RydWN0KFxuICAgIHNjb3BlOiBTY29wZVtdLFxuICAgIGF0dHJpYnV0ZXM6IEF0dHJpYnV0ZU1vZGVsW10sXG4gICAgbmVzdGluZ19tb2RlOiBzdHJpbmcsXG4gICAgaXNTaW5nbGVJdGVtID0gZmFsc2VcbiAgKSB7XG4gICAgY29uc3QgcG9zc2libGVOYW1lID0gdG9QYXNjYWxDYXNlKFxuICAgICAgc2NvcGUubWFwKCh4KSA9PiB0b1NuYWtlQ2FzZSh4Lm5hbWUpKS5qb2luKFwiX1wiKVxuICAgICk7XG4gICAgY29uc3QgbmFtZSA9IHRoaXMudW5pcXVlQ2xhc3NOYW1lKFxuICAgICAgaXNSZXNlcnZlZFN0cnVjdENsYXNzTmFtZShwb3NzaWJsZU5hbWUpXG4gICAgICAgID8gYCR7cG9zc2libGVOYW1lfVN0cnVjdGBcbiAgICAgICAgOiBwb3NzaWJsZU5hbWVcbiAgICApO1xuXG4gICAgY29uc3QgcGFyZW50ID0gc2NvcGVbc2NvcGUubGVuZ3RoIC0gMV07XG4gICAgLy8gYmxvY2tUeXBlLm5lc3RpbmdfbW9kZSA9PiBsaXN0L3NldCAmIGJsb2NrVHlwZS5tYXhfaXRlbXMgPT09IDEsXG4gICAgY29uc3QgaXNDbGFzcyA9IChwYXJlbnQuaXNDb21wdXRlZCAmJiAhcGFyZW50LmlzT3B0aW9uYWwpIHx8IGlzU2luZ2xlSXRlbTtcbiAgICBjb25zdCBpc0Fub255bW91cyA9IHRydWU7XG4gICAgY29uc3QgcyA9IG5ldyBTdHJ1Y3QoXG4gICAgICBuYW1lLFxuICAgICAgYXR0cmlidXRlcyxcbiAgICAgIGlzQ2xhc3MsXG4gICAgICBpc0Fub255bW91cyxcbiAgICAgIGlzU2luZ2xlSXRlbSxcbiAgICAgIG5lc3RpbmdfbW9kZVxuICAgICk7XG4gICAgdGhpcy5zdHJ1Y3RzLnB1c2gocyk7XG4gICAgcmV0dXJuIHM7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFJlc291cmNlUGFyc2VyIHtcbiAgcHJpdmF0ZSB1bmlxdWVDbGFzc25hbWVzOiBzdHJpbmdbXSA9IFtdO1xuICBwcml2YXRlIHJlc291cmNlczogUmVjb3JkPHN0cmluZywgUmVzb3VyY2VNb2RlbD4gPSB7fTtcblxuICBwdWJsaWMgcGFyc2UoXG4gICAgZnFwbjogRlFQTixcbiAgICB0eXBlOiBzdHJpbmcsXG4gICAgc2NoZW1hOiBTY2hlbWEsXG4gICAgdGVycmFmb3JtVHlwZTogc3RyaW5nLFxuICAgIGNvbnN0cmFpbnQ/OiBDb25zdHJ1Y3RzTWFrZXJUYXJnZXRcbiAgKTogUmVzb3VyY2VNb2RlbCB7XG4gICAgaWYgKHRoaXMucmVzb3VyY2VzW3R5cGVdKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZXNvdXJjZXNbdHlwZV07XG4gICAgfVxuXG4gICAgY29uc3QgcGFyc2VyID0gbmV3IFBhcnNlcih0aGlzLnVuaXF1ZUNsYXNzbmFtZXMpO1xuICAgIGNvbnN0IHJlc291cmNlID0gcGFyc2VyLnJlc291cmNlRnJvbShcbiAgICAgIGZxcG4sXG4gICAgICB0eXBlLFxuICAgICAgc2NoZW1hLFxuICAgICAgdGVycmFmb3JtVHlwZSxcbiAgICAgIGNvbnN0cmFpbnRcbiAgICApO1xuICAgIHRoaXMucmVzb3VyY2VzW3R5cGVdID0gcmVzb3VyY2U7XG4gICAgcmV0dXJuIHJlc291cmNlO1xuICB9XG5cbiAgLy8gVXNlZCBieSBjb252ZXJ0IHRvIGRldGVybWluZSB0aGUgcmlnaHQgbmFtZSBmb3IgYSBjbGFzc1xuICBwdWJsaWMgZ2V0Q2xhc3NOYW1lRm9yUmVzb3VyY2UodGVycmFmb3JtVHlwZTogc3RyaW5nKSB7XG4gICAgY29uc3QgcmVzb3VyY2UgPSB0aGlzLnJlc291cmNlc1t0ZXJyYWZvcm1UeXBlXTtcbiAgICByZXR1cm4gcmVzb3VyY2UgPyByZXNvdXJjZS5jbGFzc05hbWUgOiBcIlwiO1xuICB9XG5cbiAgLy8gVXNlZCBieSBjb252ZXJ0IHRvIGRldGVybWluZSB0aGUgcmlnaHQgbmFtZSBmb3IgYSBuYW1lc3BhY2VcbiAgcHVibGljIGdldE5hbWVzcGFjZU5hbWVGb3JSZXNvdXJjZSh0ZXJyYWZvcm1UeXBlOiBzdHJpbmcpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2UgZXh0ZXJuYWwgcHJvdmlkZXIgc2luY2UgdGhlIG5hbWUgb2YgcmVzb3VyY2UgZG9lc24ndCBoYXZlIGEgcHJlZml4XG4gICAgaWYgKHRlcnJhZm9ybVR5cGUgPT09IFwiZGF0YV9leHRlcm5hbF9cIikge1xuICAgICAgdGVycmFmb3JtVHlwZSA9IFwiZGF0YV9leHRlcm5hbFwiO1xuICAgIH1cblxuICAgIGNvbnN0IHJlc291cmNlID0gdGhpcy5yZXNvdXJjZXNbdGVycmFmb3JtVHlwZV07XG4gICAgaWYgKCFyZXNvdXJjZSkge1xuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIGNvbnN0IGZvbGRlciA9IGBwcm92aWRlcnMvJHtyZXNvdXJjZS5wcm92aWRlcn1gO1xuICAgIHJldHVybiByZXNvdXJjZS5maWxlUGF0aC5yZXBsYWNlKGAke2ZvbGRlcn0vYCwgXCJcIikucmVwbGFjZShcIi9pbmRleC50c1wiLCBcIlwiKTtcbiAgfVxufVxuIl19