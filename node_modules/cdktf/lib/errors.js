"use strict";
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.unableToResolveCircularReference = exports.intrinsicNewError = exports.argToIntrinsicMustBePlainValue = exports.indexTooLargeToEncode = exports.canOnlyEncodePositiveIntegers = exports.doesNotImplementDependableTrait = exports.cannotConcatenateStringsInTokenizedMap = exports.mapValueAddedToReferenceList = exports.numberValueAddedToReferenceList = exports.cannotConcatenateStringsInTokenizedStringArray = exports.stringValueAddedToReferenceList = exports.cannotCalcIdForEmptySetOfComponents = exports.functionArgumentValidationFailure = exports.functionReceivedWrongNumberOfArgs = exports.listElementIsOfWrongType = exports.valueIsInvalidNumberOrToken = exports.valueIsInvalidStringOrToken = exports.encounteredAnnotationWithLevelError = exports.valueContainsUnescapedQuotes = exports.cloudBackendWorkspaceIsNotDefinedByName = exports.constructDependencyBelowV10 = exports.sourceOrTargetNotAnObject = exports.targetNotResolvableWithOverrides = exports.invalidStack = exports.expectNotGloballyAccessible = exports.jestNotInstantiated = exports.matchersFoundErrorsInStack = exports.matchersPathIsNotDirectory = exports.stackValidationFailure = exports.stackHasCircularDependency = exports.noStackForConstruct = exports.stackIdContainsWhitespace = exports.stackContainsDisallowedChar = exports.resourceGivenTwoMoveOperationsByTarget = exports.resourceGivenTwoMoveOperationsById = exports.resourceGivenTwoMoveOperationsByTargetAndId = exports.movedToResourceOfDifferentType = exports.moveTargetNotSet = exports.moveTargetAlreadySet = exports.modulesWithSameAlias = exports.iteratorOnResourceWithoutForEach = exports.iteratorOnResourceWithCount = exports.unresolvedTokenInConstructId = exports.dynamicBlockNotSupported = exports.assetTypeNotImplemented = exports.assetExpectsDirectory = exports.assetOutOfScopeOfCDKTFJson = exports.providerVersionMismatch = exports.appValidationFailure = exports.noAppFound = void 0;
exports.IdIncludesUnresolvedTokens = exports.unrecognizedTokenKey = exports.unknownNumberTokenFound = exports.mapKeyMustResolveToString = exports.constructsCannotBeResolved = exports.encodedMapTokenInScalarNumberContext = exports.encodedMapTokenInScalarStringContext = exports.encodedListTokenInScalarStringContext = exports.cannotResolveFunction = void 0;
const noAppFound = (constructPath) => new Error(`No app could be identified for the construct at path '${constructPath}', likely a TerraformStack.
The scope of CDKTF's TerraformStack class is a single App instance created by 'const app = new App()'. The App is the root of your project that holds project configuration and validations.
You can learn more about the App here: https://developer.hashicorp.com/terraform/cdktf/concepts/cdktf-architecture#app-class:~:text=and%20Resource.-,App%20Class,-Each%20CDKTF%20project
    `);
exports.noAppFound = noAppFound;
const appValidationFailure = (errorList) => new Error(`App level validation failed with the following errors:\n  ${errorList}
Validations allow for dynamic verification of your project.
To skip validations, add 'skipValidation: true' to your App config
    `);
exports.appValidationFailure = appValidationFailure;
const providerVersionMismatch = () => new Error(`Version mismatch detected: The provider bindings seem to have been built for an older version of CDKTF. 
Upgrade your pre-built provider or re-run cdktf get with a more recent version (>= 0.10) of the cdktf-cli.
    `);
exports.providerVersionMismatch = providerVersionMismatch;
const assetOutOfScopeOfCDKTFJson = (id, configPath) => new Error(`TerraformAsset ${id} was created with a relative path '${configPath}', but no cdktf.json file was found to base it on.

The cdktf.json is needed to establish the base for the relative path (e.g the '.' in './foo/bar'). We cannot find the cdktf.json within your current working directory '${process.cwd()}'
To avoid this, please place a cdktf.json at the root of your project. Learn more here: https://developer.hashicorp.com/terraform/cdktf/create-and-deploy/configuration-file
To learn more about TerraformAsset read here: https://developer.hashicorp.com/terraform/cdktf/concepts/assets
`);
exports.assetOutOfScopeOfCDKTFJson = assetOutOfScopeOfCDKTFJson;
const assetExpectsDirectory = (id, configPath) => new Error(`TerraformAsset ${id} expects path to be a directory, a file was passed: '${configPath}'
To learn more about TerraformAsset read here: https://developer.hashicorp.com/terraform/cdktf/concepts/assets
    `);
exports.assetExpectsDirectory = assetExpectsDirectory;
const assetTypeNotImplemented = () => new Error(`Asset type is not implemented
Possible Asset types include: FILE, DIRECTORY, and ARCHIVE
The values are to be taken from the AssetType Enum.
To learn more about TerraformAsset read here: https://developer.hashicorp.com/terraform/cdktf/concepts/assets
  `);
exports.assetTypeNotImplemented = assetTypeNotImplemented;
const dynamicBlockNotSupported = (_foreachExpression) => new Error(`Tried to directly resolve a TerraformDynamicBlock which is not supported.
The TerraformDynamicBlock is created by calling '.dynamic' on a TerraformIterator instance.
Dynamic blocks are only supported on block attributes of resources, data sources and providers.

The expression used for the dynamic block: .dynamic({
  ${_foreachExpression}
})
`);
exports.dynamicBlockNotSupported = dynamicBlockNotSupported;
const unresolvedTokenInConstructId = (id) => new Error(`You cannot use a Token (e.g. a reference to an attribute) as the id of a construct.
The following id was passed: "${id}"
Ids of constructs must be known at synthesis time and the value of tokens is only known when Terraform runs, hence you cannot use tokens in construct ids.`);
exports.unresolvedTokenInConstructId = unresolvedTokenInConstructId;
const iteratorOnResourceWithCount = () => new Error(`Cannot create iterator from a resource with a count argument.
The resource passed to the iterator has a count argument which determines how many instances of the resource are created.
Please re-use the same TerraformCount used in this resource on the resource where you planned to use this iterator instead.

If you need to use the iterator to populate a list attribute, replace the count on the resource with an iterator passed into the forEach argument.`);
exports.iteratorOnResourceWithCount = iteratorOnResourceWithCount;
const iteratorOnResourceWithoutForEach = () => new Error(`Cannot create an iterator from resource without a forEach argument.
The resource passed to the iterator does not have a forEach argument, meaning only a single instance of it will be created.
If you want to create more instances of this resource pass an iterator to the forEach argument of the resource first.
  `);
exports.iteratorOnResourceWithoutForEach = iteratorOnResourceWithoutForEach;
const modulesWithSameAlias = (alias) => new Error(`Error: Multiple providers have the same alias: "${alias}"
When passing multiple providers of the same type to modules, each provider must have a unique alias.
  `);
exports.modulesWithSameAlias = modulesWithSameAlias;
const moveTargetAlreadySet = (target, friendlyUniqueId) => new Error(`Target "${target}" has already been used for the construct at ${friendlyUniqueId}.
Target must be a string that is unique across all resources in the same stack.`);
exports.moveTargetAlreadySet = moveTargetAlreadySet;
const moveTargetNotSet = (target, entries) => new Error(`Target "${target}" has not been set.
You tried to move a resource to a target that has not been set on any resource.
Call .addMoveTarget("${target}") on the instance of the resource you want to move this one to.

Alternatively you can use one of the following targets (in case you had a typo):
${entries}
`);
exports.moveTargetNotSet = moveTargetNotSet;
const movedToResourceOfDifferentType = (moveTarget, originalResourceType, destinationResourceType) => new Error(`You have tried to move a resource to a different type which is not supported.

The move target "${moveTarget}" corresponding to the resource of type ${destinationResourceType} to move to differs from the resource of type ${originalResourceType} being moved from.

If this was intentional, you can instead try importing the existing resource into your target as described in the import docs:
https://developer.hashicorp.com/terraform/cdktf/concepts/resources#importing-resources

Please note, that you will manually need to remove the original resource from your state file after importing it, using the "terraform state rm" command in the output directory of the stack this resource is defined in. Read more about the command here:
https://developer.hashicorp.com/terraform/cli/commands/state/rm
`);
exports.movedToResourceOfDifferentType = movedToResourceOfDifferentType;
const resourceGivenTwoMoveOperationsByTargetAndId = (id, existingTarget, newMove) => new Error(`
${id} has been given two separate moved operations.

Move target: "${existingTarget}"
Move by id: {
  from: ${newMove.from}
  to: ${newMove.to}
}

Only one move operation can occur per plan/apply. Remove one of the operations.

To learn more about moving resources see: https://developer.hashicorp.com/terraform/cdktf/examples-and-guides/refactoring#:~:text=Moving%20%26%20Renaming%20Resources%20Within%20a%20Stack
`);
exports.resourceGivenTwoMoveOperationsByTargetAndId = resourceGivenTwoMoveOperationsByTargetAndId;
const resourceGivenTwoMoveOperationsById = (id, existingMove, newMove) => new Error(`
${id} has been given two separate moved operations.

{
  from: ${existingMove.from}
  to: ${existingMove.to}
}
{
  from: ${newMove.from}
  to: ${newMove.to} (Resource calling the move to operation)
}

Only one move operation can occur per plan/apply. Remove one of the operations.

To learn more about moving resources see: https://developer.hashicorp.com/terraform/cdktf/examples-and-guides/refactoring#:~:text=Moving%20%26%20Renaming%20Resources%20Within%20a%20Stack
`);
exports.resourceGivenTwoMoveOperationsById = resourceGivenTwoMoveOperationsById;
const resourceGivenTwoMoveOperationsByTarget = (resourceId, existingMoveTarget, newMoveTarget) => new Error(`The resource ${resourceId} has been given two moveTargets: "${newMoveTarget}" and "${existingMoveTarget}"

A resource can only be moved once per plan/apply

To learn more about moving resources see: https://developer.hashicorp.com/terraform/cdktf/examples-and-guides/refactoring#:~:text=Moving%20%26%20Renaming%20Resources%20Within%20a%20Stack
`);
exports.resourceGivenTwoMoveOperationsByTarget = resourceGivenTwoMoveOperationsByTarget;
const stackContainsDisallowedChar = (stackId, invalidChar) => new Error(`Can not create Terraform stack with id "${stackId}". It contains a glob character: "${invalidChar}"

Glob characters are disallowed in stack names due to their use in deploying/destroying multiple stacks 

Such as 'cdktf deploy \`*-production\`' which deploys all stacks with names that end in '-production'
`);
exports.stackContainsDisallowedChar = stackContainsDisallowedChar;
const stackIdContainsWhitespace = (stackId) => new Error(`Can not create TerraformStack with id "${stackId}". It contains a whitespace character.

Please remove any whitespace characters in your TerraformStack id like so: "${stackId.replace(/\s/g, "")}"
`);
exports.stackIdContainsWhitespace = stackIdContainsWhitespace;
const noStackForConstruct = (constructPath, hint) => new Error(`No stack could be identified for the construct at path '${constructPath}'${hint}

Constructs can only be used as a part of a TerraformStack. While Constructs represent a collection of infrastructure, they must be used within a TerraformStack to be apart of a dedication Terraform configuration.

To learn more about Constructs vs. TerraformStacks see here: https://developer.hashicorp.com/terraform/cdktf/concepts/constructs#:~:text=Constructs%20vs.%20Stacks
`);
exports.noStackForConstruct = noStackForConstruct;
const stackHasCircularDependency = (thisStack, dependency) => new Error(`Can not add dependency ${dependency} to ${thisStack} since it would result in a loop

This is caused by the TerraformStack ${dependency} already being dependent on ${thisStack} directly, or dependent on a TerraformStack within ${thisStack}
  
To learn more about cross-stack references see here: https://developer.hashicorp.com/terraform/cdktf/concepts/stacks#:~:text=Cross%2DStack%20References
`);
exports.stackHasCircularDependency = stackHasCircularDependency;
const stackValidationFailure = (errorList) => new Error(`Validation failed with the following errors:\n  ${errorList}
  
If you wish to ignore these validations, pass 'skipValidation: true' to your App config
`);
exports.stackValidationFailure = stackValidationFailure;
const matchersPathIsNotDirectory = (functionName) => new Error(`Path is not a directory

Ensure you are passing the result of Testing.fullSynth('stack instance') and not Testing.synth('stack instance') in your usage of '${functionName}'. 

Testing.fullSynth returns a file path to temporary testing environment. This file path is used in CDKTF tests that ensure your TerraformStack produces a validate Terraform configuration (toBeValidTerraform & toPlanSuccessfully).
Like so: "Testing.toBeValidateTerraform(Testing.fullSynth('TerraformStack instance'))"

Testing.synth returns the JSON representation of your stack. This JSON can then be used in CDKTF assertions that check the composition of your stacks (toHaveResource, toHaveDataSource, ect.)
Like so: "Testing.toHaveResource(Testing.synth('TerraformStack instance'), S3Bucket)"

To learn more about testing in CDKTF see: https://developer.hashicorp.com/terraform/cdktf/test/unit-tests`);
exports.matchersPathIsNotDirectory = matchersPathIsNotDirectory;
const matchersFoundErrorsInStack = (errorCount, stackName, diagnostics) => new Error(`Found ${errorCount} Errors in stack ${stackName}: ${diagnostics}
  
These errors are not failures of your tests, but issues with the underlying TerraformStack being tested. Fix the above issues before running tests again.
`);
exports.matchersFoundErrorsInStack = matchersFoundErrorsInStack;
const jestNotInstantiated = () => new Error(`expect is not defined, jest was not properly instantiated
  
Ensure you have a 'setup.js' file in your project's directory that calls 'cdktf.Testing.setupJest()'

To learn more about setting up testing see: https://developer.hashicorp.com/terraform/cdktf/test/unit-tests#:~:text=Add%20Testing%20to%20Your%20Application
`);
exports.jestNotInstantiated = jestNotInstantiated;
const expectNotGloballyAccessible = () => new Error(`setupJest called, but expect is not globally accessible

To learn more about setting up testing see: https://developer.hashicorp.com/terraform/cdktf/test/unit-tests#:~:text=Add%20Testing%20to%20Your%20Application
`);
exports.expectNotGloballyAccessible = expectNotGloballyAccessible;
const invalidStack = (stackContent) => new Error(`invalid JSON string passed: ${stackContent}

Ensure you are passing the result of Testing.synth('stack instance') and not Testing.fullSynth('stack instance'). 

Testing.synth returns the JSON representation of your stack. This JSON can then be used in CDKTF assertions that check the composition of your stacks (toHaveResource, toHaveDataSource, ect.)
Like so: "Testing.toHaveResource(Testing.synth('TerraformStack instance'), S3Bucket)"

Testing.fullSynth returns a file path to temporary testing environment. This file path is used in CDKTF tests that ensure your TerraformStack produces a validate Terraform configuration (toBeValidTerraform & toPlanSuccessfully).
Like so: "Testing.toBeValidateTerraform(Testing.fullSynth('TerraformStack instance'))"

To learn more about testing in CDKTF see: https://developer.hashicorp.com/terraform/cdktf/test/unit-tests`);
exports.invalidStack = invalidStack;
const targetNotResolvableWithOverrides = (target) => new Error(`Invalid usage. Target (${target}) can not be a resolvable token when overrides are specified. Please replace the value of the field you are overriding with a static value.

Because the target is a resolvable Token any overrides cannot be applied as it has not yet been resolved. 

To learn more about Tokens see here: https://developer.hashicorp.com/terraform/cdktf/concepts/tokens
`);
exports.targetNotResolvableWithOverrides = targetNotResolvableWithOverrides;
const sourceOrTargetNotAnObject = (source, sourceType, target, targetType) => new Error(`An issue was encountered during the synthesization of your Terraform configuration. 
  
Both the source element (${source}) and and its containing target element (${target}) must be objects

Type of source: ${sourceType}
Type of target: ${targetType}
`);
exports.sourceOrTargetNotAnObject = sourceOrTargetNotAnObject;
const constructDependencyBelowV10 = () => new Error(`Version mismatch! The constructs dependency appears to be lower than v10 which is required as of cdktf version 0.6.
Your current constructs version is missing Construct.node which was added in v10.
Please update your constructs dependency: https://cdk.tf/upgrade-constructs-v10
`);
exports.constructDependencyBelowV10 = constructDependencyBelowV10;
const cloudBackendWorkspaceIsNotDefinedByName = () => new Error(`The Cloud backend only supports cross-stack references when the workspace is defined by name instead of by tags.

To properly utilize cross-stack references, replace your usage of 'TaggedCloudWorkspaces' to 'NamedCloudWorkspace' like so:

new CloudBackend(stack, {
  ...
  workspaces: new NamedCloudWorkspace("my-app"),
});

To learn more about Remote Backends see: https://developer.hashicorp.com/terraform/cdktf/concepts/remote-backends
`);
exports.cloudBackendWorkspaceIsNotDefinedByName = cloudBackendWorkspaceIsNotDefinedByName;
const valueContainsUnescapedQuotes = (value) => new Error(`'${value}' can not be used as value directly since it has unescaped double quotes in it.

To safely use the value, use Fn.rawString on your string like so:

Fn.rawString('${value}')

This is needed as CDKTF or Terraform will otherwise try to interpret these double quotes incorrectly.

To learn more about built in Terraform functions within CDKTF see: https://developer.hashicorp.com/terraform/cdktf/concepts/functions
`);
exports.valueContainsUnescapedQuotes = valueContainsUnescapedQuotes;
const encounteredAnnotationWithLevelError = (errors) => new Error(`Encountered Annotations with level "ERROR":\n${errors}
  
Either fix the issues above, or set the environment variable CDKTF_CONTINUE_SYNTH_ON_ERROR_ANNOTATIONS to ignore these annotations
`);
exports.encounteredAnnotationWithLevelError = encounteredAnnotationWithLevelError;
const valueIsInvalidStringOrToken = (value) => new Error(`'${value}' is not a valid string nor a token, This function only accepts strings or tokens resolving to strings, please change your code accordingly.`);
exports.valueIsInvalidStringOrToken = valueIsInvalidStringOrToken;
const valueIsInvalidNumberOrToken = (value) => new Error(`${value} is not a valid number nor a token. This function only accepts numbers or tokens resolving to numbers, please change your code accordingly.`);
exports.valueIsInvalidNumberOrToken = valueIsInvalidNumberOrToken;
const listElementIsOfWrongType = (value, position, error) => new Error(`Element in list ${value} at position ${position} is not of the right type: ${error}. Please make sure all elements in the list are of the correct type for this function.`);
exports.listElementIsOfWrongType = listElementIsOfWrongType;
const functionReceivedWrongNumberOfArgs = (name, argValidatorsLength, argsLength) => new Error(`${name} takes ${argValidatorsLength} arguments, but ${argsLength} were provided. Please provide the missing arguments to the function.`);
exports.functionReceivedWrongNumberOfArgs = functionReceivedWrongNumberOfArgs;
const functionArgumentValidationFailure = (argNumber, name, error) => new Error(`Argument ${argNumber} of ${name} failed the validation: ${error}. Please change your code to pass a valid value for this argument.`);
exports.functionArgumentValidationFailure = functionArgumentValidationFailure;
const cannotCalcIdForEmptySetOfComponents = () => new Error(`Unable to calculate a unique id for an empty set of components. This can only happen if you are trying to create a unique id while not passing in any construct node ids. This means your construct likely has no parent, which is not allowed. Please make sure your construct has a parent, e.g. new App(this) or new TerraformStack(this, 'stack')`);
exports.cannotCalcIdForEmptySetOfComponents = cannotCalcIdForEmptySetOfComponents;
const stringValueAddedToReferenceList = (listToken) => new Error(`Cannot add elements to list token, got: ${listToken}. We expect the elements of a tokenized string array to be a single string token, e.g. ["&{TfToken[Token.1]}"]. In this case the one element in the array consist of more than one value. To add values to a tokenized list use Terraform Functions instead, e.g. Fn.concat([yourReferencedList, ["my", "new", "items"]]).`);
exports.stringValueAddedToReferenceList = stringValueAddedToReferenceList;
const cannotConcatenateStringsInTokenizedStringArray = (listToken) => new Error(`Cannot concatenate strings in a tokenized string array, got: ${listToken}. We expect the elements of a tokenized string array to be a single string token, e.g. ["&{TfToken[Token.1]}"]. In this case the one element in the array consist of something different than a single token, likely by mutating the value inside this list. This leads to CDKTF not being able to resolve the token into the appropriate runtime value. Please don't mutate tokenized string arrays.`);
exports.cannotConcatenateStringsInTokenizedStringArray = cannotConcatenateStringsInTokenizedStringArray;
const numberValueAddedToReferenceList = (listToken) => new Error(`Cannot add elements to list token, got: ${listToken}. Tokens are used to represent runtime values (e.g. references to attributes of resource or data sources), they don't contain the values since the values are only available at apply time, whereas the Tokens are present during compile time. You tried to add a value to a tokenized list, this should be done via Terraform function: Fn.concat([yourReferencedList, [42, 43, 44]]).`);
exports.numberValueAddedToReferenceList = numberValueAddedToReferenceList;
const mapValueAddedToReferenceList = (mapToken) => new Error(`Cannot add elements to map token, got: ${mapToken}. This can happen if you merge multiple maps or if you add a new key value pair to the map token. Tokens are used to represent runtime values (e.g. references to attributes of resource or data sources), they don't contain the values since the values are only available at apply time, whereas the Tokens are present during compile time. Instead of adding the value to the tokenized map you need to use a Terraform Function, e.g. Fn.merge([yourReferencedMap, { your: 'value' }]) that creates a new map Token for a value that represents what you want to express. For example this might get rendered as merge(my_resource.resource_name.one_specific_map_attribute, { your: ' value' })`);
exports.mapValueAddedToReferenceList = mapValueAddedToReferenceList;
const cannotConcatenateStringsInTokenizedMap = (tokenizedMap) => new Error(`Cannot concatenate strings in a tokenized map, got: ${tokenizedMap}. We expect the key of a tokenized map to be a string token, e.g. { "&{TfToken[Token.1]}": "String Map Token Value" }. In this case the key in the map consists of more than a string token (e.g. the Token and a static string or multiple Token). This can happen if you mutate the key of the map, which is not allowed. Please don't mutate tokenized Maps as it makes it impossible for CDKTF to translate them to their intended values.`);
exports.cannotConcatenateStringsInTokenizedMap = cannotConcatenateStringsInTokenizedMap;
const doesNotImplementDependableTrait = (instance) => new Error(`${instance} does not implement DependableTrait`);
exports.doesNotImplementDependableTrait = doesNotImplementDependableTrait;
const canOnlyEncodePositiveIntegers = () => new Error(`Can only encode positive integers into Tokens. This is a bug in CDKTF, please file a bug report.`);
exports.canOnlyEncodePositiveIntegers = canOnlyEncodePositiveIntegers;
const indexTooLargeToEncode = (index) => new Error(`Got an index too large to encode into a Token :${index}. This happens if you have an enormous amount of Tokens in a single CDKTF application. Most likely you are creating numeric tokens in an infinite loop, e.g. by calling 'Token.asNumber()' a lot. If you reach the maximum number of allowed Tokens (a limitation imposed by the way we encode Tokens / separate them from real numeric values) you need to work around this issue by splitting up your application into multiple applications.`);
exports.indexTooLargeToEncode = indexTooLargeToEncode;
const argToIntrinsicMustBePlainValue = (value, creationStack) => new Error(`You can only use a plain value (not a function) when creating an Intrinsic token. We got the value '${value}' created at:\n${creationStack.join("\n")}. If you want to use a function, please use the Lazy class, e.g. Lazy.anyValue({ produce: () => "Hello World" }).`);
exports.argToIntrinsicMustBePlainValue = argToIntrinsicMustBePlainValue;
const intrinsicNewError = (message, createdAt) => new Error(`${message}\nToken created:\n    at ${createdAt}\nError thrown:`);
exports.intrinsicNewError = intrinsicNewError;
const unableToResolveCircularReference = (pathName) => new Error(`Unable to resolve object tree with circular reference at '${pathName}'.
This error is thrown if the depth of the object tree is greater than 200 to protect against cyclic references.
To resolve this inspect the construct creating the cyclic reference (most likely in '${pathName}') and make sure
it does not create an infinite nesting of constructs.`);
exports.unableToResolveCircularReference = unableToResolveCircularReference;
const cannotResolveFunction = (pathName, obj) => new Error(`Trying to resolve a non-data object (e.g. a function) at '${pathName}': ${obj}. Only tokens are supported for lazy evaluation.
If you want to have a lazily computed value, please use the Lazy class, e.g. Lazy.stringValue({ produce: () => "Hello World" })`);
exports.cannotResolveFunction = cannotResolveFunction;
const LIST_ERROR_EXPLANATION = `In CDKTF we represent lists where the value is only known at runtime (versus compile / synth time) as
Arrays with a single element that is a string token, e.g. ["Token.1"]. This is because at compile time we
don't know the length of the list, so far CDKTF did not invoke Terraform to communicate with the cloud provider.
This is done at a later stage on the synthesized static JSON file.
As we don't know the length of the list not the content we can not differentiate if the list was accessed at the first index,
the last index, or as part of a loop. To avoid this ambiguity:

- If you want to access a singular item use 'Fn.element(list, 0)' (not 'list[0]')
- If you want to loop over the list use 'TerraformIterator.fromList(list)' (not 'for (const item of list)' or 'list.forEach(item => ...)')

To learn more about tokens see https://developer.hashicorp.com/terraform/cdktf/concepts/tokens
To learn more about iterators see https://developer.hashicorp.com/terraform/cdktf/concepts/iterators`;
const MAP_ERROR_EXPLANATION = `In CDKTF we represent maps where the value is only known at runtime (versus compile / synth time) as
objects with a single key-value pair where the value is a string token, e.g. { "&{TfToken[Token.1]}": "String Map Token Value" }.
This is because the length of the list isn't know at compile time, as CDKTF has not yet invoked Terraform to communicate with the cloud provider.
This is done at a later stage on the synthesized static JSON file.
As we don't know the contents of the map we do not know which key was accessed, or if the map was accessed as part of a loop.
To avoid this ambiguity:

- If you want to access a singular item use 'Fn.lookup(map, key)' (not 'map[key]')
- If you want to loop over the map use 'TerraformIterator.fromMap(map)' (not 'for (const [key, value] of map)' or 'Object.entries(map).forEach((key, value) => ...)')

To learn more about tokens see https://developer.hashicorp.com/terraform/cdktf/concepts/tokens
To learn more about iterators see https://developer.hashicorp.com/terraform/cdktf/concepts/iterators`;
const encodedListTokenInScalarStringContext = () => new Error(`Found an encoded list token string in a scalar string context.
${LIST_ERROR_EXPLANATION}`);
exports.encodedListTokenInScalarStringContext = encodedListTokenInScalarStringContext;
const encodedMapTokenInScalarStringContext = () => new Error(`Found an encoded map token in a scalar string context.
${MAP_ERROR_EXPLANATION}`);
exports.encodedMapTokenInScalarStringContext = encodedMapTokenInScalarStringContext;
const encodedMapTokenInScalarNumberContext = () => new Error(`Found an encoded map token in a scalar number context.
${MAP_ERROR_EXPLANATION}`);
exports.encodedMapTokenInScalarNumberContext = encodedMapTokenInScalarNumberContext;
const constructsCannotBeResolved = (pathName) => new Error(`Trying to resolve() a Construct at '${pathName}'. 
This often means that there is an unintended cyclic dependency in your construct tree, leading to the resolution being stuck in an infinite loop which will eventually fail. This can happen if the scope passed into this construct is also part of its subtree in some way. To resolve this issue, please refactor your code to avoid this cyclic dependency by changing the scope of this construct.`);
exports.constructsCannotBeResolved = constructsCannotBeResolved;
const mapKeyMustResolveToString = (pathName, key, resolvedKey) => new Error(`At "${pathName}" the key "${key}" is used in a map so it must resolve to a string, but it resolves to a ${typeof resolvedKey} with the value ${JSON.stringify(resolvedKey)}. This means that the token used as the key is not resolving into string, you must change the Token so that it does.`);
exports.mapKeyMustResolveToString = mapKeyMustResolveToString;
const unknownTokenExplanation = `This means that you are trying to access a Token value that does not exist. This can only happen if the Token is e.g. from another CDK (i.e. AWS CDK, CDK8s, etc.) and is not known to the CDKTF Application. You either need to make the other CDK resolve this token before CDKTF tries to resolve the token or work around using this token at all. 

If this error occurs without another CDK (or a value looking like a Token) being involved, please file a bug.`;
const unknownNumberTokenFound = () => new Error(`Encoded representation of unknown number Token found. ${unknownTokenExplanation}`);
exports.unknownNumberTokenFound = unknownNumberTokenFound;
const unrecognizedTokenKey = (key) => new Error(`Unrecognized Token Key '${key}'. ${unknownTokenExplanation}`);
exports.unrecognizedTokenKey = unrecognizedTokenKey;
const IdIncludesUnresolvedTokens = (unresolvedTokens) => new Error(`This construct (or its parent construct) was configured with an ID that contains a Token: ${unresolvedTokens}. This is not allowed as IDs must be known statically during synthesis. The values of tokens are only known during apply, therefore they cannot be used in IDs. Please use a concrete value for your constructs ID instead.`);
exports.IdIncludesUnresolvedTokens = IdIncludesUnresolvedTokens;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXJyb3JzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiZXJyb3JzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTs7O0dBR0c7Ozs7QUFLSSxNQUFNLFVBQVUsR0FBRyxDQUFDLGFBQXFCLEVBQUUsRUFBRSxDQUNsRCxJQUFJLEtBQUssQ0FDUCx5REFBeUQsYUFBYTs7O0tBR3JFLENBQ0YsQ0FBQztBQU5TLFFBQUEsVUFBVSxjQU1uQjtBQUVHLE1BQU0sb0JBQW9CLEdBQUcsQ0FBQyxTQUFpQixFQUFFLEVBQUUsQ0FDeEQsSUFBSSxLQUFLLENBQ1AsNkRBQTZELFNBQVM7OztLQUdyRSxDQUNGLENBQUM7QUFOUyxRQUFBLG9CQUFvQix3QkFNN0I7QUFFRyxNQUFNLHVCQUF1QixHQUFHLEdBQUcsRUFBRSxDQUMxQyxJQUFJLEtBQUssQ0FDUDs7S0FFQyxDQUNGLENBQUM7QUFMUyxRQUFBLHVCQUF1QiwyQkFLaEM7QUFFRyxNQUFNLDBCQUEwQixHQUFHLENBQUMsRUFBVSxFQUFFLFVBQWtCLEVBQUUsRUFBRSxDQUMzRSxJQUFJLEtBQUssQ0FDUCxrQkFBa0IsRUFBRSxzQ0FBc0MsVUFBVTs7MEtBRWtHLE9BQU8sQ0FBQyxHQUFHLEVBQUU7OztDQUd0TCxDQUNFLENBQUM7QUFSUyxRQUFBLDBCQUEwQiw4QkFRbkM7QUFFRyxNQUFNLHFCQUFxQixHQUFHLENBQUMsRUFBVSxFQUFFLFVBQWtCLEVBQUUsRUFBRSxDQUN0RSxJQUFJLEtBQUssQ0FDUCxrQkFBa0IsRUFBRSx3REFBd0QsVUFBVTs7S0FFckYsQ0FDRixDQUFDO0FBTFMsUUFBQSxxQkFBcUIseUJBSzlCO0FBRUcsTUFBTSx1QkFBdUIsR0FBRyxHQUFHLEVBQUUsQ0FDMUMsSUFBSSxLQUFLLENBQUM7Ozs7R0FJVCxDQUFDLENBQUM7QUFMUSxRQUFBLHVCQUF1QiwyQkFLL0I7QUFFRSxNQUFNLHdCQUF3QixHQUFHLENBQUMsa0JBQTBCLEVBQUUsRUFBRSxDQUNyRSxJQUFJLEtBQUssQ0FD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RUFDVixxQkFBcUIsRUFBRSxDQUFDLENBQUM7QUFGZCxRQUFBLG9DQUFvQyx3Q0FFdEI7QUFFcEIsTUFBTSwwQkFBMEIsR0FBRyxDQUFDLFFBQWdCLEVBQUUsRUFBRSxDQUM3RCxJQUFJLEtBQUssQ0FBQyx1Q0FBdUMsUUFBUTt3WUFDNlUsQ0FBQyxDQUFDO0FBRjdYLFFBQUEsMEJBQTBCLDhCQUVtVztBQUVuWSxNQUFNLHlCQUF5QixHQUFHLENBQ3ZDLFFBQWdCLEVBQ2hCLEdBQVcsRUFDWCxXQUFnQixFQUNoQixFQUFFLENBQ0YsSUFBSSxLQUFLLENBQ1AsT0FBTyxRQUFRLGNBQWMsR0FBRywyRUFBMkUsT0FBTyxXQUFXLG1CQUFtQixJQUFJLENBQUMsU0FBUyxDQUM1SixXQUFXLENBQ1osc0hBQXNILENBQ3hILENBQUM7QUFUUyxRQUFBLHlCQUF5Qiw2QkFTbEM7QUFFSixNQUFNLHVCQUF1QixHQUFHOzs4R0FFOEUsQ0FBQztBQUV4RyxNQUFNLHVCQUF1QixHQUFHLEdBQUcsRUFBRSxDQUMxQyxJQUFJLEtBQUssQ0FDUCx5REFBeUQsdUJBQXVCLEVBQUUsQ0FDbkYsQ0FBQztBQUhTLFFBQUEsdUJBQXVCLDJCQUdoQztBQUVHLE1BQU0sb0JBQW9CLEdBQUcsQ0FBQyxHQUFXLEVBQUUsRUFBRSxDQUNsRCxJQUFJLEtBQUssQ0FBQywyQkFBMkIsR0FBRyxNQUFNLHVCQUF1QixFQUFFLENBQUMsQ0FBQztBQUQ5RCxRQUFBLG9CQUFvQix3QkFDMEM7QUFFcEUsTUFBTSwwQkFBMEIsR0FBRyxDQUFDLGdCQUF3QixFQUFFLEVBQUUsQ0FDckUsSUFBSSxLQUFLLENBQ1AsNkZBQTZGLGdCQUFnQiw2TkFBNk4sQ0FDM1UsQ0FBQztBQUhTLFFBQUEsMEJBQTBCLDhCQUduQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBIYXNoaUNvcnAsIEluYy5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBNUEwtMi4wXG4gKi9cblxuaW1wb3J0IHsgSURlcGVuZGFibGUgfSBmcm9tIFwiY29uc3RydWN0c1wiO1xuaW1wb3J0IHsgVGVycmFmb3JtU3RhY2sgfSBmcm9tIFwiLi90ZXJyYWZvcm0tc3RhY2tcIjtcblxuZXhwb3J0IGNvbnN0IG5vQXBwRm91bmQgPSAoY29uc3RydWN0UGF0aDogc3RyaW5nKSA9PlxuICBuZXcgRXJyb3IoXG4gICAgYE5vIGFwcCBjb3VsZCBiZSBpZGVudGlmaWVkIGZvciB0aGUgY29uc3RydWN0IGF0IHBhdGggJyR7Y29uc3RydWN0UGF0aH0nLCBsaWtlbHkgYSBUZXJyYWZvcm1TdGFjay5cblRoZSBzY29wZSBvZiBDREtURidzIFRlcnJhZm9ybVN0YWNrIGNsYXNzIGlzIGEgc2luZ2xlIEFwcCBpbnN0YW5jZSBjcmVhdGVkIGJ5ICdjb25zdCBhcHAgPSBuZXcgQXBwKCknLiBUaGUgQXBwIGlzIHRoZSByb290IG9mIHlvdXIgcHJvamVjdCB0aGF0IGhvbGRzIHByb2plY3QgY29uZmlndXJhdGlvbiBhbmQgdmFsaWRhdGlvbnMuXG5Zb3UgY2FuIGxlYXJuIG1vcmUgYWJvdXQgdGhlIEFwcCBoZXJlOiBodHRwczovL2RldmVsb3Blci5oYXNoaWNvcnAuY29tL3RlcnJhZm9ybS9jZGt0Zi9jb25jZXB0cy9jZGt0Zi1hcmNoaXRlY3R1cmUjYXBwLWNsYXNzOn46dGV4dD1hbmQlMjBSZXNvdXJjZS4tLEFwcCUyMENsYXNzLC1FYWNoJTIwQ0RLVEYlMjBwcm9qZWN0XG4gICAgYFxuICApO1xuXG5leHBvcnQgY29uc3QgYXBwVmFsaWRhdGlvbkZhaWx1cmUgPSAoZXJyb3JMaXN0OiBzdHJpbmcpID0+XG4gIG5ldyBFcnJvcihcbiAgICBgQXBwIGxldmVsIHZhbGlkYXRpb24gZmFpbGVkIHdpdGggdGhlIGZvbGxvd2luZyBlcnJvcnM6XFxuICAke2Vycm9yTGlzdH1cblZhbGlkYXRpb25zIGFsbG93IGZvciBkeW5hbWljIHZlcmlmaWNhdGlvbiBvZiB5b3VyIHByb2plY3QuXG5UbyBza2lwIHZhbGlkYXRpb25zLCBhZGQgJ3NraXBWYWxpZGF0aW9uOiB0cnVlJyB0byB5b3VyIEFwcCBjb25maWdcbiAgICBgXG4gICk7XG5cbmV4cG9ydCBjb25zdCBwcm92aWRlclZlcnNpb25NaXNtYXRjaCA9ICgpID0+XG4gIG5ldyBFcnJvcihcbiAgICBgVmVyc2lvbiBtaXNtYXRjaCBkZXRlY3RlZDogVGhlIHByb3ZpZGVyIGJpbmRpbmdzIHNlZW0gdG8gaGF2ZSBiZWVuIGJ1aWx0IGZvciBhbiBvbGRlciB2ZXJzaW9uIG9mIENES1RGLiBcblVwZ3JhZGUgeW91ciBwcmUtYnVpbHQgcHJvdmlkZXIgb3IgcmUtcnVuIGNka3RmIGdldCB3aXRoIGEgbW9yZSByZWNlbnQgdmVyc2lvbiAoPj0gMC4xMCkgb2YgdGhlIGNka3RmLWNsaS5cbiAgICBgXG4gICk7XG5cbmV4cG9ydCBjb25zdCBhc3NldE91dE9mU2NvcGVPZkNES1RGSnNvbiA9IChpZDogc3RyaW5nLCBjb25maWdQYXRoOiBzdHJpbmcpID0+XG4gIG5ldyBFcnJvcihcbiAgICBgVGVycmFmb3JtQXNzZXQgJHtpZH0gd2FzIGNyZWF0ZWQgd2l0aCBhIHJlbGF0aXZlIHBhdGggJyR7Y29uZmlnUGF0aH0nLCBidXQgbm8gY2RrdGYuanNvbiBmaWxlIHdhcyBmb3VuZCB0byBiYXNlIGl0IG9uLlxuXG5UaGUgY2RrdGYuanNvbiBpcyBuZWVkZWQgdG8gZXN0YWJsaXNoIHRoZSBiYXNlIGZvciB0aGUgcmVsYXRpdmUgcGF0aCAoZS5nIHRoZSAnLicgaW4gJy4vZm9vL2JhcicpLiBXZSBjYW5ub3QgZmluZCB0aGUgY2RrdGYuanNvbiB3aXRoaW4geW91ciBjdXJyZW50IHdvcmtpbmcgZGlyZWN0b3J5ICcke3Byb2Nlc3MuY3dkKCl9J1xuVG8gYXZvaWQgdGhpcywgcGxlYXNlIHBsYWNlIGEgY2RrdGYuanNvbiBhdCB0aGUgcm9vdCBvZiB5b3VyIHByb2plY3QuIExlYXJuIG1vcmUgaGVyZTogaHR0cHM6Ly9kZXZlbG9wZXIuaGFzaGljb3JwLmNvbS90ZXJyYWZvcm0vY2RrdGYvY3JlYXRlLWFuZC1kZXBsb3kvY29uZmlndXJhdGlvbi1maWxlXG5UbyBsZWFybiBtb3JlIGFib3V0IFRlcnJhZm9ybUFzc2V0IHJlYWQgaGVyZTogaHR0cHM6Ly9kZXZlbG9wZXIuaGFzaGljb3JwLmNvbS90ZXJyYWZvcm0vY2RrdGYvY29uY2VwdHMvYXNzZXRzXG5gXG4gICk7XG5cbmV4cG9ydCBjb25zdCBhc3NldEV4cGVjdHNEaXJlY3RvcnkgPSAoaWQ6IHN0cmluZywgY29uZmlnUGF0aDogc3RyaW5nKSA9PlxuICBuZXcgRXJyb3IoXG4gICAgYFRlcnJhZm9ybUFzc2V0ICR7aWR9IGV4cGVjdHMgcGF0aCB0byBiZSBhIGRpcmVjdG9yeSwgYSBmaWxlIHdhcyBwYXNzZWQ6ICcke2NvbmZpZ1BhdGh9J1xuVG8gbGVhcm4gbW9yZSBhYm91dCBUZXJyYWZvcm1Bc3NldCByZWFkIGhlcmU6IGh0dHBzOi8vZGV2ZWxvcGVyLmhhc2hpY29ycC5jb20vdGVycmFmb3JtL2Nka3RmL2NvbmNlcHRzL2Fzc2V0c1xuICAgIGBcbiAgKTtcblxuZXhwb3J0IGNvbnN0IGFzc2V0VHlwZU5vdEltcGxlbWVudGVkID0gKCkgPT5cbiAgbmV3IEVycm9yKGBBc3NldCB0eXBlIGlzIG5vdCBpbXBsZW1lbnRlZFxuUG9zc2libGUgQXNzZXQgdHlwZXMgaW5jbHVkZTogRklMRSwgRElSRUNUT1JZLCBhbmQgQVJDSElWRVxuVGhlIHZhbHVlcyBhcmUgdG8gYmUgdGFrZW4gZnJvbSB0aGUgQXNzZXRUeXBlIEVudW0uXG5UbyBsZWFybiBtb3JlIGFib3V0IFRlcnJhZm9ybUFzc2V0IHJlYWQgaGVyZTogaHR0cHM6Ly9kZXZlbG9wZXIuaGFzaGljb3JwLmNvbS90ZXJyYWZvcm0vY2RrdGYvY29uY2VwdHMvYXNzZXRzXG4gIGApO1xuXG5leHBvcnQgY29uc3QgZHluYW1pY0Jsb2NrTm90U3VwcG9ydGVkID0gKF9mb3JlYWNoRXhwcmVzc2lvbjogc3RyaW5nKSA9PlxuICBuZXcgRXJyb3IoXG4gICAgYFRyaWVkIHRvIGRpcmVjdGx5IHJlc29sdmUgYSBUZXJyYWZvcm1EeW5hbWljQmxvY2sgd2hpY2ggaXMgbm90IHN1cHBvcnRlZC5cblRoZSBUZXJyYWZvcm1EeW5hbWljQmxvY2sgaXMgY3JlYXRlZCBieSBjYWxsaW5nICcuZHluYW1pYycgb24gYSBUZXJyYWZvcm1JdGVyYXRvciBpbnN0YW5jZS5cbkR5bmFtaWMgYmxvY2tzIGFyZSBvbmx5IHN1cHBvcnRlZCBvbiBibG9jayBhdHRyaWJ1dGVzIG9mIHJlc291cmNlcywgZGF0YSBzb3VyY2VzIGFuZCBwcm92aWRlcnMuXG5cblRoZSBleHByZXNzaW9uIHVzZWQgZm9yIHRoZSBkeW5hbWljIGJsb2NrOiAuZHluYW1pYyh7XG4gICR7X2ZvcmVhY2hFeHByZXNzaW9ufVxufSlcbmBcbiAgKTtcblxuZXhwb3J0IGNvbnN0IHVucmVzb2x2ZWRUb2tlbkluQ29uc3RydWN0SWQgPSAoaWQ6IHN0cmluZykgPT5cbiAgbmV3IEVycm9yKFxuICAgIGBZb3UgY2Fubm90IHVzZSBhIFRva2VuIChlLmcuIGEgcmVmZXJlbmNlIHRvIGFuIGF0dHJpYnV0ZSkgYXMgdGhlIGlkIG9mIGEgY29uc3RydWN0LlxuVGhlIGZvbGxvd2luZyBpZCB3YXMgcGFzc2VkOiBcIiR7aWR9XCJcbklkcyBvZiBjb25zdHJ1Y3RzIG11c3QgYmUga25vd24gYXQgc3ludGhlc2lzIHRpbWUgYW5kIHRoZSB2YWx1ZSBvZiB0b2tlbnMgaXMgb25seSBrbm93biB3aGVuIFRlcnJhZm9ybSBydW5zLCBoZW5jZSB5b3UgY2Fubm90IHVzZSB0b2tlbnMgaW4gY29uc3RydWN0IGlkcy5gXG4gICk7XG5cbmV4cG9ydCBjb25zdCBpdGVyYXRvck9uUmVzb3VyY2VXaXRoQ291bnQgPSAoKSA9PlxuICBuZXcgRXJyb3IoXG4gICAgYENhbm5vdCBjcmVhdGUgaXRlcmF0b3IgZnJvbSBhIHJlc291cmNlIHdpdGggYSBjb3VudCBhcmd1bWVudC5cblRoZSByZXNvdXJjZSBwYXNzZWQgdG8gdGhlIGl0ZXJhdG9yIGhhcyBhIGNvdW50IGFyZ3VtZW50IHdoaWNoIGRldGVybWluZXMgaG93IG1hbnkgaW5zdGFuY2VzIG9mIHRoZSByZXNvdXJjZSBhcmUgY3JlYXRlZC5cblBsZWFzZSByZS11c2UgdGhlIHNhbWUgVGVycmFmb3JtQ291bnQgdXNlZCBpbiB0aGlzIHJlc291cmNlIG9uIHRoZSByZXNvdXJjZSB3aGVyZSB5b3UgcGxhbm5lZCB0byB1c2UgdGhpcyBpdGVyYXRvciBpbnN0ZWFkLlxuXG5JZiB5b3UgbmVlZCB0byB1c2UgdGhlIGl0ZXJhdG9yIHRvIHBvcHVsYXRlIGEgbGlzdCBhdHRyaWJ1dGUsIHJlcGxhY2UgdGhlIGNvdW50IG9uIHRoZSByZXNvdXJjZSB3aXRoIGFuIGl0ZXJhdG9yIHBhc3NlZCBpbnRvIHRoZSBmb3JFYWNoIGFyZ3VtZW50LmBcbiAgKTtcblxuZXhwb3J0IGNvbnN0IGl0ZXJhdG9yT25SZXNvdXJjZVdpdGhvdXRGb3JFYWNoID0gKCkgPT5cbiAgbmV3IEVycm9yKGBDYW5ub3QgY3JlYXRlIGFuIGl0ZXJhdG9yIGZyb20gcmVzb3VyY2Ugd2l0aG91dCBhIGZvckVhY2ggYXJndW1lbnQuXG5UaGUgcmVzb3VyY2UgcGFzc2VkIHRvIHRoZSBpdGVyYXRvciBkb2VzIG5vdCBoYXZlIGEgZm9yRWFjaCBhcmd1bWVudCwgbWVhbmluZyBvbmx5IGEgc2luZ2xlIGluc3RhbmNlIG9mIGl0IHdpbGwgYmUgY3JlYXRlZC5cbklmIHlvdSB3YW50IHRvIGNyZWF0ZSBtb3JlIGluc3RhbmNlcyBvZiB0aGlzIHJlc291cmNlIHBhc3MgYW4gaXRlcmF0b3IgdG8gdGhlIGZvckVhY2ggYXJndW1lbnQgb2YgdGhlIHJlc291cmNlIGZpcnN0LlxuICBgKTtcblxuZXhwb3J0IGNvbnN0IG1vZHVsZXNXaXRoU2FtZUFsaWFzID0gKGFsaWFzOiBzdHJpbmcpID0+XG4gIG5ldyBFcnJvcihgRXJyb3I6IE11bHRpcGxlIHByb3ZpZGVycyBoYXZlIHRoZSBzYW1lIGFsaWFzOiBcIiR7YWxpYXN9XCJcbldoZW4gcGFzc2luZyBtdWx0aXBsZSBwcm92aWRlcnMgb2YgdGhlIHNhbWUgdHlwZSB0byBtb2R1bGVzLCBlYWNoIHByb3ZpZGVyIG11c3QgaGF2ZSBhIHVuaXF1ZSBhbGlhcy5cbiAgYCk7XG5cbmV4cG9ydCBjb25zdCBtb3ZlVGFyZ2V0QWxyZWFkeVNldCA9IChcbiAgdGFyZ2V0OiBzdHJpbmcsXG4gIGZyaWVuZGx5VW5pcXVlSWQ6IHN0cmluZyB8IHVuZGVmaW5lZFxuKSA9PlxuICBuZXcgRXJyb3IoYFRhcmdldCBcIiR7dGFyZ2V0fVwiIGhhcyBhbHJlYWR5IGJlZW4gdXNlZCBmb3IgdGhlIGNvbnN0cnVjdCBhdCAke2ZyaWVuZGx5VW5pcXVlSWR9LlxuVGFyZ2V0IG11c3QgYmUgYSBzdHJpbmcgdGhhdCBpcyB1bmlxdWUgYWNyb3NzIGFsbCByZXNvdXJjZXMgaW4gdGhlIHNhbWUgc3RhY2suYCk7XG5cbmV4cG9ydCBjb25zdCBtb3ZlVGFyZ2V0Tm90U2V0ID0gKHRhcmdldDogc3RyaW5nLCBlbnRyaWVzOiBzdHJpbmcpID0+XG4gIG5ldyBFcnJvcihgVGFyZ2V0IFwiJHt0YXJnZXR9XCIgaGFzIG5vdCBiZWVuIHNldC5cbllvdSB0cmllZCB0byBtb3ZlIGEgcmVzb3VyY2UgdG8gYSB0YXJnZXQgdGhhdCBoYXMgbm90IGJlZW4gc2V0IG9uIGFueSByZXNvdXJjZS5cbkNhbGwgLmFkZE1vdmVUYXJnZXQoXCIke3RhcmdldH1cIikgb24gdGhlIGluc3RhbmNlIG9mIHRoZSByZXNvdXJjZSB5b3Ugd2FudCB0byBtb3ZlIHRoaXMgb25lIHRvLlxuXG5BbHRlcm5hdGl2ZWx5IHlvdSBjYW4gdXNlIG9uZSBvZiB0aGUgZm9sbG93aW5nIHRhcmdldHMgKGluIGNhc2UgeW91IGhhZCBhIHR5cG8pOlxuJHtlbnRyaWVzfVxuYCk7XG5cbmV4cG9ydCBjb25zdCBtb3ZlZFRvUmVzb3VyY2VPZkRpZmZlcmVudFR5cGUgPSAoXG4gIG1vdmVUYXJnZXQ6IHN0cmluZyxcbiAgb3JpZ2luYWxSZXNvdXJjZVR5cGU6IHN0cmluZyxcbiAgZGVzdGluYXRpb25SZXNvdXJjZVR5cGU6IHN0cmluZ1xuKSA9PlxuICBuZXcgRXJyb3IoYFlvdSBoYXZlIHRyaWVkIHRvIG1vdmUgYSByZXNvdXJjZSB0byBhIGRpZmZlcmVudCB0eXBlIHdoaWNoIGlzIG5vdCBzdXBwb3J0ZWQuXG5cblRoZSBtb3ZlIHRhcmdldCBcIiR7bW92ZVRhcmdldH1cIiBjb3JyZXNwb25kaW5nIHRvIHRoZSByZXNvdXJjZSBvZiB0eXBlICR7ZGVzdGluYXRpb25SZXNvdXJjZVR5cGV9IHRvIG1vdmUgdG8gZGlmZmVycyBmcm9tIHRoZSByZXNvdXJjZSBvZiB0eXBlICR7b3JpZ2luYWxSZXNvdXJjZVR5cGV9IGJlaW5nIG1vdmVkIGZyb20uXG5cbklmIHRoaXMgd2FzIGludGVudGlvbmFsLCB5b3UgY2FuIGluc3RlYWQgdHJ5IGltcG9ydGluZyB0aGUgZXhpc3RpbmcgcmVzb3VyY2UgaW50byB5b3VyIHRhcmdldCBhcyBkZXNjcmliZWQgaW4gdGhlIGltcG9ydCBkb2NzOlxuaHR0cHM6Ly9kZXZlbG9wZXIuaGFzaGljb3JwLmNvbS90ZXJyYWZvcm0vY2RrdGYvY29uY2VwdHMvcmVzb3VyY2VzI2ltcG9ydGluZy1yZXNvdXJjZXNcblxuUGxlYXNlIG5vdGUsIHRoYXQgeW91IHdpbGwgbWFudWFsbHkgbmVlZCB0byByZW1vdmUgdGhlIG9yaWdpbmFsIHJlc291cmNlIGZyb20geW91ciBzdGF0ZSBmaWxlIGFmdGVyIGltcG9ydGluZyBpdCwgdXNpbmcgdGhlIFwidGVycmFmb3JtIHN0YXRlIHJtXCIgY29tbWFuZCBpbiB0aGUgb3V0cHV0IGRpcmVjdG9yeSBvZiB0aGUgc3RhY2sgdGhpcyByZXNvdXJjZSBpcyBkZWZpbmVkIGluLiBSZWFkIG1vcmUgYWJvdXQgdGhlIGNvbW1hbmQgaGVyZTpcbmh0dHBzOi8vZGV2ZWxvcGVyLmhhc2hpY29ycC5jb20vdGVycmFmb3JtL2NsaS9jb21tYW5kcy9zdGF0ZS9ybVxuYCk7XG5cbmV4cG9ydCBjb25zdCByZXNvdXJjZUdpdmVuVHdvTW92ZU9wZXJhdGlvbnNCeVRhcmdldEFuZElkID0gKFxuICBpZDogc3RyaW5nLFxuICBleGlzdGluZ1RhcmdldDogc3RyaW5nLFxuICBuZXdNb3ZlOiB7IHRvOiBzdHJpbmc7IGZyb206IHN0cmluZyB9XG4pID0+XG4gIG5ldyBFcnJvcihgXG4ke2lkfSBoYXMgYmVlbiBnaXZlbiB0d28gc2VwYXJhdGUgbW92ZWQgb3BlcmF0aW9ucy5cblxuTW92ZSB0YXJnZXQ6IFwiJHtleGlzdGluZ1RhcmdldH1cIlxuTW92ZSBieSBpZDoge1xuICBmcm9tOiAke25ld01vdmUuZnJvbX1cbiAgdG86ICR7bmV3TW92ZS50b31cbn1cblxuT25seSBvbmUgbW92ZSBvcGVyYXRpb24gY2FuIG9jY3VyIHBlciBwbGFuL2FwcGx5LiBSZW1vdmUgb25lIG9mIHRoZSBvcGVyYXRpb25zLlxuXG5UbyBsZWFybiBtb3JlIGFib3V0IG1vdmluZyByZXNvdXJjZXMgc2VlOiBodHRwczovL2RldmVsb3Blci5oYXNoaWNvcnAuY29tL3RlcnJhZm9ybS9jZGt0Zi9leGFtcGxlcy1hbmQtZ3VpZGVzL3JlZmFjdG9yaW5nIzp+OnRleHQ9TW92aW5nJTIwJTI2JTIwUmVuYW1pbmclMjBSZXNvdXJjZXMlMjBXaXRoaW4lMjBhJTIwU3RhY2tcbmApO1xuXG5leHBvcnQgY29uc3QgcmVzb3VyY2VHaXZlblR3b01vdmVPcGVyYXRpb25zQnlJZCA9IChcbiAgaWQ6IHN0cmluZyxcbiAgZXhpc3RpbmdNb3ZlOiB7IHRvOiBzdHJpbmc7IGZyb206IHN0cmluZyB9LFxuICBuZXdNb3ZlOiB7IHRvOiBzdHJpbmc7IGZyb206IHN0cmluZyB9XG4pID0+XG4gIG5ldyBFcnJvcihgXG4ke2lkfSBoYXMgYmVlbiBnaXZlbiB0d28gc2VwYXJhdGUgbW92ZWQgb3BlcmF0aW9ucy5cblxue1xuICBmcm9tOiAke2V4aXN0aW5nTW92ZS5mcm9tfVxuICB0bzogJHtleGlzdGluZ01vdmUudG99XG59XG57XG4gIGZyb206ICR7bmV3TW92ZS5mcm9tfVxuICB0bzogJHtuZXdNb3ZlLnRvfSAoUmVzb3VyY2UgY2FsbGluZyB0aGUgbW92ZSB0byBvcGVyYXRpb24pXG59XG5cbk9ubHkgb25lIG1vdmUgb3BlcmF0aW9uIGNhbiBvY2N1ciBwZXIgcGxhbi9hcHBseS4gUmVtb3ZlIG9uZSBvZiB0aGUgb3BlcmF0aW9ucy5cblxuVG8gbGVhcm4gbW9yZSBhYm91dCBtb3ZpbmcgcmVzb3VyY2VzIHNlZTogaHR0cHM6Ly9kZXZlbG9wZXIuaGFzaGljb3JwLmNvbS90ZXJyYWZvcm0vY2RrdGYvZXhhbXBsZXMtYW5kLWd1aWRlcy9yZWZhY3RvcmluZyM6fjp0ZXh0PU1vdmluZyUyMCUyNiUyMFJlbmFtaW5nJTIwUmVzb3VyY2VzJTIwV2l0aGluJTIwYSUyMFN0YWNrXG5gKTtcblxuZXhwb3J0IGNvbnN0IHJlc291cmNlR2l2ZW5Ud29Nb3ZlT3BlcmF0aW9uc0J5VGFyZ2V0ID0gKFxuICByZXNvdXJjZUlkOiBzdHJpbmcsXG4gIGV4aXN0aW5nTW92ZVRhcmdldDogc3RyaW5nLFxuICBuZXdNb3ZlVGFyZ2V0OiBzdHJpbmdcbikgPT5cbiAgbmV3IEVycm9yKGBUaGUgcmVzb3VyY2UgJHtyZXNvdXJjZUlkfSBoYXMgYmVlbiBnaXZlbiB0d28gbW92ZVRhcmdldHM6IFwiJHtuZXdNb3ZlVGFyZ2V0fVwiIGFuZCBcIiR7ZXhpc3RpbmdNb3ZlVGFyZ2V0fVwiXG5cbkEgcmVzb3VyY2UgY2FuIG9ubHkgYmUgbW92ZWQgb25jZSBwZXIgcGxhbi9hcHBseVxuXG5UbyBsZWFybiBtb3JlIGFib3V0IG1vdmluZyByZXNvdXJjZXMgc2VlOiBodHRwczovL2RldmVsb3Blci5oYXNoaWNvcnAuY29tL3RlcnJhZm9ybS9jZGt0Zi9leGFtcGxlcy1hbmQtZ3VpZGVzL3JlZmFjdG9yaW5nIzp+OnRleHQ9TW92aW5nJTIwJTI2JTIwUmVuYW1pbmclMjBSZXNvdXJjZXMlMjBXaXRoaW4lMjBhJTIwU3RhY2tcbmApO1xuXG5leHBvcnQgY29uc3Qgc3RhY2tDb250YWluc0Rpc2FsbG93ZWRDaGFyID0gKFxuICBzdGFja0lkOiBzdHJpbmcsXG4gIGludmFsaWRDaGFyOiBzdHJpbmdcbikgPT5cbiAgbmV3IEVycm9yKGBDYW4gbm90IGNyZWF0ZSBUZXJyYWZvcm0gc3RhY2sgd2l0aCBpZCBcIiR7c3RhY2tJZH1cIi4gSXQgY29udGFpbnMgYSBnbG9iIGNoYXJhY3RlcjogXCIke2ludmFsaWRDaGFyfVwiXG5cbkdsb2IgY2hhcmFjdGVycyBhcmUgZGlzYWxsb3dlZCBpbiBzdGFjayBuYW1lcyBkdWUgdG8gdGhlaXIgdXNlIGluIGRlcGxveWluZy9kZXN0cm95aW5nIG11bHRpcGxlIHN0YWNrcyBcblxuU3VjaCBhcyAnY2RrdGYgZGVwbG95IFxcYCotcHJvZHVjdGlvblxcYCcgd2hpY2ggZGVwbG95cyBhbGwgc3RhY2tzIHdpdGggbmFtZXMgdGhhdCBlbmQgaW4gJy1wcm9kdWN0aW9uJ1xuYCk7XG5cbmV4cG9ydCBjb25zdCBzdGFja0lkQ29udGFpbnNXaGl0ZXNwYWNlID0gKHN0YWNrSWQ6IHN0cmluZykgPT5cbiAgbmV3IEVycm9yKGBDYW4gbm90IGNyZWF0ZSBUZXJyYWZvcm1TdGFjayB3aXRoIGlkIFwiJHtzdGFja0lkfVwiLiBJdCBjb250YWlucyBhIHdoaXRlc3BhY2UgY2hhcmFjdGVyLlxuXG5QbGVhc2UgcmVtb3ZlIGFueSB3aGl0ZXNwYWNlIGNoYXJhY3RlcnMgaW4geW91ciBUZXJyYWZvcm1TdGFjayBpZCBsaWtlIHNvOiBcIiR7c3RhY2tJZC5yZXBsYWNlKFxuICAgIC9cXHMvZyxcbiAgICBcIlwiXG4gICl9XCJcbmApO1xuXG5leHBvcnQgY29uc3Qgbm9TdGFja0ZvckNvbnN0cnVjdCA9IChjb25zdHJ1Y3RQYXRoOiBzdHJpbmcsIGhpbnQ6IHN0cmluZykgPT5cbiAgbmV3IEVycm9yKGBObyBzdGFjayBjb3VsZCBiZSBpZGVudGlmaWVkIGZvciB0aGUgY29uc3RydWN0IGF0IHBhdGggJyR7Y29uc3RydWN0UGF0aH0nJHtoaW50fVxuXG5Db25zdHJ1Y3RzIGNhbiBvbmx5IGJlIHVzZWQgYXMgYSBwYXJ0IG9mIGEgVGVycmFmb3JtU3RhY2suIFdoaWxlIENvbnN0cnVjdHMgcmVwcmVzZW50IGEgY29sbGVjdGlvbiBvZiBpbmZyYXN0cnVjdHVyZSwgdGhleSBtdXN0IGJlIHVzZWQgd2l0aGluIGEgVGVycmFmb3JtU3RhY2sgdG8gYmUgYXBhcnQgb2YgYSBkZWRpY2F0aW9uIFRlcnJhZm9ybSBjb25maWd1cmF0aW9uLlxuXG5UbyBsZWFybiBtb3JlIGFib3V0IENvbnN0cnVjdHMgdnMuIFRlcnJhZm9ybVN0YWNrcyBzZWUgaGVyZTogaHR0cHM6Ly9kZXZlbG9wZXIuaGFzaGljb3JwLmNvbS90ZXJyYWZvcm0vY2RrdGYvY29uY2VwdHMvY29uc3RydWN0cyM6fjp0ZXh0PUNvbnN0cnVjdHMlMjB2cy4lMjBTdGFja3NcbmApO1xuXG5leHBvcnQgY29uc3Qgc3RhY2tIYXNDaXJjdWxhckRlcGVuZGVuY3kgPSAoXG4gIHRoaXNTdGFjazogVGVycmFmb3JtU3RhY2ssXG4gIGRlcGVuZGVuY3k6IFRlcnJhZm9ybVN0YWNrXG4pID0+XG4gIG5ldyBFcnJvcihgQ2FuIG5vdCBhZGQgZGVwZW5kZW5jeSAke2RlcGVuZGVuY3l9IHRvICR7dGhpc1N0YWNrfSBzaW5jZSBpdCB3b3VsZCByZXN1bHQgaW4gYSBsb29wXG5cblRoaXMgaXMgY2F1c2VkIGJ5IHRoZSBUZXJyYWZvcm1TdGFjayAke2RlcGVuZGVuY3l9IGFscmVhZHkgYmVpbmcgZGVwZW5kZW50IG9uICR7dGhpc1N0YWNrfSBkaXJlY3RseSwgb3IgZGVwZW5kZW50IG9uIGEgVGVycmFmb3JtU3RhY2sgd2l0aGluICR7dGhpc1N0YWNrfVxuICBcblRvIGxlYXJuIG1vcmUgYWJvdXQgY3Jvc3Mtc3RhY2sgcmVmZXJlbmNlcyBzZWUgaGVyZTogaHR0cHM6Ly9kZXZlbG9wZXIuaGFzaGljb3JwLmNvbS90ZXJyYWZvcm0vY2RrdGYvY29uY2VwdHMvc3RhY2tzIzp+OnRleHQ9Q3Jvc3MlMkRTdGFjayUyMFJlZmVyZW5jZXNcbmApO1xuXG5leHBvcnQgY29uc3Qgc3RhY2tWYWxpZGF0aW9uRmFpbHVyZSA9IChlcnJvckxpc3Q6IHN0cmluZykgPT5cbiAgbmV3IEVycm9yKGBWYWxpZGF0aW9uIGZhaWxlZCB3aXRoIHRoZSBmb2xsb3dpbmcgZXJyb3JzOlxcbiAgJHtlcnJvckxpc3R9XG4gIFxuSWYgeW91IHdpc2ggdG8gaWdub3JlIHRoZXNlIHZhbGlkYXRpb25zLCBwYXNzICdza2lwVmFsaWRhdGlvbjogdHJ1ZScgdG8geW91ciBBcHAgY29uZmlnXG5gKTtcblxuZXhwb3J0IGNvbnN0IG1hdGNoZXJzUGF0aElzTm90RGlyZWN0b3J5ID0gKGZ1bmN0aW9uTmFtZTogc3RyaW5nKSA9PlxuICBuZXcgRXJyb3IoYFBhdGggaXMgbm90IGEgZGlyZWN0b3J5XG5cbkVuc3VyZSB5b3UgYXJlIHBhc3NpbmcgdGhlIHJlc3VsdCBvZiBUZXN0aW5nLmZ1bGxTeW50aCgnc3RhY2sgaW5zdGFuY2UnKSBhbmQgbm90IFRlc3Rpbmcuc3ludGgoJ3N0YWNrIGluc3RhbmNlJykgaW4geW91ciB1c2FnZSBvZiAnJHtmdW5jdGlvbk5hbWV9Jy4gXG5cblRlc3RpbmcuZnVsbFN5bnRoIHJldHVybnMgYSBmaWxlIHBhdGggdG8gdGVtcG9yYXJ5IHRlc3RpbmcgZW52aXJvbm1lbnQuIFRoaXMgZmlsZSBwYXRoIGlzIHVzZWQgaW4gQ0RLVEYgdGVzdHMgdGhhdCBlbnN1cmUgeW91ciBUZXJyYWZvcm1TdGFjayBwcm9kdWNlcyBhIHZhbGlkYXRlIFRlcnJhZm9ybSBjb25maWd1cmF0aW9uICh0b0JlVmFsaWRUZXJyYWZvcm0gJiB0b1BsYW5TdWNjZXNzZnVsbHkpLlxuTGlrZSBzbzogXCJUZXN0aW5nLnRvQmVWYWxpZGF0ZVRlcnJhZm9ybShUZXN0aW5nLmZ1bGxTeW50aCgnVGVycmFmb3JtU3RhY2sgaW5zdGFuY2UnKSlcIlxuXG5UZXN0aW5nLnN5bnRoIHJldHVybnMgdGhlIEpTT04gcmVwcmVzZW50YXRpb24gb2YgeW91ciBzdGFjay4gVGhpcyBKU09OIGNhbiB0aGVuIGJlIHVzZWQgaW4gQ0RLVEYgYXNzZXJ0aW9ucyB0aGF0IGNoZWNrIHRoZSBjb21wb3NpdGlvbiBvZiB5b3VyIHN0YWNrcyAodG9IYXZlUmVzb3VyY2UsIHRvSGF2ZURhdGFTb3VyY2UsIGVjdC4pXG5MaWtlIHNvOiBcIlRlc3RpbmcudG9IYXZlUmVzb3VyY2UoVGVzdGluZy5zeW50aCgnVGVycmFmb3JtU3RhY2sgaW5zdGFuY2UnKSwgUzNCdWNrZXQpXCJcblxuVG8gbGVhcm4gbW9yZSBhYm91dCB0ZXN0aW5nIGluIENES1RGIHNlZTogaHR0cHM6Ly9kZXZlbG9wZXIuaGFzaGljb3JwLmNvbS90ZXJyYWZvcm0vY2RrdGYvdGVzdC91bml0LXRlc3RzYCk7XG5cbmV4cG9ydCBjb25zdCBtYXRjaGVyc0ZvdW5kRXJyb3JzSW5TdGFjayA9IChcbiAgZXJyb3JDb3VudDogYW55LFxuICBzdGFja05hbWU6IHN0cmluZyxcbiAgZGlhZ25vc3RpY3M6IHN0cmluZ1xuKSA9PlxuICBuZXcgRXJyb3IoYEZvdW5kICR7ZXJyb3JDb3VudH0gRXJyb3JzIGluIHN0YWNrICR7c3RhY2tOYW1lfTogJHtkaWFnbm9zdGljc31cbiAgXG5UaGVzZSBlcnJvcnMgYXJlIG5vdCBmYWlsdXJlcyBvZiB5b3VyIHRlc3RzLCBidXQgaXNzdWVzIHdpdGggdGhlIHVuZGVybHlpbmcgVGVycmFmb3JtU3RhY2sgYmVpbmcgdGVzdGVkLiBGaXggdGhlIGFib3ZlIGlzc3VlcyBiZWZvcmUgcnVubmluZyB0ZXN0cyBhZ2Fpbi5cbmApO1xuXG5leHBvcnQgY29uc3QgamVzdE5vdEluc3RhbnRpYXRlZCA9ICgpID0+XG4gIG5ldyBFcnJvcihgZXhwZWN0IGlzIG5vdCBkZWZpbmVkLCBqZXN0IHdhcyBub3QgcHJvcGVybHkgaW5zdGFudGlhdGVkXG4gIFxuRW5zdXJlIHlvdSBoYXZlIGEgJ3NldHVwLmpzJyBmaWxlIGluIHlvdXIgcHJvamVjdCdzIGRpcmVjdG9yeSB0aGF0IGNhbGxzICdjZGt0Zi5UZXN0aW5nLnNldHVwSmVzdCgpJ1xuXG5UbyBsZWFybiBtb3JlIGFib3V0IHNldHRpbmcgdXAgdGVzdGluZyBzZWU6IGh0dHBzOi8vZGV2ZWxvcGVyLmhhc2hpY29ycC5jb20vdGVycmFmb3JtL2Nka3RmL3Rlc3QvdW5pdC10ZXN0cyM6fjp0ZXh0PUFkZCUyMFRlc3RpbmclMjB0byUyMFlvdXIlMjBBcHBsaWNhdGlvblxuYCk7XG5cbmV4cG9ydCBjb25zdCBleHBlY3ROb3RHbG9iYWxseUFjY2Vzc2libGUgPSAoKSA9PlxuICBuZXcgRXJyb3IoYHNldHVwSmVzdCBjYWxsZWQsIGJ1dCBleHBlY3QgaXMgbm90IGdsb2JhbGx5IGFjY2Vzc2libGVcblxuVG8gbGVhcm4gbW9yZSBhYm91dCBzZXR0aW5nIHVwIHRlc3Rpbmcgc2VlOiBodHRwczovL2RldmVsb3Blci5oYXNoaWNvcnAuY29tL3RlcnJhZm9ybS9jZGt0Zi90ZXN0L3VuaXQtdGVzdHMjOn46dGV4dD1BZGQlMjBUZXN0aW5nJTIwdG8lMjBZb3VyJTIwQXBwbGljYXRpb25cbmApO1xuXG5leHBvcnQgY29uc3QgaW52YWxpZFN0YWNrID0gKHN0YWNrQ29udGVudDogc3RyaW5nKSA9PlxuICBuZXcgRXJyb3IoYGludmFsaWQgSlNPTiBzdHJpbmcgcGFzc2VkOiAke3N0YWNrQ29udGVudH1cblxuRW5zdXJlIHlvdSBhcmUgcGFzc2luZyB0aGUgcmVzdWx0IG9mIFRlc3Rpbmcuc3ludGgoJ3N0YWNrIGluc3RhbmNlJykgYW5kIG5vdCBUZXN0aW5nLmZ1bGxTeW50aCgnc3RhY2sgaW5zdGFuY2UnKS4gXG5cblRlc3Rpbmcuc3ludGggcmV0dXJucyB0aGUgSlNPTiByZXByZXNlbnRhdGlvbiBvZiB5b3VyIHN0YWNrLiBUaGlzIEpTT04gY2FuIHRoZW4gYmUgdXNlZCBpbiBDREtURiBhc3NlcnRpb25zIHRoYXQgY2hlY2sgdGhlIGNvbXBvc2l0aW9uIG9mIHlvdXIgc3RhY2tzICh0b0hhdmVSZXNvdXJjZSwgdG9IYXZlRGF0YVNvdXJjZSwgZWN0Lilcbkxpa2Ugc286IFwiVGVzdGluZy50b0hhdmVSZXNvdXJjZShUZXN0aW5nLnN5bnRoKCdUZXJyYWZvcm1TdGFjayBpbnN0YW5jZScpLCBTM0J1Y2tldClcIlxuXG5UZXN0aW5nLmZ1bGxTeW50aCByZXR1cm5zIGEgZmlsZSBwYXRoIHRvIHRlbXBvcmFyeSB0ZXN0aW5nIGVudmlyb25tZW50LiBUaGlzIGZpbGUgcGF0aCBpcyB1c2VkIGluIENES1RGIHRlc3RzIHRoYXQgZW5zdXJlIHlvdXIgVGVycmFmb3JtU3RhY2sgcHJvZHVjZXMgYSB2YWxpZGF0ZSBUZXJyYWZvcm0gY29uZmlndXJhdGlvbiAodG9CZVZhbGlkVGVycmFmb3JtICYgdG9QbGFuU3VjY2Vzc2Z1bGx5KS5cbkxpa2Ugc286IFwiVGVzdGluZy50b0JlVmFsaWRhdGVUZXJyYWZvcm0oVGVzdGluZy5mdWxsU3ludGgoJ1RlcnJhZm9ybVN0YWNrIGluc3RhbmNlJykpXCJcblxuVG8gbGVhcm4gbW9yZSBhYm91dCB0ZXN0aW5nIGluIENES1RGIHNlZTogaHR0cHM6Ly9kZXZlbG9wZXIuaGFzaGljb3JwLmNvbS90ZXJyYWZvcm0vY2RrdGYvdGVzdC91bml0LXRlc3RzYCk7XG5cbmV4cG9ydCBjb25zdCB0YXJnZXROb3RSZXNvbHZhYmxlV2l0aE92ZXJyaWRlcyA9ICh0YXJnZXQ6IHN0cmluZykgPT5cbiAgbmV3IEVycm9yKGBJbnZhbGlkIHVzYWdlLiBUYXJnZXQgKCR7dGFyZ2V0fSkgY2FuIG5vdCBiZSBhIHJlc29sdmFibGUgdG9rZW4gd2hlbiBvdmVycmlkZXMgYXJlIHNwZWNpZmllZC4gUGxlYXNlIHJlcGxhY2UgdGhlIHZhbHVlIG9mIHRoZSBmaWVsZCB5b3UgYXJlIG92ZXJyaWRpbmcgd2l0aCBhIHN0YXRpYyB2YWx1ZS5cblxuQmVjYXVzZSB0aGUgdGFyZ2V0IGlzIGEgcmVzb2x2YWJsZSBUb2tlbiBhbnkgb3ZlcnJpZGVzIGNhbm5vdCBiZSBhcHBsaWVkIGFzIGl0IGhhcyBub3QgeWV0IGJlZW4gcmVzb2x2ZWQuIFxuXG5UbyBsZWFybiBtb3JlIGFib3V0IFRva2VucyBzZWUgaGVyZTogaHR0cHM6Ly9kZXZlbG9wZXIuaGFzaGljb3JwLmNvbS90ZXJyYWZvcm0vY2RrdGYvY29uY2VwdHMvdG9rZW5zXG5gKTtcblxuZXhwb3J0IGNvbnN0IHNvdXJjZU9yVGFyZ2V0Tm90QW5PYmplY3QgPSAoXG4gIHNvdXJjZTogc3RyaW5nLFxuICBzb3VyY2VUeXBlOiBzdHJpbmcsXG4gIHRhcmdldDogc3RyaW5nLFxuICB0YXJnZXRUeXBlOiBzdHJpbmdcbikgPT5cbiAgbmV3IEVycm9yKGBBbiBpc3N1ZSB3YXMgZW5jb3VudGVyZWQgZHVyaW5nIHRoZSBzeW50aGVzaXphdGlvbiBvZiB5b3VyIFRlcnJhZm9ybSBjb25maWd1cmF0aW9uLiBcbiAgXG5Cb3RoIHRoZSBzb3VyY2UgZWxlbWVudCAoJHtzb3VyY2V9KSBhbmQgYW5kIGl0cyBjb250YWluaW5nIHRhcmdldCBlbGVtZW50ICgke3RhcmdldH0pIG11c3QgYmUgb2JqZWN0c1xuXG5UeXBlIG9mIHNvdXJjZTogJHtzb3VyY2VUeXBlfVxuVHlwZSBvZiB0YXJnZXQ6ICR7dGFyZ2V0VHlwZX1cbmApO1xuXG5leHBvcnQgY29uc3QgY29uc3RydWN0RGVwZW5kZW5jeUJlbG93VjEwID0gKCkgPT5cbiAgbmV3IEVycm9yKGBWZXJzaW9uIG1pc21hdGNoISBUaGUgY29uc3RydWN0cyBkZXBlbmRlbmN5IGFwcGVhcnMgdG8gYmUgbG93ZXIgdGhhbiB2MTAgd2hpY2ggaXMgcmVxdWlyZWQgYXMgb2YgY2RrdGYgdmVyc2lvbiAwLjYuXG5Zb3VyIGN1cnJlbnQgY29uc3RydWN0cyB2ZXJzaW9uIGlzIG1pc3NpbmcgQ29uc3RydWN0Lm5vZGUgd2hpY2ggd2FzIGFkZGVkIGluIHYxMC5cblBsZWFzZSB1cGRhdGUgeW91ciBjb25zdHJ1Y3RzIGRlcGVuZGVuY3k6IGh0dHBzOi8vY2RrLnRmL3VwZ3JhZGUtY29uc3RydWN0cy12MTBcbmApO1xuXG5leHBvcnQgY29uc3QgY2xvdWRCYWNrZW5kV29ya3NwYWNlSXNOb3REZWZpbmVkQnlOYW1lID0gKCkgPT5cbiAgbmV3IEVycm9yKGBUaGUgQ2xvdWQgYmFja2VuZCBvbmx5IHN1cHBvcnRzIGNyb3NzLXN0YWNrIHJlZmVyZW5jZXMgd2hlbiB0aGUgd29ya3NwYWNlIGlzIGRlZmluZWQgYnkgbmFtZSBpbnN0ZWFkIG9mIGJ5IHRhZ3MuXG5cblRvIHByb3Blcmx5IHV0aWxpemUgY3Jvc3Mtc3RhY2sgcmVmZXJlbmNlcywgcmVwbGFjZSB5b3VyIHVzYWdlIG9mICdUYWdnZWRDbG91ZFdvcmtzcGFjZXMnIHRvICdOYW1lZENsb3VkV29ya3NwYWNlJyBsaWtlIHNvOlxuXG5uZXcgQ2xvdWRCYWNrZW5kKHN0YWNrLCB7XG4gIC4uLlxuICB3b3Jrc3BhY2VzOiBuZXcgTmFtZWRDbG91ZFdvcmtzcGFjZShcIm15LWFwcFwiKSxcbn0pO1xuXG5UbyBsZWFybiBtb3JlIGFib3V0IFJlbW90ZSBCYWNrZW5kcyBzZWU6IGh0dHBzOi8vZGV2ZWxvcGVyLmhhc2hpY29ycC5jb20vdGVycmFmb3JtL2Nka3RmL2NvbmNlcHRzL3JlbW90ZS1iYWNrZW5kc1xuYCk7XG5cbmV4cG9ydCBjb25zdCB2YWx1ZUNvbnRhaW5zVW5lc2NhcGVkUXVvdGVzID0gKHZhbHVlOiBzdHJpbmcpID0+XG4gIG5ldyBFcnJvcihcbiAgICBgJyR7dmFsdWV9JyBjYW4gbm90IGJlIHVzZWQgYXMgdmFsdWUgZGlyZWN0bHkgc2luY2UgaXQgaGFzIHVuZXNjYXBlZCBkb3VibGUgcXVvdGVzIGluIGl0LlxuXG5UbyBzYWZlbHkgdXNlIHRoZSB2YWx1ZSwgdXNlIEZuLnJhd1N0cmluZyBvbiB5b3VyIHN0cmluZyBsaWtlIHNvOlxuXG5Gbi5yYXdTdHJpbmcoJyR7dmFsdWV9JylcblxuVGhpcyBpcyBuZWVkZWQgYXMgQ0RLVEYgb3IgVGVycmFmb3JtIHdpbGwgb3RoZXJ3aXNlIHRyeSB0byBpbnRlcnByZXQgdGhlc2UgZG91YmxlIHF1b3RlcyBpbmNvcnJlY3RseS5cblxuVG8gbGVhcm4gbW9yZSBhYm91dCBidWlsdCBpbiBUZXJyYWZvcm0gZnVuY3Rpb25zIHdpdGhpbiBDREtURiBzZWU6IGh0dHBzOi8vZGV2ZWxvcGVyLmhhc2hpY29ycC5jb20vdGVycmFmb3JtL2Nka3RmL2NvbmNlcHRzL2Z1bmN0aW9uc1xuYFxuICApO1xuXG5leHBvcnQgY29uc3QgZW5jb3VudGVyZWRBbm5vdGF0aW9uV2l0aExldmVsRXJyb3IgPSAoZXJyb3JzOiBzdHJpbmcpID0+XG4gIG5ldyBFcnJvcihgRW5jb3VudGVyZWQgQW5ub3RhdGlvbnMgd2l0aCBsZXZlbCBcIkVSUk9SXCI6XFxuJHtlcnJvcnN9XG4gIFxuRWl0aGVyIGZpeCB0aGUgaXNzdWVzIGFib3ZlLCBvciBzZXQgdGhlIGVudmlyb25tZW50IHZhcmlhYmxlIENES1RGX0NPTlRJTlVFX1NZTlRIX09OX0VSUk9SX0FOTk9UQVRJT05TIHRvIGlnbm9yZSB0aGVzZSBhbm5vdGF0aW9uc1xuYCk7XG5cbmV4cG9ydCBjb25zdCB2YWx1ZUlzSW52YWxpZFN0cmluZ09yVG9rZW4gPSAodmFsdWU6IHN0cmluZykgPT5cbiAgbmV3IEVycm9yKFxuICAgIGAnJHt2YWx1ZX0nIGlzIG5vdCBhIHZhbGlkIHN0cmluZyBub3IgYSB0b2tlbiwgVGhpcyBmdW5jdGlvbiBvbmx5IGFjY2VwdHMgc3RyaW5ncyBvciB0b2tlbnMgcmVzb2x2aW5nIHRvIHN0cmluZ3MsIHBsZWFzZSBjaGFuZ2UgeW91ciBjb2RlIGFjY29yZGluZ2x5LmBcbiAgKTtcblxuZXhwb3J0IGNvbnN0IHZhbHVlSXNJbnZhbGlkTnVtYmVyT3JUb2tlbiA9ICh2YWx1ZTogc3RyaW5nKSA9PlxuICBuZXcgRXJyb3IoXG4gICAgYCR7dmFsdWV9IGlzIG5vdCBhIHZhbGlkIG51bWJlciBub3IgYSB0b2tlbi4gVGhpcyBmdW5jdGlvbiBvbmx5IGFjY2VwdHMgbnVtYmVycyBvciB0b2tlbnMgcmVzb2x2aW5nIHRvIG51bWJlcnMsIHBsZWFzZSBjaGFuZ2UgeW91ciBjb2RlIGFjY29yZGluZ2x5LmBcbiAgKTtcblxuZXhwb3J0IGNvbnN0IGxpc3RFbGVtZW50SXNPZldyb25nVHlwZSA9IChcbiAgdmFsdWU6IGFueVtdLFxuICBwb3NpdGlvbjogbnVtYmVyLFxuICBlcnJvcjogdW5rbm93blxuKSA9PlxuICBuZXcgRXJyb3IoXG4gICAgYEVsZW1lbnQgaW4gbGlzdCAke3ZhbHVlfSBhdCBwb3NpdGlvbiAke3Bvc2l0aW9ufSBpcyBub3Qgb2YgdGhlIHJpZ2h0IHR5cGU6ICR7ZXJyb3J9LiBQbGVhc2UgbWFrZSBzdXJlIGFsbCBlbGVtZW50cyBpbiB0aGUgbGlzdCBhcmUgb2YgdGhlIGNvcnJlY3QgdHlwZSBmb3IgdGhpcyBmdW5jdGlvbi5gXG4gICk7XG5cbmV4cG9ydCBjb25zdCBmdW5jdGlvblJlY2VpdmVkV3JvbmdOdW1iZXJPZkFyZ3MgPSAoXG4gIG5hbWU6IHN0cmluZyxcbiAgYXJnVmFsaWRhdG9yc0xlbmd0aDogbnVtYmVyLFxuICBhcmdzTGVuZ3RoOiBudW1iZXJcbikgPT5cbiAgbmV3IEVycm9yKFxuICAgIGAke25hbWV9IHRha2VzICR7YXJnVmFsaWRhdG9yc0xlbmd0aH0gYXJndW1lbnRzLCBidXQgJHthcmdzTGVuZ3RofSB3ZXJlIHByb3ZpZGVkLiBQbGVhc2UgcHJvdmlkZSB0aGUgbWlzc2luZyBhcmd1bWVudHMgdG8gdGhlIGZ1bmN0aW9uLmBcbiAgKTtcblxuZXhwb3J0IGNvbnN0IGZ1bmN0aW9uQXJndW1lbnRWYWxpZGF0aW9uRmFpbHVyZSA9IChcbiAgYXJnTnVtYmVyOiBudW1iZXIsXG4gIG5hbWU6IHN0cmluZyxcbiAgZXJyb3I6IHVua25vd25cbikgPT5cbiAgbmV3IEVycm9yKFxuICAgIGBBcmd1bWVudCAke2FyZ051bWJlcn0gb2YgJHtuYW1lfSBmYWlsZWQgdGhlIHZhbGlkYXRpb246ICR7ZXJyb3J9LiBQbGVhc2UgY2hhbmdlIHlvdXIgY29kZSB0byBwYXNzIGEgdmFsaWQgdmFsdWUgZm9yIHRoaXMgYXJndW1lbnQuYFxuICApO1xuXG5leHBvcnQgY29uc3QgY2Fubm90Q2FsY0lkRm9yRW1wdHlTZXRPZkNvbXBvbmVudHMgPSAoKSA9PlxuICBuZXcgRXJyb3IoXG4gICAgYFVuYWJsZSB0byBjYWxjdWxhdGUgYSB1bmlxdWUgaWQgZm9yIGFuIGVtcHR5IHNldCBvZiBjb21wb25lbnRzLiBUaGlzIGNhbiBvbmx5IGhhcHBlbiBpZiB5b3UgYXJlIHRyeWluZyB0byBjcmVhdGUgYSB1bmlxdWUgaWQgd2hpbGUgbm90IHBhc3NpbmcgaW4gYW55IGNvbnN0cnVjdCBub2RlIGlkcy4gVGhpcyBtZWFucyB5b3VyIGNvbnN0cnVjdCBsaWtlbHkgaGFzIG5vIHBhcmVudCwgd2hpY2ggaXMgbm90IGFsbG93ZWQuIFBsZWFzZSBtYWtlIHN1cmUgeW91ciBjb25zdHJ1Y3QgaGFzIGEgcGFyZW50LCBlLmcuIG5ldyBBcHAodGhpcykgb3IgbmV3IFRlcnJhZm9ybVN0YWNrKHRoaXMsICdzdGFjaycpYFxuICApO1xuXG5leHBvcnQgY29uc3Qgc3RyaW5nVmFsdWVBZGRlZFRvUmVmZXJlbmNlTGlzdCA9IChsaXN0VG9rZW46IHN0cmluZ1tdKSA9PlxuICBuZXcgRXJyb3IoXG4gICAgYENhbm5vdCBhZGQgZWxlbWVudHMgdG8gbGlzdCB0b2tlbiwgZ290OiAke2xpc3RUb2tlbn0uIFdlIGV4cGVjdCB0aGUgZWxlbWVudHMgb2YgYSB0b2tlbml6ZWQgc3RyaW5nIGFycmF5IHRvIGJlIGEgc2luZ2xlIHN0cmluZyB0b2tlbiwgZS5nLiBbXCIme1RmVG9rZW5bVG9rZW4uMV19XCJdLiBJbiB0aGlzIGNhc2UgdGhlIG9uZSBlbGVtZW50IGluIHRoZSBhcnJheSBjb25zaXN0IG9mIG1vcmUgdGhhbiBvbmUgdmFsdWUuIFRvIGFkZCB2YWx1ZXMgdG8gYSB0b2tlbml6ZWQgbGlzdCB1c2UgVGVycmFmb3JtIEZ1bmN0aW9ucyBpbnN0ZWFkLCBlLmcuIEZuLmNvbmNhdChbeW91clJlZmVyZW5jZWRMaXN0LCBbXCJteVwiLCBcIm5ld1wiLCBcIml0ZW1zXCJdXSkuYFxuICApO1xuXG5leHBvcnQgY29uc3QgY2Fubm90Q29uY2F0ZW5hdGVTdHJpbmdzSW5Ub2tlbml6ZWRTdHJpbmdBcnJheSA9IChcbiAgbGlzdFRva2VuOiBzdHJpbmdcbikgPT5cbiAgbmV3IEVycm9yKFxuICAgIGBDYW5ub3QgY29uY2F0ZW5hdGUgc3RyaW5ncyBpbiBhIHRva2VuaXplZCBzdHJpbmcgYXJyYXksIGdvdDogJHtsaXN0VG9rZW59LiBXZSBleHBlY3QgdGhlIGVsZW1lbnRzIG9mIGEgdG9rZW5pemVkIHN0cmluZyBhcnJheSB0byBiZSBhIHNpbmdsZSBzdHJpbmcgdG9rZW4sIGUuZy4gW1wiJntUZlRva2VuW1Rva2VuLjFdfVwiXS4gSW4gdGhpcyBjYXNlIHRoZSBvbmUgZWxlbWVudCBpbiB0aGUgYXJyYXkgY29uc2lzdCBvZiBzb21ldGhpbmcgZGlmZmVyZW50IHRoYW4gYSBzaW5nbGUgdG9rZW4sIGxpa2VseSBieSBtdXRhdGluZyB0aGUgdmFsdWUgaW5zaWRlIHRoaXMgbGlzdC4gVGhpcyBsZWFkcyB0byBDREtURiBub3QgYmVpbmcgYWJsZSB0byByZXNvbHZlIHRoZSB0b2tlbiBpbnRvIHRoZSBhcHByb3ByaWF0ZSBydW50aW1lIHZhbHVlLiBQbGVhc2UgZG9uJ3QgbXV0YXRlIHRva2VuaXplZCBzdHJpbmcgYXJyYXlzLmBcbiAgKTtcblxuZXhwb3J0IGNvbnN0IG51bWJlclZhbHVlQWRkZWRUb1JlZmVyZW5jZUxpc3QgPSAobGlzdFRva2VuOiBudW1iZXJbXSkgPT5cbiAgbmV3IEVycm9yKFxuICAgIGBDYW5ub3QgYWRkIGVsZW1lbnRzIHRvIGxpc3QgdG9rZW4sIGdvdDogJHtsaXN0VG9rZW59LiBUb2tlbnMgYXJlIHVzZWQgdG8gcmVwcmVzZW50IHJ1bnRpbWUgdmFsdWVzIChlLmcuIHJlZmVyZW5jZXMgdG8gYXR0cmlidXRlcyBvZiByZXNvdXJjZSBvciBkYXRhIHNvdXJjZXMpLCB0aGV5IGRvbid0IGNvbnRhaW4gdGhlIHZhbHVlcyBzaW5jZSB0aGUgdmFsdWVzIGFyZSBvbmx5IGF2YWlsYWJsZSBhdCBhcHBseSB0aW1lLCB3aGVyZWFzIHRoZSBUb2tlbnMgYXJlIHByZXNlbnQgZHVyaW5nIGNvbXBpbGUgdGltZS4gWW91IHRyaWVkIHRvIGFkZCBhIHZhbHVlIHRvIGEgdG9rZW5pemVkIGxpc3QsIHRoaXMgc2hvdWxkIGJlIGRvbmUgdmlhIFRlcnJhZm9ybSBmdW5jdGlvbjogRm4uY29uY2F0KFt5b3VyUmVmZXJlbmNlZExpc3QsIFs0MiwgNDMsIDQ0XV0pLmBcbiAgKTtcblxuZXhwb3J0IGNvbnN0IG1hcFZhbHVlQWRkZWRUb1JlZmVyZW5jZUxpc3QgPSAobWFwVG9rZW46IHN0cmluZykgPT5cbiAgbmV3IEVycm9yKFxuICAgIGBDYW5ub3QgYWRkIGVsZW1lbnRzIHRvIG1hcCB0b2tlbiwgZ290OiAke21hcFRva2VufS4gVGhpcyBjYW4gaGFwcGVuIGlmIHlvdSBtZXJnZSBtdWx0aXBsZSBtYXBzIG9yIGlmIHlvdSBhZGQgYSBuZXcga2V5IHZhbHVlIHBhaXIgdG8gdGhlIG1hcCB0b2tlbi4gVG9rZW5zIGFyZSB1c2VkIHRvIHJlcHJlc2VudCBydW50aW1lIHZhbHVlcyAoZS5nLiByZWZlcmVuY2VzIHRvIGF0dHJpYnV0ZXMgb2YgcmVzb3VyY2Ugb3IgZGF0YSBzb3VyY2VzKSwgdGhleSBkb24ndCBjb250YWluIHRoZSB2YWx1ZXMgc2luY2UgdGhlIHZhbHVlcyBhcmUgb25seSBhdmFpbGFibGUgYXQgYXBwbHkgdGltZSwgd2hlcmVhcyB0aGUgVG9rZW5zIGFyZSBwcmVzZW50IGR1cmluZyBjb21waWxlIHRpbWUuIEluc3RlYWQgb2YgYWRkaW5nIHRoZSB2YWx1ZSB0byB0aGUgdG9rZW5pemVkIG1hcCB5b3UgbmVlZCB0byB1c2UgYSBUZXJyYWZvcm0gRnVuY3Rpb24sIGUuZy4gRm4ubWVyZ2UoW3lvdXJSZWZlcmVuY2VkTWFwLCB7IHlvdXI6ICd2YWx1ZScgfV0pIHRoYXQgY3JlYXRlcyBhIG5ldyBtYXAgVG9rZW4gZm9yIGEgdmFsdWUgdGhhdCByZXByZXNlbnRzIHdoYXQgeW91IHdhbnQgdG8gZXhwcmVzcy4gRm9yIGV4YW1wbGUgdGhpcyBtaWdodCBnZXQgcmVuZGVyZWQgYXMgbWVyZ2UobXlfcmVzb3VyY2UucmVzb3VyY2VfbmFtZS5vbmVfc3BlY2lmaWNfbWFwX2F0dHJpYnV0ZSwgeyB5b3VyOiAnIHZhbHVlJyB9KWBcbiAgKTtcblxuZXhwb3J0IGNvbnN0IGNhbm5vdENvbmNhdGVuYXRlU3RyaW5nc0luVG9rZW5pemVkTWFwID0gKHRva2VuaXplZE1hcDogYW55KSA9PlxuICBuZXcgRXJyb3IoXG4gICAgYENhbm5vdCBjb25jYXRlbmF0ZSBzdHJpbmdzIGluIGEgdG9rZW5pemVkIG1hcCwgZ290OiAke3Rva2VuaXplZE1hcH0uIFdlIGV4cGVjdCB0aGUga2V5IG9mIGEgdG9rZW5pemVkIG1hcCB0byBiZSBhIHN0cmluZyB0b2tlbiwgZS5nLiB7IFwiJntUZlRva2VuW1Rva2VuLjFdfVwiOiBcIlN0cmluZyBNYXAgVG9rZW4gVmFsdWVcIiB9LiBJbiB0aGlzIGNhc2UgdGhlIGtleSBpbiB0aGUgbWFwIGNvbnNpc3RzIG9mIG1vcmUgdGhhbiBhIHN0cmluZyB0b2tlbiAoZS5nLiB0aGUgVG9rZW4gYW5kIGEgc3RhdGljIHN0cmluZyBvciBtdWx0aXBsZSBUb2tlbikuIFRoaXMgY2FuIGhhcHBlbiBpZiB5b3UgbXV0YXRlIHRoZSBrZXkgb2YgdGhlIG1hcCwgd2hpY2ggaXMgbm90IGFsbG93ZWQuIFBsZWFzZSBkb24ndCBtdXRhdGUgdG9rZW5pemVkIE1hcHMgYXMgaXQgbWFrZXMgaXQgaW1wb3NzaWJsZSBmb3IgQ0RLVEYgdG8gdHJhbnNsYXRlIHRoZW0gdG8gdGhlaXIgaW50ZW5kZWQgdmFsdWVzLmBcbiAgKTtcblxuZXhwb3J0IGNvbnN0IGRvZXNOb3RJbXBsZW1lbnREZXBlbmRhYmxlVHJhaXQgPSAoaW5zdGFuY2U6IElEZXBlbmRhYmxlKSA9PlxuICBuZXcgRXJyb3IoYCR7aW5zdGFuY2V9IGRvZXMgbm90IGltcGxlbWVudCBEZXBlbmRhYmxlVHJhaXRgKTtcblxuZXhwb3J0IGNvbnN0IGNhbk9ubHlFbmNvZGVQb3NpdGl2ZUludGVnZXJzID0gKCkgPT5cbiAgbmV3IEVycm9yKFxuICAgIGBDYW4gb25seSBlbmNvZGUgcG9zaXRpdmUgaW50ZWdlcnMgaW50byBUb2tlbnMuIFRoaXMgaXMgYSBidWcgaW4gQ0RLVEYsIHBsZWFzZSBmaWxlIGEgYnVnIHJlcG9ydC5gXG4gICk7XG5cbmV4cG9ydCBjb25zdCBpbmRleFRvb0xhcmdlVG9FbmNvZGUgPSAoaW5kZXg6IG51bWJlcikgPT5cbiAgbmV3IEVycm9yKFxuICAgIGBHb3QgYW4gaW5kZXggdG9vIGxhcmdlIHRvIGVuY29kZSBpbnRvIGEgVG9rZW4gOiR7aW5kZXh9LiBUaGlzIGhhcHBlbnMgaWYgeW91IGhhdmUgYW4gZW5vcm1vdXMgYW1vdW50IG9mIFRva2VucyBpbiBhIHNpbmdsZSBDREtURiBhcHBsaWNhdGlvbi4gTW9zdCBsaWtlbHkgeW91IGFyZSBjcmVhdGluZyBudW1lcmljIHRva2VucyBpbiBhbiBpbmZpbml0ZSBsb29wLCBlLmcuIGJ5IGNhbGxpbmcgJ1Rva2VuLmFzTnVtYmVyKCknIGEgbG90LiBJZiB5b3UgcmVhY2ggdGhlIG1heGltdW0gbnVtYmVyIG9mIGFsbG93ZWQgVG9rZW5zIChhIGxpbWl0YXRpb24gaW1wb3NlZCBieSB0aGUgd2F5IHdlIGVuY29kZSBUb2tlbnMgLyBzZXBhcmF0ZSB0aGVtIGZyb20gcmVhbCBudW1lcmljIHZhbHVlcykgeW91IG5lZWQgdG8gd29yayBhcm91bmQgdGhpcyBpc3N1ZSBieSBzcGxpdHRpbmcgdXAgeW91ciBhcHBsaWNhdGlvbiBpbnRvIG11bHRpcGxlIGFwcGxpY2F0aW9ucy5gXG4gICk7XG5cbmV4cG9ydCBjb25zdCBhcmdUb0ludHJpbnNpY011c3RCZVBsYWluVmFsdWUgPSAoXG4gIHZhbHVlOiBhbnksXG4gIGNyZWF0aW9uU3RhY2s6IHN0cmluZ1tdXG4pID0+XG4gIG5ldyBFcnJvcihcbiAgICBgWW91IGNhbiBvbmx5IHVzZSBhIHBsYWluIHZhbHVlIChub3QgYSBmdW5jdGlvbikgd2hlbiBjcmVhdGluZyBhbiBJbnRyaW5zaWMgdG9rZW4uIFdlIGdvdCB0aGUgdmFsdWUgJyR7dmFsdWV9JyBjcmVhdGVkIGF0OlxcbiR7Y3JlYXRpb25TdGFjay5qb2luKFxuICAgICAgXCJcXG5cIlxuICAgICl9LiBJZiB5b3Ugd2FudCB0byB1c2UgYSBmdW5jdGlvbiwgcGxlYXNlIHVzZSB0aGUgTGF6eSBjbGFzcywgZS5nLiBMYXp5LmFueVZhbHVlKHsgcHJvZHVjZTogKCkgPT4gXCJIZWxsbyBXb3JsZFwiIH0pLmBcbiAgKTtcblxuZXhwb3J0IGNvbnN0IGludHJpbnNpY05ld0Vycm9yID0gKG1lc3NhZ2U6IHN0cmluZywgY3JlYXRlZEF0OiBzdHJpbmcpID0+XG4gIG5ldyBFcnJvcihgJHttZXNzYWdlfVxcblRva2VuIGNyZWF0ZWQ6XFxuICAgIGF0ICR7Y3JlYXRlZEF0fVxcbkVycm9yIHRocm93bjpgKTtcblxuZXhwb3J0IGNvbnN0IHVuYWJsZVRvUmVzb2x2ZUNpcmN1bGFyUmVmZXJlbmNlID0gKHBhdGhOYW1lOiBzdHJpbmcpID0+XG4gIG5ldyBFcnJvcihgVW5hYmxlIHRvIHJlc29sdmUgb2JqZWN0IHRyZWUgd2l0aCBjaXJjdWxhciByZWZlcmVuY2UgYXQgJyR7cGF0aE5hbWV9Jy5cblRoaXMgZXJyb3IgaXMgdGhyb3duIGlmIHRoZSBkZXB0aCBvZiB0aGUgb2JqZWN0IHRyZWUgaXMgZ3JlYXRlciB0aGFuIDIwMCB0byBwcm90ZWN0IGFnYWluc3QgY3ljbGljIHJlZmVyZW5jZXMuXG5UbyByZXNvbHZlIHRoaXMgaW5zcGVjdCB0aGUgY29uc3RydWN0IGNyZWF0aW5nIHRoZSBjeWNsaWMgcmVmZXJlbmNlIChtb3N0IGxpa2VseSBpbiAnJHtwYXRoTmFtZX0nKSBhbmQgbWFrZSBzdXJlXG5pdCBkb2VzIG5vdCBjcmVhdGUgYW4gaW5maW5pdGUgbmVzdGluZyBvZiBjb25zdHJ1Y3RzLmApO1xuXG5leHBvcnQgY29uc3QgY2Fubm90UmVzb2x2ZUZ1bmN0aW9uID0gKHBhdGhOYW1lOiBzdHJpbmcsIG9iajogYW55KSA9PlxuICBuZXcgRXJyb3IoYFRyeWluZyB0byByZXNvbHZlIGEgbm9uLWRhdGEgb2JqZWN0IChlLmcuIGEgZnVuY3Rpb24pIGF0ICcke3BhdGhOYW1lfSc6ICR7b2JqfS4gT25seSB0b2tlbnMgYXJlIHN1cHBvcnRlZCBmb3IgbGF6eSBldmFsdWF0aW9uLlxuSWYgeW91IHdhbnQgdG8gaGF2ZSBhIGxhemlseSBjb21wdXRlZCB2YWx1ZSwgcGxlYXNlIHVzZSB0aGUgTGF6eSBjbGFzcywgZS5nLiBMYXp5LnN0cmluZ1ZhbHVlKHsgcHJvZHVjZTogKCkgPT4gXCJIZWxsbyBXb3JsZFwiIH0pYCk7XG5cbmNvbnN0IExJU1RfRVJST1JfRVhQTEFOQVRJT04gPSBgSW4gQ0RLVEYgd2UgcmVwcmVzZW50IGxpc3RzIHdoZXJlIHRoZSB2YWx1ZSBpcyBvbmx5IGtub3duIGF0IHJ1bnRpbWUgKHZlcnN1cyBjb21waWxlIC8gc3ludGggdGltZSkgYXNcbkFycmF5cyB3aXRoIGEgc2luZ2xlIGVsZW1lbnQgdGhhdCBpcyBhIHN0cmluZyB0b2tlbiwgZS5nLiBbXCJUb2tlbi4xXCJdLiBUaGlzIGlzIGJlY2F1c2UgYXQgY29tcGlsZSB0aW1lIHdlXG5kb24ndCBrbm93IHRoZSBsZW5ndGggb2YgdGhlIGxpc3QsIHNvIGZhciBDREtURiBkaWQgbm90IGludm9rZSBUZXJyYWZvcm0gdG8gY29tbXVuaWNhdGUgd2l0aCB0aGUgY2xvdWQgcHJvdmlkZXIuXG5UaGlzIGlzIGRvbmUgYXQgYSBsYXRlciBzdGFnZSBvbiB0aGUgc3ludGhlc2l6ZWQgc3RhdGljIEpTT04gZmlsZS5cbkFzIHdlIGRvbid0IGtub3cgdGhlIGxlbmd0aCBvZiB0aGUgbGlzdCBub3QgdGhlIGNvbnRlbnQgd2UgY2FuIG5vdCBkaWZmZXJlbnRpYXRlIGlmIHRoZSBsaXN0IHdhcyBhY2Nlc3NlZCBhdCB0aGUgZmlyc3QgaW5kZXgsXG50aGUgbGFzdCBpbmRleCwgb3IgYXMgcGFydCBvZiBhIGxvb3AuIFRvIGF2b2lkIHRoaXMgYW1iaWd1aXR5OlxuXG4tIElmIHlvdSB3YW50IHRvIGFjY2VzcyBhIHNpbmd1bGFyIGl0ZW0gdXNlICdGbi5lbGVtZW50KGxpc3QsIDApJyAobm90ICdsaXN0WzBdJylcbi0gSWYgeW91IHdhbnQgdG8gbG9vcCBvdmVyIHRoZSBsaXN0IHVzZSAnVGVycmFmb3JtSXRlcmF0b3IuZnJvbUxpc3QobGlzdCknIChub3QgJ2ZvciAoY29uc3QgaXRlbSBvZiBsaXN0KScgb3IgJ2xpc3QuZm9yRWFjaChpdGVtID0+IC4uLiknKVxuXG5UbyBsZWFybiBtb3JlIGFib3V0IHRva2VucyBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuaGFzaGljb3JwLmNvbS90ZXJyYWZvcm0vY2RrdGYvY29uY2VwdHMvdG9rZW5zXG5UbyBsZWFybiBtb3JlIGFib3V0IGl0ZXJhdG9ycyBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuaGFzaGljb3JwLmNvbS90ZXJyYWZvcm0vY2RrdGYvY29uY2VwdHMvaXRlcmF0b3JzYDtcblxuY29uc3QgTUFQX0VSUk9SX0VYUExBTkFUSU9OID0gYEluIENES1RGIHdlIHJlcHJlc2VudCBtYXBzIHdoZXJlIHRoZSB2YWx1ZSBpcyBvbmx5IGtub3duIGF0IHJ1bnRpbWUgKHZlcnN1cyBjb21waWxlIC8gc3ludGggdGltZSkgYXNcbm9iamVjdHMgd2l0aCBhIHNpbmdsZSBrZXktdmFsdWUgcGFpciB3aGVyZSB0aGUgdmFsdWUgaXMgYSBzdHJpbmcgdG9rZW4sIGUuZy4geyBcIiZ7VGZUb2tlbltUb2tlbi4xXX1cIjogXCJTdHJpbmcgTWFwIFRva2VuIFZhbHVlXCIgfS5cblRoaXMgaXMgYmVjYXVzZSB0aGUgbGVuZ3RoIG9mIHRoZSBsaXN0IGlzbid0IGtub3cgYXQgY29tcGlsZSB0aW1lLCBhcyBDREtURiBoYXMgbm90IHlldCBpbnZva2VkIFRlcnJhZm9ybSB0byBjb21tdW5pY2F0ZSB3aXRoIHRoZSBjbG91ZCBwcm92aWRlci5cblRoaXMgaXMgZG9uZSBhdCBhIGxhdGVyIHN0YWdlIG9uIHRoZSBzeW50aGVzaXplZCBzdGF0aWMgSlNPTiBmaWxlLlxuQXMgd2UgZG9uJ3Qga25vdyB0aGUgY29udGVudHMgb2YgdGhlIG1hcCB3ZSBkbyBub3Qga25vdyB3aGljaCBrZXkgd2FzIGFjY2Vzc2VkLCBvciBpZiB0aGUgbWFwIHdhcyBhY2Nlc3NlZCBhcyBwYXJ0IG9mIGEgbG9vcC5cblRvIGF2b2lkIHRoaXMgYW1iaWd1aXR5OlxuXG4tIElmIHlvdSB3YW50IHRvIGFjY2VzcyBhIHNpbmd1bGFyIGl0ZW0gdXNlICdGbi5sb29rdXAobWFwLCBrZXkpJyAobm90ICdtYXBba2V5XScpXG4tIElmIHlvdSB3YW50IHRvIGxvb3Agb3ZlciB0aGUgbWFwIHVzZSAnVGVycmFmb3JtSXRlcmF0b3IuZnJvbU1hcChtYXApJyAobm90ICdmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBtYXApJyBvciAnT2JqZWN0LmVudHJpZXMobWFwKS5mb3JFYWNoKChrZXksIHZhbHVlKSA9PiAuLi4pJylcblxuVG8gbGVhcm4gbW9yZSBhYm91dCB0b2tlbnMgc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmhhc2hpY29ycC5jb20vdGVycmFmb3JtL2Nka3RmL2NvbmNlcHRzL3Rva2Vuc1xuVG8gbGVhcm4gbW9yZSBhYm91dCBpdGVyYXRvcnMgc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmhhc2hpY29ycC5jb20vdGVycmFmb3JtL2Nka3RmL2NvbmNlcHRzL2l0ZXJhdG9yc2A7XG5cbmV4cG9ydCBjb25zdCBlbmNvZGVkTGlzdFRva2VuSW5TY2FsYXJTdHJpbmdDb250ZXh0ID0gKCkgPT5cbiAgbmV3IEVycm9yKGBGb3VuZCBhbiBlbmNvZGVkIGxpc3QgdG9rZW4gc3RyaW5nIGluIGEgc2NhbGFyIHN0cmluZyBjb250ZXh0LlxuJHtMSVNUX0VSUk9SX0VYUExBTkFUSU9OfWApO1xuXG5leHBvcnQgY29uc3QgZW5jb2RlZE1hcFRva2VuSW5TY2FsYXJTdHJpbmdDb250ZXh0ID0gKCkgPT5cbiAgbmV3IEVycm9yKGBGb3VuZCBhbiBlbmNvZGVkIG1hcCB0b2tlbiBpbiBhIHNjYWxhciBzdHJpbmcgY29udGV4dC5cbiR7TUFQX0VSUk9SX0VYUExBTkFUSU9OfWApO1xuXG5leHBvcnQgY29uc3QgZW5jb2RlZE1hcFRva2VuSW5TY2FsYXJOdW1iZXJDb250ZXh0ID0gKCkgPT5cbiAgbmV3IEVycm9yKGBGb3VuZCBhbiBlbmNvZGVkIG1hcCB0b2tlbiBpbiBhIHNjYWxhciBudW1iZXIgY29udGV4dC5cbiR7TUFQX0VSUk9SX0VYUExBTkFUSU9OfWApO1xuXG5leHBvcnQgY29uc3QgY29uc3RydWN0c0Nhbm5vdEJlUmVzb2x2ZWQgPSAocGF0aE5hbWU6IHN0cmluZykgPT5cbiAgbmV3IEVycm9yKGBUcnlpbmcgdG8gcmVzb2x2ZSgpIGEgQ29uc3RydWN0IGF0ICcke3BhdGhOYW1lfScuIFxuVGhpcyBvZnRlbiBtZWFucyB0aGF0IHRoZXJlIGlzIGFuIHVuaW50ZW5kZWQgY3ljbGljIGRlcGVuZGVuY3kgaW4geW91ciBjb25zdHJ1Y3QgdHJlZSwgbGVhZGluZyB0byB0aGUgcmVzb2x1dGlvbiBiZWluZyBzdHVjayBpbiBhbiBpbmZpbml0ZSBsb29wIHdoaWNoIHdpbGwgZXZlbnR1YWxseSBmYWlsLiBUaGlzIGNhbiBoYXBwZW4gaWYgdGhlIHNjb3BlIHBhc3NlZCBpbnRvIHRoaXMgY29uc3RydWN0IGlzIGFsc28gcGFydCBvZiBpdHMgc3VidHJlZSBpbiBzb21lIHdheS4gVG8gcmVzb2x2ZSB0aGlzIGlzc3VlLCBwbGVhc2UgcmVmYWN0b3IgeW91ciBjb2RlIHRvIGF2b2lkIHRoaXMgY3ljbGljIGRlcGVuZGVuY3kgYnkgY2hhbmdpbmcgdGhlIHNjb3BlIG9mIHRoaXMgY29uc3RydWN0LmApO1xuXG5leHBvcnQgY29uc3QgbWFwS2V5TXVzdFJlc29sdmVUb1N0cmluZyA9IChcbiAgcGF0aE5hbWU6IHN0cmluZyxcbiAga2V5OiBzdHJpbmcsXG4gIHJlc29sdmVkS2V5OiBhbnlcbikgPT5cbiAgbmV3IEVycm9yKFxuICAgIGBBdCBcIiR7cGF0aE5hbWV9XCIgdGhlIGtleSBcIiR7a2V5fVwiIGlzIHVzZWQgaW4gYSBtYXAgc28gaXQgbXVzdCByZXNvbHZlIHRvIGEgc3RyaW5nLCBidXQgaXQgcmVzb2x2ZXMgdG8gYSAke3R5cGVvZiByZXNvbHZlZEtleX0gd2l0aCB0aGUgdmFsdWUgJHtKU09OLnN0cmluZ2lmeShcbiAgICAgIHJlc29sdmVkS2V5XG4gICAgKX0uIFRoaXMgbWVhbnMgdGhhdCB0aGUgdG9rZW4gdXNlZCBhcyB0aGUga2V5IGlzIG5vdCByZXNvbHZpbmcgaW50byBzdHJpbmcsIHlvdSBtdXN0IGNoYW5nZSB0aGUgVG9rZW4gc28gdGhhdCBpdCBkb2VzLmBcbiAgKTtcblxuY29uc3QgdW5rbm93blRva2VuRXhwbGFuYXRpb24gPSBgVGhpcyBtZWFucyB0aGF0IHlvdSBhcmUgdHJ5aW5nIHRvIGFjY2VzcyBhIFRva2VuIHZhbHVlIHRoYXQgZG9lcyBub3QgZXhpc3QuIFRoaXMgY2FuIG9ubHkgaGFwcGVuIGlmIHRoZSBUb2tlbiBpcyBlLmcuIGZyb20gYW5vdGhlciBDREsgKGkuZS4gQVdTIENESywgQ0RLOHMsIGV0Yy4pIGFuZCBpcyBub3Qga25vd24gdG8gdGhlIENES1RGIEFwcGxpY2F0aW9uLiBZb3UgZWl0aGVyIG5lZWQgdG8gbWFrZSB0aGUgb3RoZXIgQ0RLIHJlc29sdmUgdGhpcyB0b2tlbiBiZWZvcmUgQ0RLVEYgdHJpZXMgdG8gcmVzb2x2ZSB0aGUgdG9rZW4gb3Igd29yayBhcm91bmQgdXNpbmcgdGhpcyB0b2tlbiBhdCBhbGwuIFxuXG5JZiB0aGlzIGVycm9yIG9jY3VycyB3aXRob3V0IGFub3RoZXIgQ0RLIChvciBhIHZhbHVlIGxvb2tpbmcgbGlrZSBhIFRva2VuKSBiZWluZyBpbnZvbHZlZCwgcGxlYXNlIGZpbGUgYSBidWcuYDtcblxuZXhwb3J0IGNvbnN0IHVua25vd25OdW1iZXJUb2tlbkZvdW5kID0gKCkgPT5cbiAgbmV3IEVycm9yKFxuICAgIGBFbmNvZGVkIHJlcHJlc2VudGF0aW9uIG9mIHVua25vd24gbnVtYmVyIFRva2VuIGZvdW5kLiAke3Vua25vd25Ub2tlbkV4cGxhbmF0aW9ufWBcbiAgKTtcblxuZXhwb3J0IGNvbnN0IHVucmVjb2duaXplZFRva2VuS2V5ID0gKGtleTogc3RyaW5nKSA9PlxuICBuZXcgRXJyb3IoYFVucmVjb2duaXplZCBUb2tlbiBLZXkgJyR7a2V5fScuICR7dW5rbm93blRva2VuRXhwbGFuYXRpb259YCk7XG5cbmV4cG9ydCBjb25zdCBJZEluY2x1ZGVzVW5yZXNvbHZlZFRva2VucyA9ICh1bnJlc29sdmVkVG9rZW5zOiBzdHJpbmcpID0+XG4gIG5ldyBFcnJvcihcbiAgICBgVGhpcyBjb25zdHJ1Y3QgKG9yIGl0cyBwYXJlbnQgY29uc3RydWN0KSB3YXMgY29uZmlndXJlZCB3aXRoIGFuIElEIHRoYXQgY29udGFpbnMgYSBUb2tlbjogJHt1bnJlc29sdmVkVG9rZW5zfS4gVGhpcyBpcyBub3QgYWxsb3dlZCBhcyBJRHMgbXVzdCBiZSBrbm93biBzdGF0aWNhbGx5IGR1cmluZyBzeW50aGVzaXMuIFRoZSB2YWx1ZXMgb2YgdG9rZW5zIGFyZSBvbmx5IGtub3duIGR1cmluZyBhcHBseSwgdGhlcmVmb3JlIHRoZXkgY2Fubm90IGJlIHVzZWQgaW4gSURzLiBQbGVhc2UgdXNlIGEgY29uY3JldGUgdmFsdWUgZm9yIHlvdXIgY29uc3RydWN0cyBJRCBpbnN0ZWFkLmBcbiAgKTtcbiJdfQ==