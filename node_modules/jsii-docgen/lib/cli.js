"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.main = main;
const fs = __importStar(require("fs/promises"));
const path = __importStar(require("node:path"));
const yargs = __importStar(require("yargs"));
const transpile_1 = require("./docgen/transpile/transpile");
const index_1 = require("./index");
async function generateForLanguage(docs, options) {
    const { format, output } = options;
    // e.g. API.typescript as name
    const splitByLanguage = output.endsWith(`.${options.language.name}`);
    const submoduleSuffix = splitByLanguage ? `${options.language.name}.${format}` : format;
    // Ensure the output path exists
    const outputPath = path.dirname(output);
    await fs.mkdir(outputPath, { recursive: true });
    if (options.splitBySubmodules) {
        if (format !== 'md') {
            throw new Error('split-by-submodule is only supported for markdown');
        }
        const submodules = await docs.listSubmodules();
        for (const submodule of submodules) {
            const content = await docs.toMarkdown({
                ...options,
                submodule: submodule.fqn,
                allSubmodules: false,
                header: { title: `\`${(0, transpile_1.submoduleRelName)(submodule)}\` Submodule`, id: submodule.fqn },
            });
            await fs.writeFile(path.join(outputPath, `${(0, transpile_1.submoduleRelName)(submodule)}.${submoduleSuffix}`), content.render());
        }
        await fs.writeFile(`${output}.${format}`, await (await docs.toIndexMarkdown(submoduleSuffix, options)).render());
    }
    else {
        const content = await (format === 'md' ? docs.toMarkdown(options) : docs.toJson(options));
        await fs.writeFile(`${output}.${format}`, content.render());
    }
}
async function main() {
    const args = await yargs
        .usage('Usage: $0')
        .option('output', { alias: 'o', type: 'string', required: false, desc: 'Output filename, the file type is automatically added. Defaults to API.md if format is markdown (-f md) or API.json if format is JSON (-f json). If more than one language is passed, then the language will be included in the filename e.g. API.typescript.md' })
        .option('format', { alias: 'f', default: 'md', choices: ['md', 'json'], desc: 'Output format, markdown or json' })
        .option('language', { array: true, alias: 'l', default: ['typescript'], choices: transpile_1.Language.values().map(x => x.toString()), desc: 'Output language' })
        .option('package', { alias: 'p', type: 'string', required: false, desc: 'The name@version of an NPM package to document', defaultDescription: 'The package in the current directory' })
        .option('readme', { alias: 'r', type: 'boolean', required: false, desc: 'Include the user defined README.md in the documentation.' })
        .option('submodule', { alias: 's', type: 'string', required: false, desc: 'Generate docs for a specific submodule (or "root")' })
        .option('split-by-submodule', { type: 'boolean', required: false, desc: 'Generate a separate file for each submodule' })
        .example('$0', 'Generate documentation for the current module as a single file (auto-resolves node dependencies)')
        .argv;
    const submodule = args.submodule === 'root' ? undefined : args.submodule;
    const allSubmodules = !args.submodule;
    const readme = args.readme;
    const splitBySubmodules = args['split-by-submodule'];
    const docs = await (args.package
        ? index_1.Documentation.forPackage(args.package)
        : index_1.Documentation.forProject(process.cwd()));
    const options = (lang, output = 'API', includeLanguageInOutputName = false) => {
        const format = args.format === 'md' ? 'md' : 'json';
        // Clean the user provided output of a possible file ending
        let outputFileName = output.endsWith(`.${format}`)
            ? output.slice(0, -(format.length + 1))
            : output;
        // for multi language docs, include the language in the filename
        if (includeLanguageInOutputName) {
            outputFileName = `${outputFileName}.${lang}`;
        }
        return ({
            readme,
            language: transpile_1.Language.fromString(lang),
            submodule,
            allSubmodules,
            splitBySubmodules,
            format,
            output: outputFileName,
        });
    };
    if (args.language.length <= 1) {
        await generateForLanguage(docs, options(args.language[0], args.output));
    }
    else {
        for (const lang of args.language) {
            await generateForLanguage(docs, options(lang, args.output, true));
        }
    }
}
main().catch(e => {
    console.error(e);
    process.exit(1);
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2xpLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL2NsaS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBbURBLG9CQW9EQztBQXZHRCxnREFBa0M7QUFDbEMsZ0RBQWtDO0FBQ2xDLDZDQUErQjtBQUMvQiw0REFBMEU7QUFDMUUsbUNBQXdDO0FBWXhDLEtBQUssVUFBVSxtQkFBbUIsQ0FBQyxJQUFtQixFQUFFLE9BQXdCO0lBQzlFLE1BQU0sRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFLEdBQUcsT0FBTyxDQUFDO0lBQ25DLDhCQUE4QjtJQUM5QixNQUFNLGVBQWUsR0FBRyxNQUFNLENBQUMsUUFBUSxDQUFDLElBQUksT0FBTyxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDO0lBQ3JFLE1BQU0sZUFBZSxHQUFHLGVBQWUsQ0FBQyxDQUFDLENBQUMsR0FBRyxPQUFPLENBQUMsUUFBUSxDQUFDLElBQUksSUFBSSxNQUFNLEVBQUUsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDO0lBRXhGLGdDQUFnQztJQUNoQyxNQUFNLFVBQVUsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQ3hDLE1BQU0sRUFBRSxDQUFDLEtBQUssQ0FBQyxVQUFVLEVBQUUsRUFBRSxTQUFTLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQztJQUVoRCxJQUFJLE9BQU8sQ0FBQyxpQkFBaUIsRUFBRSxDQUFDO1FBQzlCLElBQUksTUFBTSxLQUFLLElBQUksRUFBRSxDQUFDO1lBQ3BCLE1BQU0sSUFBSSxLQUFLLENBQUMsbURBQW1ELENBQUMsQ0FBQztRQUN2RSxDQUFDO1FBRUQsTUFBTSxVQUFVLEdBQUcsTUFBTSxJQUFJLENBQUMsY0FBYyxFQUFFLENBQUM7UUFDL0MsS0FBSyxNQUFNLFNBQVMsSUFBSSxVQUFVLEVBQUUsQ0FBQztZQUNuQyxNQUFNLE9BQU8sR0FBRyxNQUFNLElBQUks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R0FBRyxHQUFHLGNBQWMsSUFBSSxJQUFJLEVBQUUsQ0FBQztRQUMvQyxDQUFDO1FBRUQsT0FBTyxDQUFDO1lBQ04sTUFBTTtZQUNOLFFBQVEsRUFBRSxvQkFBUSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUM7WUFDbkMsU0FBUztZQUNULGFBQWE7WUFDYixpQkFBaUI7WUFDakIsTUFBTTtZQUNOLE1BQU0sRUFBRSxjQUFjO1NBQ3ZCLENBQUMsQ0FBQztJQUNMLENBQUMsQ0FBQztJQUVGLElBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLElBQUksQ0FBQyxFQUFFLENBQUM7UUFDOUIsTUFBTSxtQkFBbUIsQ0FBQyxJQUFJLEVBQUUsT0FBTyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7SUFDMUUsQ0FBQztTQUFNLENBQUM7UUFDTixLQUFLLE1BQU0sSUFBSSxJQUFJLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQztZQUNqQyxNQUFNLG1CQUFtQixDQUFDLElBQUksRUFBRSxPQUFPLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQztRQUNwRSxDQUFDO0lBQ0gsQ0FBQztBQUNILENBQUM7QUFFRCxJQUFJLEVBQUUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUU7SUFDZixPQUFPLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ2pCLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDbEIsQ0FBQyxDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBmcyBmcm9tICdmcy9wcm9taXNlcyc7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ25vZGU6cGF0aCc7XG5pbXBvcnQgKiBhcyB5YXJncyBmcm9tICd5YXJncyc7XG5pbXBvcnQgeyBMYW5ndWFnZSwgc3VibW9kdWxlUmVsTmFtZSB9IGZyb20gJy4vZG9jZ2VuL3RyYW5zcGlsZS90cmFuc3BpbGUnO1xuaW1wb3J0IHsgRG9jdW1lbnRhdGlvbiB9IGZyb20gJy4vaW5kZXgnO1xuXG50eXBlIEdlbmVyYXRlT3B0aW9ucyA9IHtcbiAgcmVhZG1lPzogYm9vbGVhbjtcbiAgbGFuZ3VhZ2U6IExhbmd1YWdlO1xuICBzdWJtb2R1bGU/OiBzdHJpbmc7XG4gIGFsbFN1Ym1vZHVsZXM/OiBib29sZWFuO1xuICBzcGxpdEJ5U3VibW9kdWxlcz86IGJvb2xlYW47XG4gIGZvcm1hdDogJ21kJyB8ICdqc29uJztcbiAgb3V0cHV0OiBzdHJpbmc7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlRm9yTGFuZ3VhZ2UoZG9jczogRG9jdW1lbnRhdGlvbiwgb3B0aW9uczogR2VuZXJhdGVPcHRpb25zKSB7XG4gIGNvbnN0IHsgZm9ybWF0LCBvdXRwdXQgfSA9IG9wdGlvbnM7XG4gIC8vIGUuZy4gQVBJLnR5cGVzY3JpcHQgYXMgbmFtZVxuICBjb25zdCBzcGxpdEJ5TGFuZ3VhZ2UgPSBvdXRwdXQuZW5kc1dpdGgoYC4ke29wdGlvbnMubGFuZ3VhZ2UubmFtZX1gKTtcbiAgY29uc3Qgc3VibW9kdWxlU3VmZml4ID0gc3BsaXRCeUxhbmd1YWdlID8gYCR7b3B0aW9ucy5sYW5ndWFnZS5uYW1lfS4ke2Zvcm1hdH1gIDogZm9ybWF0O1xuXG4gIC8vIEVuc3VyZSB0aGUgb3V0cHV0IHBhdGggZXhpc3RzXG4gIGNvbnN0IG91dHB1dFBhdGggPSBwYXRoLmRpcm5hbWUob3V0cHV0KTtcbiAgYXdhaXQgZnMubWtkaXIob3V0cHV0UGF0aCwgeyByZWN1cnNpdmU6IHRydWUgfSk7XG5cbiAgaWYgKG9wdGlvbnMuc3BsaXRCeVN1Ym1vZHVsZXMpIHtcbiAgICBpZiAoZm9ybWF0ICE9PSAnbWQnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NwbGl0LWJ5LXN1Ym1vZHVsZSBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgbWFya2Rvd24nKTtcbiAgICB9XG5cbiAgICBjb25zdCBzdWJtb2R1bGVzID0gYXdhaXQgZG9jcy5saXN0U3VibW9kdWxlcygpO1xuICAgIGZvciAoY29uc3Qgc3VibW9kdWxlIG9mIHN1Ym1vZHVsZXMpIHtcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSBhd2FpdCBkb2NzLnRvTWFya2Rvd24oe1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICBzdWJtb2R1bGU6IHN1Ym1vZHVsZS5mcW4sXG4gICAgICAgIGFsbFN1Ym1vZHVsZXM6IGZhbHNlLFxuICAgICAgICBoZWFkZXI6IHsgdGl0bGU6IGBcXGAke3N1Ym1vZHVsZVJlbE5hbWUoc3VibW9kdWxlKX1cXGAgU3VibW9kdWxlYCwgaWQ6IHN1Ym1vZHVsZS5mcW4gfSxcbiAgICAgIH0pO1xuXG4gICAgICBhd2FpdCBmcy53cml0ZUZpbGUocGF0aC5qb2luKG91dHB1dFBhdGgsIGAke3N1Ym1vZHVsZVJlbE5hbWUoc3VibW9kdWxlKX0uJHtzdWJtb2R1bGVTdWZmaXh9YCksIGNvbnRlbnQucmVuZGVyKCkpO1xuICAgIH1cblxuICAgIGF3YWl0IGZzLndyaXRlRmlsZShgJHtvdXRwdXR9LiR7Zm9ybWF0fWAsIGF3YWl0IChhd2FpdCBkb2NzLnRvSW5kZXhNYXJrZG93bihzdWJtb2R1bGVTdWZmaXgsIG9wdGlvbnMpKS5yZW5kZXIoKSk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgY29udGVudCA9IGF3YWl0IChmb3JtYXQgPT09ICdtZCcgPyBkb2NzLnRvTWFya2Rvd24ob3B0aW9ucykgOiBkb2NzLnRvSnNvbihvcHRpb25zKSk7XG4gICAgYXdhaXQgZnMud3JpdGVGaWxlKGAke291dHB1dH0uJHtmb3JtYXR9YCwgY29udGVudC5yZW5kZXIoKSk7XG4gIH1cbn1cblxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gbWFpbigpIHtcbiAgY29uc3QgYXJncyA9IGF3YWl0IHlhcmdzXG4gICAgLnVzYWdlKCdVc2FnZTogJDAnKVxuICAgIC5vcHRpb24oJ291dHB1dCcsIHsgYWxpYXM6ICdvJywgdHlwZTogJ3N0cmluZycsIHJlcXVpcmVkOiBmYWxzZSwgZGVzYzogJ091dHB1dCBmaWxlbmFtZSwgdGhlIGZpbGUgdHlwZSBpcyBhdXRvbWF0aWNhbGx5IGFkZGVkLiBEZWZhdWx0cyB0byBBUEkubWQgaWYgZm9ybWF0IGlzIG1hcmtkb3duICgtZiBtZCkgb3IgQVBJLmpzb24gaWYgZm9ybWF0IGlzIEpTT04gKC1mIGpzb24pLiBJZiBtb3JlIHRoYW4gb25lIGxhbmd1YWdlIGlzIHBhc3NlZCwgdGhlbiB0aGUgbGFuZ3VhZ2Ugd2lsbCBiZSBpbmNsdWRlZCBpbiB0aGUgZmlsZW5hbWUgZS5nLiBBUEkudHlwZXNjcmlwdC5tZCcgfSlcbiAgICAub3B0aW9uKCdmb3JtYXQnLCB7IGFsaWFzOiAnZicsIGRlZmF1bHQ6ICdtZCcsIGNob2ljZXM6IFsnbWQnLCAnanNvbiddLCBkZXNjOiAnT3V0cHV0IGZvcm1hdCwgbWFya2Rvd24gb3IganNvbicgfSlcbiAgICAub3B0aW9uKCdsYW5ndWFnZScsIHsgYXJyYXk6IHRydWUsIGFsaWFzOiAnbCcsIGRlZmF1bHQ6IFsndHlwZXNjcmlwdCddLCBjaG9pY2VzOiBMYW5ndWFnZS52YWx1ZXMoKS5tYXAoeCA9PiB4LnRvU3RyaW5nKCkpLCBkZXNjOiAnT3V0cHV0IGxhbmd1YWdlJyB9KVxuICAgIC5vcHRpb24oJ3BhY2thZ2UnLCB7IGFsaWFzOiAncCcsIHR5cGU6ICdzdHJpbmcnLCByZXF1aXJlZDogZmFsc2UsIGRlc2M6ICdUaGUgbmFtZUB2ZXJzaW9uIG9mIGFuIE5QTSBwYWNrYWdlIHRvIGRvY3VtZW50JywgZGVmYXVsdERlc2NyaXB0aW9uOiAnVGhlIHBhY2thZ2UgaW4gdGhlIGN1cnJlbnQgZGlyZWN0b3J5JyB9KVxuICAgIC5vcHRpb24oJ3JlYWRtZScsIHsgYWxpYXM6ICdyJywgdHlwZTogJ2Jvb2xlYW4nLCByZXF1aXJlZDogZmFsc2UsIGRlc2M6ICdJbmNsdWRlIHRoZSB1c2VyIGRlZmluZWQgUkVBRE1FLm1kIGluIHRoZSBkb2N1bWVudGF0aW9uLicgfSlcbiAgICAub3B0aW9uKCdzdWJtb2R1bGUnLCB7IGFsaWFzOiAncycsIHR5cGU6ICdzdHJpbmcnLCByZXF1aXJlZDogZmFsc2UsIGRlc2M6ICdHZW5lcmF0ZSBkb2NzIGZvciBhIHNwZWNpZmljIHN1Ym1vZHVsZSAob3IgXCJyb290XCIpJyB9KVxuICAgIC5vcHRpb24oJ3NwbGl0LWJ5LXN1Ym1vZHVsZScsIHsgdHlwZTogJ2Jvb2xlYW4nLCByZXF1aXJlZDogZmFsc2UsIGRlc2M6ICdHZW5lcmF0ZSBhIHNlcGFyYXRlIGZpbGUgZm9yIGVhY2ggc3VibW9kdWxlJyB9KVxuICAgIC5leGFtcGxlKCckMCcsICdHZW5lcmF0ZSBkb2N1bWVudGF0aW9uIGZvciB0aGUgY3VycmVudCBtb2R1bGUgYXMgYSBzaW5nbGUgZmlsZSAoYXV0by1yZXNvbHZlcyBub2RlIGRlcGVuZGVuY2llcyknKVxuICAgIC5hcmd2O1xuXG4gIGNvbnN0IHN1Ym1vZHVsZSA9IGFyZ3Muc3VibW9kdWxlID09PSAncm9vdCcgPyB1bmRlZmluZWQgOiBhcmdzLnN1Ym1vZHVsZTtcbiAgY29uc3QgYWxsU3VibW9kdWxlcyA9ICFhcmdzLnN1Ym1vZHVsZTtcbiAgY29uc3QgcmVhZG1lID0gYXJncy5yZWFkbWU7XG4gIGNvbnN0IHNwbGl0QnlTdWJtb2R1bGVzID0gYXJnc1snc3BsaXQtYnktc3VibW9kdWxlJ107XG4gIGNvbnN0IGRvY3MgPSBhd2FpdCAoYXJncy5wYWNrYWdlXG4gICAgPyBEb2N1bWVudGF0aW9uLmZvclBhY2thZ2UoYXJncy5wYWNrYWdlKVxuICAgIDogRG9jdW1lbnRhdGlvbi5mb3JQcm9qZWN0KHByb2Nlc3MuY3dkKCkpKTtcblxuICBjb25zdCBvcHRpb25zID0gKGxhbmc6IHN0cmluZywgb3V0cHV0OiBzdHJpbmcgPSAnQVBJJywgaW5jbHVkZUxhbmd1YWdlSW5PdXRwdXROYW1lID0gZmFsc2UpOiBHZW5lcmF0ZU9wdGlvbnMgPT4ge1xuICAgIGNvbnN0IGZvcm1hdCA9IGFyZ3MuZm9ybWF0ID09PSAnbWQnID8gJ21kJyA6ICdqc29uJztcblxuICAgIC8vIENsZWFuIHRoZSB1c2VyIHByb3ZpZGVkIG91dHB1dCBvZiBhIHBvc3NpYmxlIGZpbGUgZW5kaW5nXG4gICAgbGV0IG91dHB1dEZpbGVOYW1lID0gb3V0cHV0LmVuZHNXaXRoKGAuJHtmb3JtYXR9YClcbiAgICAgID8gb3V0cHV0LnNsaWNlKDAsIC0oZm9ybWF0Lmxlbmd0aCArIDEpKVxuICAgICAgOiBvdXRwdXQ7XG5cbiAgICAvLyBmb3IgbXVsdGkgbGFuZ3VhZ2UgZG9jcywgaW5jbHVkZSB0aGUgbGFuZ3VhZ2UgaW4gdGhlIGZpbGVuYW1lXG4gICAgaWYgKGluY2x1ZGVMYW5ndWFnZUluT3V0cHV0TmFtZSkge1xuICAgICAgb3V0cHV0RmlsZU5hbWUgPSBgJHtvdXRwdXRGaWxlTmFtZX0uJHtsYW5nfWA7XG4gICAgfVxuXG4gICAgcmV0dXJuICh7XG4gICAgICByZWFkbWUsXG4gICAgICBsYW5ndWFnZTogTGFuZ3VhZ2UuZnJvbVN0cmluZyhsYW5nKSxcbiAgICAgIHN1Ym1vZHVsZSxcbiAgICAgIGFsbFN1Ym1vZHVsZXMsXG4gICAgICBzcGxpdEJ5U3VibW9kdWxlcyxcbiAgICAgIGZvcm1hdCxcbiAgICAgIG91dHB1dDogb3V0cHV0RmlsZU5hbWUsXG4gICAgfSk7XG4gIH07XG5cbiAgaWYgKGFyZ3MubGFuZ3VhZ2UubGVuZ3RoIDw9IDEpIHtcbiAgICBhd2FpdCBnZW5lcmF0ZUZvckxhbmd1YWdlKGRvY3MsIG9wdGlvbnMoYXJncy5sYW5ndWFnZVswXSwgYXJncy5vdXRwdXQpKTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKGNvbnN0IGxhbmcgb2YgYXJncy5sYW5ndWFnZSkge1xuICAgICAgYXdhaXQgZ2VuZXJhdGVGb3JMYW5ndWFnZShkb2NzLCBvcHRpb25zKGxhbmcsIGFyZ3Mub3V0cHV0LCB0cnVlKSk7XG4gICAgfVxuICB9XG59XG5cbm1haW4oKS5jYXRjaChlID0+IHtcbiAgY29uc29sZS5lcnJvcihlKTtcbiAgcHJvY2Vzcy5leGl0KDEpO1xufSk7XG5cbiJdfQ==