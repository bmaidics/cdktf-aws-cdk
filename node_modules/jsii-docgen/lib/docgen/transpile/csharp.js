"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CSharpTranspile = void 0;
const Case = __importStar(require("case"));
const reflect = __importStar(require("jsii-reflect"));
const transpile = __importStar(require("./transpile"));
const schema_1 = require("../schema");
class CSharpTranspile extends transpile.TranspileBase {
    constructor() {
        super(transpile.Language.CSHARP);
    }
    moduleLike(moduleLike) {
        var _a, _b, _c, _d;
        const csharpPackage = (_b = (_a = moduleLike.targets) === null || _a === void 0 ? void 0 : _a.dotnet) === null || _b === void 0 ? void 0 : _b.namespace;
        // if this is a submodule, we need to break the package name down into the
        // parent name and the submodule. we also allow submodules not to have
        // explicit target names, in which case we need to append the pascal-cased
        // submodule name to the parent package name.
        if (moduleLike instanceof reflect.Submodule) {
            const parent = this.getParentModule(moduleLike);
            const parentFqn = (_d = (_c = parent.targets) === null || _c === void 0 ? void 0 : _c.dotnet) === null || _d === void 0 ? void 0 : _d.namespace;
            // if the submodule does not explicitly define a dotnet package name, we need to deduce it from the parent
            const submoduleCSharpPackage = csharpPackage !== null && csharpPackage !== void 0 ? csharpPackage : `${parentFqn}.${Case.pascal(moduleLike.name)}`;
            return { name: parentFqn, submodule: submoduleCSharpPackage };
        }
        return { name: csharpPackage };
    }
    type(type) {
        const submodule = this.findSubmodule(type);
        const moduleLike = this.moduleLike(submodule ? submodule : type.assembly);
        const fqn = [];
        let namespace = type.namespace;
        if (namespace) {
            fqn.push(moduleLike.name);
            fqn.push(namespace);
        }
        else {
            fqn.push(moduleLike.name);
        }
        fqn.push(type.name);
        return new transpile.TranspiledType({
            fqn: fqn.join('.'),
            name: type.name,
            namespace: namespace,
            module: moduleLike.name,
            submodule: moduleLike.submodule,
            submodulePath: (0, schema_1.submodulePath)(submodule),
            source: type,
            language: this.language,
        });
    }
    callable(callable) {
        const type = this.type(callable.parentType);
        const isInitializer = reflect.Initializer.isInitializer(callable);
        const name = isInitializer
            ? type.name
            : Case.pascal(callable.name);
        const parameters = callable.parameters.sort(this.optionalityCompare);
        const paramsFormatted = parameters.map(p => this.formatFnParam(this.parameter(p))).join(', ');
        const prefix = isInitializer || callable.protected ? 'protected' : 'private';
        let returnType;
        if (reflect.Initializer.isInitializer(callable)) {
            returnType = this.typeReference(callable.parentType.reference);
        }
        else if (reflect.Method.isMethod(callable)) {
            returnType = this.typeReference(callable.returns.type);
        }
        const returns = returnType === null || returnType === void 0 ? void 0 : returnType.toString({
            typeFormatter: (t) => t.name,
        });
        const signatures = [`${prefix} ${returns ? returns + ' ' : ''}${name}(${paramsFormatted})`];
        const invocations = [isInitializer
                ? `new ${name}(${paramsFormatted});`
                : `${type.name}.${name}(${paramsFormatted});`];
        return {
            name,
            parentType: type,
            import: this.formatImport(type),
            parameters,
            signatures,
            invocations,
        };
    }
    class(klass) {
        return {
            name: klass.name,
            type: this.type(klass),
        };
    }
    struct(struct) {
        const type = this.type(struct);
        const indent = ' '.repeat(4);
        const inputs = struct.allProperties.map((p) => {
            return `${indent}${this.formatFnParam(this.property(p))}`;
        }).flat();
        return {
            type: type,
            name: struct.name,
            import: this.formatImport(type),
            initialization: this.formatStructBuilder(type, inputs),
        };
    }
    interface(iface) {
        return {
            name: iface.name,
            type: this.type(iface),
        };
    }
    parameter(parameter) {
        const typeRef = this.typeReference(parameter.type);
        const name = Case.pascal(parameter.name);
        return {
            name,
            parentType: this.type(parameter.parentType),
            typeReference: typeRef,
            optional: parameter.optional,
            declaration: this.formatParameter(name, typeRef),
        };
    }
    property(property) {
        const typeRef = this.typeReference(property.type);
        const name = Case.pascal(property.name);
        return {
            name,
            parentType: this.type(property.parentType),
            typeReference: typeRef,
            optional: property.optional,
            declaration: this.formatProperty(name, typeRef, property),
        };
    }
    enum(enu) {
        return {
            fqn: this.type(enu).fqn,
            name: enu.name,
        };
    }
    enumMember(em) {
        return {
            fqn: `${this.enum(em.enumType).fqn}.${em.name}`,
            name: em.name,
        };
    }
    unionOf() {
        return 'object';
    }
    listOf(type) {
        return `${type}[]`;
    }
    mapOf(type) {
        return `System.Collections.Generic.IDictionary<string, ${type}>`;
    }
    any() {
        return 'object';
    }
    void() {
        return 'void';
    }
    str() {
        return 'string';
    }
    number() {
        return 'double';
    }
    boolean() {
        return 'bool';
    }
    json() {
        return 'Newtonsoft.Json.Linq.JObject';
    }
    date() {
        return 'System.DateTime';
    }
    readme(readme) {
        return readme;
    }
    formatImport(type) {
        return `using ${type.module};`;
    }
    formatFnParam(transpiled) {
        const tf = transpiled.typeReference.toString({
            typeFormatter: (t) => t.name,
        });
        const suffix = transpiled.optional ? ' = null' : '';
        return `${tf} ${transpiled.name}${suffix}`;
    }
    formatStructBuilder(type, properties) {
        const builder = `new ${type.name} {`;
        return [
            builder,
            properties.join(',\n'),
            '};',
        ].join('\n');
    }
    ;
    formatParameter(name, typeReference) {
        const tf = typeReference.toString({
            typeFormatter: (t) => t.name,
        });
        return `public ${tf} ${name}`;
    }
    formatProperty(name, typeReference, property) {
        const tf = typeReference.toString({
            typeFormatter: (t) => t.name,
        });
        const prefix = property.protected ? 'protected' : 'public';
        // setters are always available on struct properties
        const hasSetter = property.parentType.isDataType() || (!property.immutable && property.abstract);
        const suffix = hasSetter ? '{ get; set; }' : '{ get; }';
        return `${prefix} ${tf} ${name} ${suffix}`;
    }
}
exports.CSharpTranspile = CSharpTranspile;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY3NoYXJwLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2RvY2dlbi90cmFuc3BpbGUvY3NoYXJwLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsMkNBQTZCO0FBQzdCLHNEQUF3QztBQUN4Qyx1REFBeUM7QUFDekMsc0NBQTBDO0FBRTFDLE1BQWEsZUFBZ0IsU0FBUSxTQUFTLENBQUMsYUFBYTtJQUMxRDtRQUNFLEtBQUssQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQ25DLENBQUM7SUFFTSxVQUFVLENBQ2YsVUFBOEI7O1FBRTlCLE1BQU0sYUFBYSxHQUFXLE1BQUEsTUFBQSxVQUFVLENBQUMsT0FBTywwQ0FBRSxNQUFNLDBDQUFFLFNBQVMsQ0FBQztRQUVwRSwwRUFBMEU7UUFDMUUsc0VBQXNFO1FBQ3RFLDBFQUEwRTtRQUMxRSw2Q0FBNkM7UUFDN0MsSUFBSSxVQUFVLFlBQVksT0FBTyxDQUFDLFNBQVMsRUFBRSxDQUFDO1lBQzVDLE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxlQUFlLENBQUMsVUFBVSxDQUFDLENBQUM7WUFDaEQsTUFBTSxTQUFTLEdBQUcsTUFBQSxNQUFBLE1BQU0sQ0FBQyxPQUFPLDBDQUFFLE1BQU0sMENBQUUsU0FBUyxDQUFDO1lBRXBELDBHQUEwRztZQUMxRyxNQUFNLHNCQUFzQixHQUFHLGFBQWEsYUFBYixhQUFhLGNBQWIsYUFBYSxHQUFJLEdBQUcsU0FBUyxJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUM7WUFDL0YsT0FBTyxFQUFFLElBQUksRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLHNCQUFzQixFQUFFLENBQUM7UUFDaEUsQ0FBQztRQUVELE9BQU8sRUFBRSxJQUFJLEVBQUUsYUFBYSxFQUFFLENBQUM7SUFDakMsQ0FBQztJQUVNLElBQUksQ0FBQyxJ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RSxHQUFHLGFBQWEsQ0FBQyxRQUFRLENBQUM7WUFDaEMsYUFBYSxFQUFFLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSTtTQUM3QixDQUFDLENBQUM7UUFFSCxNQUFNLE1BQU0sR0FBRyxRQUFRLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQztRQUMzRCxvREFBb0Q7UUFDcEQsTUFBTSxTQUFTLEdBQUcsUUFBUSxDQUFDLFVBQVUsQ0FBQyxVQUFVLEVBQUUsSUFBSSxDQUFDLENBQUMsUUFBUSxDQUFDLFNBQVMsSUFBSSxRQUFRLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDakcsTUFBTSxNQUFNLEdBQUcsU0FBUyxDQUFDLENBQUMsQ0FBQyxlQUFlLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQztRQUN4RCxPQUFPLEdBQUcsTUFBTSxJQUFJLEVBQUUsSUFBSSxJQUFJLElBQUksTUFBTSxFQUFFLENBQUM7SUFDN0MsQ0FBQztDQUNGO0FBelBELDBDQXlQQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIENhc2UgZnJvbSAnY2FzZSc7XG5pbXBvcnQgKiBhcyByZWZsZWN0IGZyb20gJ2pzaWktcmVmbGVjdCc7XG5pbXBvcnQgKiBhcyB0cmFuc3BpbGUgZnJvbSAnLi90cmFuc3BpbGUnO1xuaW1wb3J0IHsgc3VibW9kdWxlUGF0aCB9IGZyb20gJy4uL3NjaGVtYSc7XG5cbmV4cG9ydCBjbGFzcyBDU2hhcnBUcmFuc3BpbGUgZXh0ZW5kcyB0cmFuc3BpbGUuVHJhbnNwaWxlQmFzZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKHRyYW5zcGlsZS5MYW5ndWFnZS5DU0hBUlApO1xuICB9XG5cbiAgcHVibGljIG1vZHVsZUxpa2UoXG4gICAgbW9kdWxlTGlrZTogcmVmbGVjdC5Nb2R1bGVMaWtlLFxuICApOiB0cmFuc3BpbGUuVHJhbnNwaWxlZE1vZHVsZUxpa2Uge1xuICAgIGNvbnN0IGNzaGFycFBhY2thZ2U6IHN0cmluZyA9IG1vZHVsZUxpa2UudGFyZ2V0cz8uZG90bmV0Py5uYW1lc3BhY2U7XG5cbiAgICAvLyBpZiB0aGlzIGlzIGEgc3VibW9kdWxlLCB3ZSBuZWVkIHRvIGJyZWFrIHRoZSBwYWNrYWdlIG5hbWUgZG93biBpbnRvIHRoZVxuICAgIC8vIHBhcmVudCBuYW1lIGFuZCB0aGUgc3VibW9kdWxlLiB3ZSBhbHNvIGFsbG93IHN1Ym1vZHVsZXMgbm90IHRvIGhhdmVcbiAgICAvLyBleHBsaWNpdCB0YXJnZXQgbmFtZXMsIGluIHdoaWNoIGNhc2Ugd2UgbmVlZCB0byBhcHBlbmQgdGhlIHBhc2NhbC1jYXNlZFxuICAgIC8vIHN1Ym1vZHVsZSBuYW1lIHRvIHRoZSBwYXJlbnQgcGFja2FnZSBuYW1lLlxuICAgIGlmIChtb2R1bGVMaWtlIGluc3RhbmNlb2YgcmVmbGVjdC5TdWJtb2R1bGUpIHtcbiAgICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuZ2V0UGFyZW50TW9kdWxlKG1vZHVsZUxpa2UpO1xuICAgICAgY29uc3QgcGFyZW50RnFuID0gcGFyZW50LnRhcmdldHM/LmRvdG5ldD8ubmFtZXNwYWNlO1xuXG4gICAgICAvLyBpZiB0aGUgc3VibW9kdWxlIGRvZXMgbm90IGV4cGxpY2l0bHkgZGVmaW5lIGEgZG90bmV0IHBhY2thZ2UgbmFtZSwgd2UgbmVlZCB0byBkZWR1Y2UgaXQgZnJvbSB0aGUgcGFyZW50XG4gICAgICBjb25zdCBzdWJtb2R1bGVDU2hhcnBQYWNrYWdlID0gY3NoYXJwUGFja2FnZSA/PyBgJHtwYXJlbnRGcW59LiR7Q2FzZS5wYXNjYWwobW9kdWxlTGlrZS5uYW1lKX1gO1xuICAgICAgcmV0dXJuIHsgbmFtZTogcGFyZW50RnFuLCBzdWJtb2R1bGU6IHN1Ym1vZHVsZUNTaGFycFBhY2thZ2UgfTtcbiAgICB9XG5cbiAgICByZXR1cm4geyBuYW1lOiBjc2hhcnBQYWNrYWdlIH07XG4gIH1cblxuICBwdWJsaWMgdHlwZSh0eXBlOiByZWZsZWN0LlR5cGUpOiB0cmFuc3BpbGUuVHJhbnNwaWxlZFR5cGUge1xuICAgIGNvbnN0IHN1Ym1vZHVsZSA9IHRoaXMuZmluZFN1Ym1vZHVsZSh0eXBlKTtcbiAgICBjb25zdCBtb2R1bGVMaWtlID0gdGhpcy5tb2R1bGVMaWtlKHN1Ym1vZHVsZSA/IHN1Ym1vZHVsZSA6IHR5cGUuYXNzZW1ibHkpO1xuXG4gICAgY29uc3QgZnFuID0gW107XG5cbiAgICBsZXQgbmFtZXNwYWNlID0gdHlwZS5uYW1lc3BhY2U7XG4gICAgaWYgKG5hbWVzcGFjZSkge1xuICAgICAgZnFuLnB1c2gobW9kdWxlTGlrZS5uYW1lKTtcbiAgICAgIGZxbi5wdXNoKG5hbWVzcGFjZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZxbi5wdXNoKG1vZHVsZUxpa2UubmFtZSk7XG4gICAgfVxuICAgIGZxbi5wdXNoKHR5cGUubmFtZSk7XG5cbiAgICByZXR1cm4gbmV3IHRyYW5zcGlsZS5UcmFuc3BpbGVkVHlwZSh7XG4gICAgICBmcW46IGZxbi5qb2luKCcuJyksXG4gICAgICBuYW1lOiB0eXBlLm5hbWUsXG4gICAgICBuYW1lc3BhY2U6IG5hbWVzcGFjZSxcbiAgICAgIG1vZHVsZTogbW9kdWxlTGlrZS5uYW1lLFxuICAgICAgc3VibW9kdWxlOiBtb2R1bGVMaWtlLnN1Ym1vZHVsZSxcbiAgICAgIHN1Ym1vZHVsZVBhdGg6IHN1Ym1vZHVsZVBhdGgoc3VibW9kdWxlKSxcbiAgICAgIHNvdXJjZTogdHlwZSxcbiAgICAgIGxhbmd1YWdlOiB0aGlzLmxhbmd1YWdlLFxuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIGNhbGxhYmxlKGNhbGxhYmxlOiByZWZsZWN0LkNhbGxhYmxlKTogdHJhbnNwaWxlLlRyYW5zcGlsZWRDYWxsYWJsZSB7XG4gICAgY29uc3QgdHlwZSA9IHRoaXMudHlwZShjYWxsYWJsZS5wYXJlbnRUeXBlKTtcbiAgICBjb25zdCBpc0luaXRpYWxpemVyID0gcmVmbGVjdC5Jbml0aWFsaXplci5pc0luaXRpYWxpemVyKGNhbGxhYmxlKTtcbiAgICBjb25zdCBuYW1lID0gaXNJbml0aWFsaXplclxuICAgICAgPyB0eXBlLm5hbWVcbiAgICAgIDogQ2FzZS5wYXNjYWwoY2FsbGFibGUubmFtZSk7XG5cbiAgICBjb25zdCBwYXJhbWV0ZXJzID0gY2FsbGFibGUucGFyYW1ldGVycy5zb3J0KHRoaXMub3B0aW9uYWxpdHlDb21wYXJlKTtcbiAgICBjb25zdCBwYXJhbXNGb3JtYXR0ZWQgPSBwYXJhbWV0ZXJzLm1hcChwID0+IHRoaXMuZm9ybWF0Rm5QYXJhbSh0aGlzLnBhcmFtZXRlcihwKSkpLmpvaW4oJywgJyk7XG4gICAgY29uc3QgcHJlZml4ID0gaXNJbml0aWFsaXplciB8fCBjYWxsYWJsZS5wcm90ZWN0ZWQgPyAncHJvdGVjdGVkJyA6ICdwcml2YXRlJztcblxuICAgIGxldCByZXR1cm5UeXBlOiB0cmFuc3BpbGUuVHJhbnNwaWxlZFR5cGVSZWZlcmVuY2UgfCB1bmRlZmluZWQ7XG4gICAgaWYgKHJlZmxlY3QuSW5pdGlhbGl6ZXIuaXNJbml0aWFsaXplcihjYWxsYWJsZSkpIHtcbiAgICAgIHJldHVyblR5cGUgPSB0aGlzLnR5cGVSZWZlcmVuY2UoY2FsbGFibGUucGFyZW50VHlwZS5yZWZlcmVuY2UpO1xuICAgIH0gZWxzZSBpZiAocmVmbGVjdC5NZXRob2QuaXNNZXRob2QoY2FsbGFibGUpKSB7XG4gICAgICByZXR1cm5UeXBlID0gdGhpcy50eXBlUmVmZXJlbmNlKGNhbGxhYmxlLnJldHVybnMudHlwZSk7XG4gICAgfVxuICAgIGNvbnN0IHJldHVybnMgPSByZXR1cm5UeXBlPy50b1N0cmluZyh7XG4gICAgICB0eXBlRm9ybWF0dGVyOiAodCkgPT4gdC5uYW1lLFxuICAgIH0pO1xuXG4gICAgY29uc3Qgc2lnbmF0dXJlcyA9IFtgJHtwcmVmaXh9ICR7cmV0dXJucyA/IHJldHVybnMgKyAnICcgOiAnJ30ke25hbWV9KCR7cGFyYW1zRm9ybWF0dGVkfSlgXTtcbiAgICBjb25zdCBpbnZvY2F0aW9ucyA9IFtpc0luaXRpYWxpemVyXG4gICAgICA/IGBuZXcgJHtuYW1lfSgke3BhcmFtc0Zvcm1hdHRlZH0pO2BcbiAgICAgIDogYCR7dHlwZS5uYW1lfS4ke25hbWV9KCR7cGFyYW1zRm9ybWF0dGVkfSk7YF07XG5cbiAgICByZXR1cm4ge1xuICAgICAgbmFtZSxcbiAgICAgIHBhcmVudFR5cGU6IHR5cGUsXG4gICAgICBpbXBvcnQ6IHRoaXMuZm9ybWF0SW1wb3J0KHR5cGUpLFxuICAgICAgcGFyYW1ldGVycyxcbiAgICAgIHNpZ25hdHVyZXMsXG4gICAgICBpbnZvY2F0aW9ucyxcbiAgICB9O1xuICB9XG5cbiAgcHVibGljIGNsYXNzKGtsYXNzOiByZWZsZWN0LkNsYXNzVHlwZSk6IHRyYW5zcGlsZS5UcmFuc3BpbGVkQ2xhc3Mge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiBrbGFzcy5uYW1lLFxuICAgICAgdHlwZTogdGhpcy50eXBlKGtsYXNzKSxcbiAgICB9O1xuICB9XG5cbiAgcHVibGljIHN0cnVjdChzdHJ1Y3Q6IHJlZmxlY3QuSW50ZXJmYWNlVHlwZSk6IHRyYW5zcGlsZS5UcmFuc3BpbGVkU3RydWN0IHtcbiAgICBjb25zdCB0eXBlID0gdGhpcy50eXBlKHN0cnVjdCk7XG4gICAgY29uc3QgaW5kZW50ID0gJyAnLnJlcGVhdCg0KTtcbiAgICBjb25zdCBpbnB1dHMgPSBzdHJ1Y3QuYWxsUHJvcGVydGllcy5tYXAoKHApID0+IHtcbiAgICAgIHJldHVybiBgJHtpbmRlbnR9JHt0aGlzLmZvcm1hdEZuUGFyYW0odGhpcy5wcm9wZXJ0eShwKSl9YDtcbiAgICB9KS5mbGF0KCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICBuYW1lOiBzdHJ1Y3QubmFtZSxcbiAgICAgIGltcG9ydDogdGhpcy5mb3JtYXRJbXBvcnQodHlwZSksXG4gICAgICBpbml0aWFsaXphdGlvbjogdGhpcy5mb3JtYXRTdHJ1Y3RCdWlsZGVyKHR5cGUsIGlucHV0cyksXG4gICAgfTtcbiAgfVxuXG4gIHB1YmxpYyBpbnRlcmZhY2UoXG4gICAgaWZhY2U6IHJlZmxlY3QuSW50ZXJmYWNlVHlwZSxcbiAgKTogdHJhbnNwaWxlLlRyYW5zcGlsZWRJbnRlcmZhY2Uge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiBpZmFjZS5uYW1lLFxuICAgICAgdHlwZTogdGhpcy50eXBlKGlmYWNlKSxcbiAgICB9O1xuICB9XG5cbiAgcHVibGljIHBhcmFtZXRlcihcbiAgICBwYXJhbWV0ZXI6IHJlZmxlY3QuUGFyYW1ldGVyLFxuICApOiB0cmFuc3BpbGUuVHJhbnNwaWxlZFBhcmFtZXRlciB7XG4gICAgY29uc3QgdHlwZVJlZiA9IHRoaXMudHlwZVJlZmVyZW5jZShwYXJhbWV0ZXIudHlwZSk7XG4gICAgY29uc3QgbmFtZSA9IENhc2UucGFzY2FsKHBhcmFtZXRlci5uYW1lKTtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZSxcbiAgICAgIHBhcmVudFR5cGU6IHRoaXMudHlwZShwYXJhbWV0ZXIucGFyZW50VHlwZSksXG4gICAgICB0eXBlUmVmZXJlbmNlOiB0eXBlUmVmLFxuICAgICAgb3B0aW9uYWw6IHBhcmFtZXRlci5vcHRpb25hbCxcbiAgICAgIGRlY2xhcmF0aW9uOiB0aGlzLmZvcm1hdFBhcmFtZXRlcihuYW1lLCB0eXBlUmVmKSxcbiAgICB9O1xuICB9XG5cbiAgcHVibGljIHByb3BlcnR5KHByb3BlcnR5OiByZWZsZWN0LlByb3BlcnR5KTogdHJhbnNwaWxlLlRyYW5zcGlsZWRQcm9wZXJ0eSB7XG4gICAgY29uc3QgdHlwZVJlZiA9IHRoaXMudHlwZVJlZmVyZW5jZShwcm9wZXJ0eS50eXBlKTtcbiAgICBjb25zdCBuYW1lID0gQ2FzZS5wYXNjYWwocHJvcGVydHkubmFtZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWUsXG4gICAgICBwYXJlbnRUeXBlOiB0aGlzLnR5cGUocHJvcGVydHkucGFyZW50VHlwZSksXG4gICAgICB0eXBlUmVmZXJlbmNlOiB0eXBlUmVmLFxuICAgICAgb3B0aW9uYWw6IHByb3BlcnR5Lm9wdGlvbmFsLFxuICAgICAgZGVjbGFyYXRpb246IHRoaXMuZm9ybWF0UHJvcGVydHkobmFtZSwgdHlwZVJlZiwgcHJvcGVydHkpLFxuICAgIH07XG4gIH1cblxuICBwdWJsaWMgZW51bShlbnU6IHJlZmxlY3QuRW51bVR5cGUpOiB0cmFuc3BpbGUuVHJhbnNwaWxlZEVudW0ge1xuICAgIHJldHVybiB7XG4gICAgICBmcW46IHRoaXMudHlwZShlbnUpLmZxbixcbiAgICAgIG5hbWU6IGVudS5uYW1lLFxuICAgIH07XG4gIH1cblxuICBwdWJsaWMgZW51bU1lbWJlcihlbTogcmVmbGVjdC5FbnVtTWVtYmVyKTogdHJhbnNwaWxlLlRyYW5zcGlsZWRFbnVtTWVtYmVyIHtcbiAgICByZXR1cm4ge1xuICAgICAgZnFuOiBgJHt0aGlzLmVudW0oZW0uZW51bVR5cGUpLmZxbn0uJHtlbS5uYW1lfWAsXG4gICAgICBuYW1lOiBlbS5uYW1lLFxuICAgIH07XG4gIH1cblxuICBwdWJsaWMgdW5pb25PZigpOiBzdHJpbmcge1xuICAgIHJldHVybiAnb2JqZWN0JztcbiAgfVxuXG4gIHB1YmxpYyBsaXN0T2YodHlwZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gYCR7dHlwZX1bXWA7XG4gIH1cblxuICBwdWJsaWMgbWFwT2YodHlwZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gYFN5c3RlbS5Db2xsZWN0aW9ucy5HZW5lcmljLklEaWN0aW9uYXJ5PHN0cmluZywgJHt0eXBlfT5gO1xuICB9XG5cbiAgcHVibGljIGFueSgpOiBzdHJpbmcge1xuICAgIHJldHVybiAnb2JqZWN0JztcbiAgfVxuXG4gIHB1YmxpYyB2b2lkKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuICd2b2lkJztcbiAgfVxuXG4gIHB1YmxpYyBzdHIoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gJ3N0cmluZyc7XG4gIH1cblxuICBwdWJsaWMgbnVtYmVyKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuICdkb3VibGUnO1xuICB9XG5cbiAgcHVibGljIGJvb2xlYW4oKTogc3RyaW5nIHtcbiAgICByZXR1cm4gJ2Jvb2wnO1xuICB9XG5cbiAgcHVibGljIGpzb24oKTogc3RyaW5nIHtcbiAgICByZXR1cm4gJ05ld3RvbnNvZnQuSnNvbi5MaW5xLkpPYmplY3QnO1xuICB9XG5cbiAgcHVibGljIGRhdGUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gJ1N5c3RlbS5EYXRlVGltZSc7XG4gIH1cblxuICBwdWJsaWMgcmVhZG1lKHJlYWRtZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gcmVhZG1lO1xuICB9XG5cbiAgcHJpdmF0ZSBmb3JtYXRJbXBvcnQodHlwZTogdHJhbnNwaWxlLlRyYW5zcGlsZWRUeXBlKTogc3RyaW5nIHtcbiAgICByZXR1cm4gYHVzaW5nICR7dHlwZS5tb2R1bGV9O2A7XG4gIH1cblxuICBwcml2YXRlIGZvcm1hdEZuUGFyYW0oXG4gICAgdHJhbnNwaWxlZDogdHJhbnNwaWxlLlRyYW5zcGlsZWRQYXJhbWV0ZXIgfCB0cmFuc3BpbGUuVHJhbnNwaWxlZFByb3BlcnR5LFxuICApOiBzdHJpbmcge1xuICAgIGNvbnN0IHRmID0gdHJhbnNwaWxlZC50eXBlUmVmZXJlbmNlLnRvU3RyaW5nKHtcbiAgICAgIHR5cGVGb3JtYXR0ZXI6ICh0KSA9PiB0Lm5hbWUsXG4gICAgfSk7XG4gICAgY29uc3Qgc3VmZml4ID0gdHJhbnNwaWxlZC5vcHRpb25hbCA/ICcgPSBudWxsJyA6ICcnO1xuICAgIHJldHVybiBgJHt0Zn0gJHt0cmFuc3BpbGVkLm5hbWV9JHtzdWZmaXh9YDtcbiAgfVxuXG4gIHByaXZhdGUgZm9ybWF0U3RydWN0QnVpbGRlcih0eXBlOiB0cmFuc3BpbGUuVHJhbnNwaWxlZFR5cGUsIHByb3BlcnRpZXM6IHN0cmluZ1tdKTogc3RyaW5nIHtcbiAgICBjb25zdCBidWlsZGVyID0gYG5ldyAke3R5cGUubmFtZX0ge2A7XG4gICAgcmV0dXJuIFtcbiAgICAgIGJ1aWxkZXIsXG4gICAgICBwcm9wZXJ0aWVzLmpvaW4oJyxcXG4nKSxcbiAgICAgICd9OycsXG4gICAgXS5qb2luKCdcXG4nKTtcbiAgfTtcblxuICBwcml2YXRlIGZvcm1hdFBhcmFtZXRlcihuYW1lOiBzdHJpbmcsIHR5cGVSZWZlcmVuY2U6IHRyYW5zcGlsZS5UcmFuc3BpbGVkVHlwZVJlZmVyZW5jZSkge1xuICAgIGNvbnN0IHRmID0gdHlwZVJlZmVyZW5jZS50b1N0cmluZyh7XG4gICAgICB0eXBlRm9ybWF0dGVyOiAodCkgPT4gdC5uYW1lLFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGBwdWJsaWMgJHt0Zn0gJHtuYW1lfWA7XG4gIH1cblxuICBwcml2YXRlIGZvcm1hdFByb3BlcnR5KFxuICAgIG5hbWU6IHN0cmluZyxcbiAgICB0eXBlUmVmZXJlbmNlOiB0cmFuc3BpbGUuVHJhbnNwaWxlZFR5cGVSZWZlcmVuY2UsXG4gICAgcHJvcGVydHk6IHJlZmxlY3QuUHJvcGVydHksXG4gICk6IHN0cmluZyB7XG4gICAgY29uc3QgdGYgPSB0eXBlUmVmZXJlbmNlLnRvU3RyaW5nKHtcbiAgICAgIHR5cGVGb3JtYXR0ZXI6ICh0KSA9PiB0Lm5hbWUsXG4gICAgfSk7XG5cbiAgICBjb25zdCBwcmVmaXggPSBwcm9wZXJ0eS5wcm90ZWN0ZWQgPyAncHJvdGVjdGVkJyA6ICdwdWJsaWMnO1xuICAgIC8vIHNldHRlcnMgYXJlIGFsd2F5cyBhdmFpbGFibGUgb24gc3RydWN0IHByb3BlcnRpZXNcbiAgICBjb25zdCBoYXNTZXR0ZXIgPSBwcm9wZXJ0eS5wYXJlbnRUeXBlLmlzRGF0YVR5cGUoKSB8fCAoIXByb3BlcnR5LmltbXV0YWJsZSAmJiBwcm9wZXJ0eS5hYnN0cmFjdCk7XG4gICAgY29uc3Qgc3VmZml4ID0gaGFzU2V0dGVyID8gJ3sgZ2V0OyBzZXQ7IH0nIDogJ3sgZ2V0OyB9JztcbiAgICByZXR1cm4gYCR7cHJlZml4fSAke3RmfSAke25hbWV9ICR7c3VmZml4fWA7XG4gIH1cbn1cbiJdfQ==