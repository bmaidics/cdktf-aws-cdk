"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PythonTranspile = void 0;
const Case = __importStar(require("case"));
const reflect = __importStar(require("jsii-reflect"));
const transpile = __importStar(require("./transpile"));
const errors_1 = require("../../errors");
const schema_1 = require("../schema");
// Helpers
const toSnakeCase = (text) => {
    return Case.snake(text !== null && text !== void 0 ? text : '');
};
const formatImport = (type) => {
    if (type.submodule) {
        return `from ${type.module} import ${type.submodule}`;
    }
    return `import ${type.module}`;
};
const formatArguments = (inputs) => {
    return inputs.length === 0 ? '()' : [
        '(',
        inputs.map(i => `  ${i}`).join(',\n'),
        ')',
    ].join('\n');
};
const formatInvocation = (type, inputs, method) => {
    let target;
    if (type.submodule) {
        if (!type.namespace) {
            throw new Error(`Invalid type: ${type.fqn}: Types defined in a submodule (${type.submodule}) must have a namespace. `);
        }
        // we don't include the submodule name here since it is
        // included in the namespace. this works because we import the submodule
        // in this case.
        // TODO - merge `formatInvocation` with `formatImport` since they are inherently coupled.
        target = `${type.namespace}.${type.name}`;
    }
    else {
        target = type.fqn;
    }
    if (method) {
        target = `${target}.${method}`;
    }
    return `${target}${formatArguments(inputs)}`;
};
const formatSignature = (name, inputs, returns) => {
    const def = 'def ';
    return `${def}${name}${formatArguments(inputs)} -> ${returns || 'None'}`;
};
/**
 * Hack to convert a jsii property to a parameter for
 * python specific parameter expansion.
 */
const propertyToParameter = (callable, property) => {
    return {
        docs: property.docs,
        method: callable,
        name: property.name,
        optional: property.optional,
        parentType: callable.parentType,
        spec: property.spec,
        system: property.system,
        type: property.type,
        variadic: false,
    };
};
/**
 * A python transpiler.
 */
class PythonTranspile extends transpile.TranspileBase {
    constructor() {
        super(transpile.Language.PYTHON);
    }
    readme(readme) {
        return readme;
    }
    unionOf(types) {
        return `${this.typing('Union')}[${types.join(', ')}]`;
    }
    listOf(type) {
        return `${this.typing('List')}[${type}]`;
    }
    mapOf(type) {
        return `${this.typing('Mapping')}[${type}]`;
    }
    any() {
        return this.typing('Any');
    }
    void() {
        return 'None';
    }
    boolean() {
        return 'bool';
    }
    str() {
        return 'str';
    }
    number() {
        return `${this.typing('Union')}[int, float]`;
    }
    date() {
        return 'datetime.datetime';
    }
    enum(enu) {
        return {
            fqn: this.type(enu).fqn,
            name: enu.name,
        };
    }
    enumMember(em) {
        return {
            fqn: `${this.enum(em.enumType).fqn}.${em.name}`,
            name: em.name,
        };
    }
    json() {
        return 'any';
    }
    property(property) {
        const name = property.const ? property.name : toSnakeCase(property.name);
        const typeRef = this.typeReference(property.type);
        return {
            name,
            parentType: this.type(property.parentType),
            typeReference: typeRef,
            optional: property.optional,
            declaration: this.formatProperty(name, typeRef),
        };
    }
    class(klass) {
        return {
            name: klass.name,
            type: this.type(klass),
        };
    }
    parameter(parameter) {
        const name = toSnakeCase(parameter.name);
        const typeRef = this.typeReference(parameter.type);
        return {
            name,
            parentType: this.type(parameter.parentType),
            typeReference: typeRef,
            optional: parameter.optional,
            declaration: this.formatProperty(name, typeRef),
        };
    }
    struct(struct) {
        const type = this.type(struct);
        const inputs = struct.allProperties.map((p) => this.formatParameters(this.property(p)));
        return {
            type: type,
            name: struct.name,
            import: formatImport(type),
            initialization: formatInvocation(type, inputs),
        };
    }
    callable(callable) {
        const type = this.type(callable.parentType);
        const parameters = new Array();
        for (const p of callable.parameters.sort(this.optionalityCompare)) {
            if (!this.isStruct(p)) {
                parameters.push(p);
            }
            else {
                // struct parameters are expanded to the individual struct properties
                const struct = p.parentType.system.findInterface(p.type.fqn);
                for (const property of struct.allProperties) {
                    const parameter = propertyToParameter(callable, property);
                    parameters.push(parameter);
                }
            }
        }
        const name = toSnakeCase(callable.name);
        const inputs = parameters.map((p) => this.formatParameters(this.parameter(p)));
        let returnType;
        if (reflect.Initializer.isInitializer(callable)) {
            returnType = this.typeReference(callable.parentType.reference);
        }
        else if (reflect.Method.isMethod(callable)) {
            returnType = this.typeReference(callable.returns.type);
        }
        const returns = returnType === null || returnType === void 0 ? void 0 : returnType.toString({
            typeFormatter: (t) => t.name,
        });
        return {
            name,
            parentType: type,
            import: formatImport(type),
            parameters,
            signatures: [formatSignature(name, inputs, returns)],
            invocations: [formatInvocation(type, inputs, callable.kind === reflect.MemberKind.Initializer ? undefined : name)],
        };
    }
    type(type) {
        const submodule = this.findSubmodule(type);
        const moduleLike = this.moduleLike(submodule ? submodule : type.assembly);
        const fqn = [moduleLike.name];
        if (type.namespace) {
            fqn.push(type.namespace);
        }
        fqn.push(type.name);
        return new transpile.TranspiledType({
            fqn: fqn.join('.'),
            name: type.name,
            namespace: type.namespace,
            module: moduleLike.name,
            submodule: moduleLike.submodule,
            submodulePath: (0, schema_1.submodulePath)(submodule),
            source: type,
            language: this.language,
        });
    }
    moduleLike(moduleLike) {
        var _a, _b, _c, _d;
        const pythonModule = (_b = (_a = moduleLike.targets) === null || _a === void 0 ? void 0 : _a.python) === null || _b === void 0 ? void 0 : _b.module;
        if (moduleLike instanceof reflect.Submodule) {
            const assembly = this.getParentModule(moduleLike);
            const parentPythonModule = (_d = (_c = assembly.targets) === null || _c === void 0 ? void 0 : _c.python) === null || _d === void 0 ? void 0 : _d.module;
            // if the submodule does not explicitly defines the python module name, then
            // append a snake case version of the submodule name to the parent module name
            // see https://github.com/aws/jsii/blob/b329670bf9ec222fad5fc0d614dcddd5daca7af5/packages/jsii-pacmak/lib/targets/python/type-name.ts#L455
            const submodulePythonModule = pythonModule !== null && pythonModule !== void 0 ? pythonModule : `${parentPythonModule}.${Case.snake(moduleLike.name)}`;
            const moduleParts = submodulePythonModule.split('.');
            return { name: moduleParts[0], submodule: moduleParts[1] };
        }
        if (!pythonModule) {
            throw new errors_1.LanguageNotSupportedError(`Python is not a supported target for module: ${moduleLike.fqn}`);
        }
        return { name: pythonModule };
    }
    interface(iface) {
        return {
            name: iface.name,
            type: this.type(iface),
        };
    }
    isStruct(p) {
        return p.type.fqn ? p.system.findFqn(p.type.fqn).isDataType() : false;
    }
    typing(type) {
        return `typing.${type}`;
    }
    formatParameters(transpiled) {
        const tf = transpiled.typeReference.toString({
            typeFormatter: (t) => t.name,
        });
        return `${transpiled.name}: ${tf}${transpiled.optional ? ' = None' : ''}`;
    }
    formatProperty(name, typeReference) {
        const tf = typeReference.toString({
            typeFormatter: (t) => t.name,
        });
        return `${name}: ${tf}`;
    }
}
exports.PythonTranspile = PythonTranspile;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHl0aG9uLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2RvY2dlbi90cmFuc3BpbGUvcHl0aG9uLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsMkNBQTZCO0FBQzdCLHNEQUF3QztBQUN4Qyx1REFBeUM7QUFDekMseUNBQXlEO0FBQ3pELHNDQUEwQztBQUUxQyxVQUFVO0FBQ1YsTUFBTSxXQUFXLEdBQUcsQ0FBQyxJQUFhLEVBQUUsRUFBRTtJQUNwQyxPQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxhQUFKLElBQUksY0FBSixJQUFJLEdBQUksRUFBRSxDQUFDLENBQUM7QUFDaEMsQ0FBQyxDQUFDO0FBRUYsTUFBTSxZQUFZLEdBQUcsQ0FBQyxJQUE4QixFQUFFLEVBQUU7SUFDdEQsSUFBSSxJQUFJLENBQUMsU0FBUyxFQUFFLENBQUM7UUFDbkIsT0FBTyxRQUFRLElBQUksQ0FBQyxNQUFNLFdBQVcsSUFBSSxDQUFDLFNBQVMsRUFBRSxDQUFDO0lBQ3hELENBQUM7SUFDRCxPQUFPLFVBQVUsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDO0FBQ2pDLENBQUMsQ0FBQztBQUVGLE1BQU0sZUFBZSxHQUFHLENBQUMsTUFBZ0IsRUFBRSxFQUFFO0lBQzNDLE9BQU8sTUFBTSxDQUFDLE1BQU0sS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7UUFDbEMsR0FBRztRQUNILE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQztRQUNyQyxHQUFHO0tBQ0osQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDZixDQUFDLENBQUM7QUFFRixNQUFNLGdCQUFnQixHQUFHLENBQ3ZCLElBQThCLEVBQzlCLE1BQWdCLEVBQ2hCLE1BQWUsRUFDZixF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QUNwQixJQUFZLEVBQ1osYUFBZ0Q7UUFFaEQsTUFBTSxFQUFFLEdBQUcsYUFBYSxDQUFDLFFBQVEsQ0FBQztZQUNoQyxhQUFhLEVBQUUsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJO1NBQzdCLENBQUMsQ0FBQztRQUNILE9BQU8sR0FBRyxJQUFJLEtBQUssRUFBRSxFQUFFLENBQUM7SUFDMUIsQ0FBQztDQUNGO0FBOU9ELDBDQThPQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIENhc2UgZnJvbSAnY2FzZSc7XG5pbXBvcnQgKiBhcyByZWZsZWN0IGZyb20gJ2pzaWktcmVmbGVjdCc7XG5pbXBvcnQgKiBhcyB0cmFuc3BpbGUgZnJvbSAnLi90cmFuc3BpbGUnO1xuaW1wb3J0IHsgTGFuZ3VhZ2VOb3RTdXBwb3J0ZWRFcnJvciB9IGZyb20gJy4uLy4uL2Vycm9ycyc7XG5pbXBvcnQgeyBzdWJtb2R1bGVQYXRoIH0gZnJvbSAnLi4vc2NoZW1hJztcblxuLy8gSGVscGVyc1xuY29uc3QgdG9TbmFrZUNhc2UgPSAodGV4dD86IHN0cmluZykgPT4ge1xuICByZXR1cm4gQ2FzZS5zbmFrZSh0ZXh0ID8/ICcnKTtcbn07XG5cbmNvbnN0IGZvcm1hdEltcG9ydCA9ICh0eXBlOiB0cmFuc3BpbGUuVHJhbnNwaWxlZFR5cGUpID0+IHtcbiAgaWYgKHR5cGUuc3VibW9kdWxlKSB7XG4gICAgcmV0dXJuIGBmcm9tICR7dHlwZS5tb2R1bGV9IGltcG9ydCAke3R5cGUuc3VibW9kdWxlfWA7XG4gIH1cbiAgcmV0dXJuIGBpbXBvcnQgJHt0eXBlLm1vZHVsZX1gO1xufTtcblxuY29uc3QgZm9ybWF0QXJndW1lbnRzID0gKGlucHV0czogc3RyaW5nW10pID0+IHtcbiAgcmV0dXJuIGlucHV0cy5sZW5ndGggPT09IDAgPyAnKCknIDogW1xuICAgICcoJyxcbiAgICBpbnB1dHMubWFwKGkgPT4gYCAgJHtpfWApLmpvaW4oJyxcXG4nKSxcbiAgICAnKScsXG4gIF0uam9pbignXFxuJyk7XG59O1xuXG5jb25zdCBmb3JtYXRJbnZvY2F0aW9uID0gKFxuICB0eXBlOiB0cmFuc3BpbGUuVHJhbnNwaWxlZFR5cGUsXG4gIGlucHV0czogc3RyaW5nW10sXG4gIG1ldGhvZD86IHN0cmluZyxcbikgPT4ge1xuICBsZXQgdGFyZ2V0O1xuICBpZiAodHlwZS5zdWJtb2R1bGUpIHtcbiAgICBpZiAoIXR5cGUubmFtZXNwYWNlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBJbnZhbGlkIHR5cGU6ICR7dHlwZS5mcW59OiBUeXBlcyBkZWZpbmVkIGluIGEgc3VibW9kdWxlICgke3R5cGUuc3VibW9kdWxlfSkgbXVzdCBoYXZlIGEgbmFtZXNwYWNlLiBgLFxuICAgICAgKTtcbiAgICB9XG4gICAgLy8gd2UgZG9uJ3QgaW5jbHVkZSB0aGUgc3VibW9kdWxlIG5hbWUgaGVyZSBzaW5jZSBpdCBpc1xuICAgIC8vIGluY2x1ZGVkIGluIHRoZSBuYW1lc3BhY2UuIHRoaXMgd29ya3MgYmVjYXVzZSB3ZSBpbXBvcnQgdGhlIHN1Ym1vZHVsZVxuICAgIC8vIGluIHRoaXMgY2FzZS5cbiAgICAvLyBUT0RPIC0gbWVyZ2UgYGZvcm1hdEludm9jYXRpb25gIHdpdGggYGZvcm1hdEltcG9ydGAgc2luY2UgdGhleSBhcmUgaW5oZXJlbnRseSBjb3VwbGVkLlxuICAgIHRhcmdldCA9IGAke3R5cGUubmFtZXNwYWNlfS4ke3R5cGUubmFtZX1gO1xuICB9IGVsc2Uge1xuICAgIHRhcmdldCA9IHR5cGUuZnFuO1xuICB9XG5cbiAgaWYgKG1ldGhvZCkge1xuICAgIHRhcmdldCA9IGAke3RhcmdldH0uJHttZXRob2R9YDtcbiAgfVxuICByZXR1cm4gYCR7dGFyZ2V0fSR7Zm9ybWF0QXJndW1lbnRzKGlucHV0cyl9YDtcbn07XG5cbmNvbnN0IGZvcm1hdFNpZ25hdHVyZSA9IChuYW1lOiBzdHJpbmcsIGlucHV0czogc3RyaW5nW10sIHJldHVybnM/OiBzdHJpbmcpID0+IHtcbiAgY29uc3QgZGVmID0gJ2RlZiAnO1xuICByZXR1cm4gYCR7ZGVmfSR7bmFtZX0ke2Zvcm1hdEFyZ3VtZW50cyhpbnB1dHMpfSAtPiAke3JldHVybnMgfHwgJ05vbmUnfWA7XG59O1xuXG4vKipcbiAqIEhhY2sgdG8gY29udmVydCBhIGpzaWkgcHJvcGVydHkgdG8gYSBwYXJhbWV0ZXIgZm9yXG4gKiBweXRob24gc3BlY2lmaWMgcGFyYW1ldGVyIGV4cGFuc2lvbi5cbiAqL1xuY29uc3QgcHJvcGVydHlUb1BhcmFtZXRlciA9IChcbiAgY2FsbGFibGU6IHJlZmxlY3QuQ2FsbGFibGUsXG4gIHByb3BlcnR5OiByZWZsZWN0LlByb3BlcnR5LFxuKTogcmVmbGVjdC5QYXJhbWV0ZXIgPT4ge1xuICByZXR1cm4ge1xuICAgIGRvY3M6IHByb3BlcnR5LmRvY3MsXG4gICAgbWV0aG9kOiBjYWxsYWJsZSxcbiAgICBuYW1lOiBwcm9wZXJ0eS5uYW1lLFxuICAgIG9wdGlvbmFsOiBwcm9wZXJ0eS5vcHRpb25hbCxcbiAgICBwYXJlbnRUeXBlOiBjYWxsYWJsZS5wYXJlbnRUeXBlLFxuICAgIHNwZWM6IHByb3BlcnR5LnNwZWMsXG4gICAgc3lzdGVtOiBwcm9wZXJ0eS5zeXN0ZW0sXG4gICAgdHlwZTogcHJvcGVydHkudHlwZSxcbiAgICB2YXJpYWRpYzogZmFsc2UsXG4gIH07XG59O1xuXG4vKipcbiAqIEEgcHl0aG9uIHRyYW5zcGlsZXIuXG4gKi9cbmV4cG9ydCBjbGFzcyBQeXRob25UcmFuc3BpbGUgZXh0ZW5kcyB0cmFuc3BpbGUuVHJhbnNwaWxlQmFzZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKHRyYW5zcGlsZS5MYW5ndWFnZS5QWVRIT04pO1xuICB9XG5cbiAgcHVibGljIHJlYWRtZShyZWFkbWU6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHJlYWRtZTtcbiAgfVxuXG4gIHB1YmxpYyB1bmlvbk9mKHR5cGVzOiBzdHJpbmdbXSk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGAke3RoaXMudHlwaW5nKCdVbmlvbicpfVske3R5cGVzLmpvaW4oJywgJyl9XWA7XG4gIH1cblxuICBwdWJsaWMgbGlzdE9mKHR5cGU6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGAke3RoaXMudHlwaW5nKCdMaXN0Jyl9WyR7dHlwZX1dYDtcbiAgfVxuXG4gIHB1YmxpYyBtYXBPZih0eXBlOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHJldHVybiBgJHt0aGlzLnR5cGluZygnTWFwcGluZycpfVske3R5cGV9XWA7XG4gIH1cblxuICBwdWJsaWMgYW55KCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMudHlwaW5nKCdBbnknKTtcbiAgfVxuXG4gIHB1YmxpYyB2b2lkKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuICdOb25lJztcbiAgfVxuXG4gIHB1YmxpYyBib29sZWFuKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuICdib29sJztcbiAgfVxuXG4gIHB1YmxpYyBzdHIoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gJ3N0cic7XG4gIH1cblxuICBwdWJsaWMgbnVtYmVyKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGAke3RoaXMudHlwaW5nKCdVbmlvbicpfVtpbnQsIGZsb2F0XWA7XG4gIH1cblxuICBwdWJsaWMgZGF0ZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiAnZGF0ZXRpbWUuZGF0ZXRpbWUnO1xuICB9XG5cbiAgcHVibGljIGVudW0oZW51OiByZWZsZWN0LkVudW1UeXBlKTogdHJhbnNwaWxlLlRyYW5zcGlsZWRFbnVtIHtcbiAgICByZXR1cm4ge1xuICAgICAgZnFuOiB0aGlzLnR5cGUoZW51KS5mcW4sXG4gICAgICBuYW1lOiBlbnUubmFtZSxcbiAgICB9O1xuICB9XG5cbiAgcHVibGljIGVudW1NZW1iZXIoZW06IHJlZmxlY3QuRW51bU1lbWJlcik6IHRyYW5zcGlsZS5UcmFuc3BpbGVkRW51bU1lbWJlciB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZxbjogYCR7dGhpcy5lbnVtKGVtLmVudW1UeXBlKS5mcW59LiR7ZW0ubmFtZX1gLFxuICAgICAgbmFtZTogZW0ubmFtZSxcbiAgICB9O1xuICB9XG4gIHB1YmxpYyBqc29uKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuICdhbnknO1xuICB9XG5cbiAgcHVibGljIHByb3BlcnR5KHByb3BlcnR5OiByZWZsZWN0LlByb3BlcnR5KTogdHJhbnNwaWxlLlRyYW5zcGlsZWRQcm9wZXJ0eSB7XG4gICAgY29uc3QgbmFtZSA9IHByb3BlcnR5LmNvbnN0ID8gcHJvcGVydHkubmFtZSA6IHRvU25ha2VDYXNlKHByb3BlcnR5Lm5hbWUpO1xuICAgIGNvbnN0IHR5cGVSZWYgPSB0aGlzLnR5cGVSZWZlcmVuY2UocHJvcGVydHkudHlwZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWUsXG4gICAgICBwYXJlbnRUeXBlOiB0aGlzLnR5cGUocHJvcGVydHkucGFyZW50VHlwZSksXG4gICAgICB0eXBlUmVmZXJlbmNlOiB0eXBlUmVmLFxuICAgICAgb3B0aW9uYWw6IHByb3BlcnR5Lm9wdGlvbmFsLFxuICAgICAgZGVjbGFyYXRpb246IHRoaXMuZm9ybWF0UHJvcGVydHkobmFtZSwgdHlwZVJlZiksXG4gICAgfTtcbiAgfVxuXG4gIHB1YmxpYyBjbGFzcyhrbGFzczogcmVmbGVjdC5DbGFzc1R5cGUpOiB0cmFuc3BpbGUuVHJhbnNwaWxlZENsYXNzIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZToga2xhc3MubmFtZSxcbiAgICAgIHR5cGU6IHRoaXMudHlwZShrbGFzcyksXG4gICAgfTtcbiAgfVxuXG4gIHB1YmxpYyBwYXJhbWV0ZXIoXG4gICAgcGFyYW1ldGVyOiByZWZsZWN0LlBhcmFtZXRlcixcbiAgKTogdHJhbnNwaWxlLlRyYW5zcGlsZWRQYXJhbWV0ZXIge1xuICAgIGNvbnN0IG5hbWUgPSB0b1NuYWtlQ2FzZShwYXJhbWV0ZXIubmFtZSk7XG4gICAgY29uc3QgdHlwZVJlZiA9IHRoaXMudHlwZVJlZmVyZW5jZShwYXJhbWV0ZXIudHlwZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWUsXG4gICAgICBwYXJlbnRUeXBlOiB0aGlzLnR5cGUocGFyYW1ldGVyLnBhcmVudFR5cGUpLFxuICAgICAgdHlwZVJlZmVyZW5jZTogdHlwZVJlZixcbiAgICAgIG9wdGlvbmFsOiBwYXJhbWV0ZXIub3B0aW9uYWwsXG4gICAgICBkZWNsYXJhdGlvbjogdGhpcy5mb3JtYXRQcm9wZXJ0eShuYW1lLCB0eXBlUmVmKSxcbiAgICB9O1xuICB9XG5cbiAgcHVibGljIHN0cnVjdChzdHJ1Y3Q6IHJlZmxlY3QuSW50ZXJmYWNlVHlwZSk6IHRyYW5zcGlsZS5UcmFuc3BpbGVkU3RydWN0IHtcbiAgICBjb25zdCB0eXBlID0gdGhpcy50eXBlKHN0cnVjdCk7XG4gICAgY29uc3QgaW5wdXRzID0gc3RydWN0LmFsbFByb3BlcnRpZXMubWFwKChwKSA9PlxuICAgICAgdGhpcy5mb3JtYXRQYXJhbWV0ZXJzKHRoaXMucHJvcGVydHkocCkpLFxuICAgICk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICBuYW1lOiBzdHJ1Y3QubmFtZSxcbiAgICAgIGltcG9ydDogZm9ybWF0SW1wb3J0KHR5cGUpLFxuICAgICAgaW5pdGlhbGl6YXRpb246IGZvcm1hdEludm9jYXRpb24odHlwZSwgaW5wdXRzKSxcbiAgICB9O1xuICB9XG5cbiAgcHVibGljIGNhbGxhYmxlKGNhbGxhYmxlOiByZWZsZWN0LkNhbGxhYmxlKTogdHJhbnNwaWxlLlRyYW5zcGlsZWRDYWxsYWJsZSB7XG4gICAgY29uc3QgdHlwZSA9IHRoaXMudHlwZShjYWxsYWJsZS5wYXJlbnRUeXBlKTtcblxuICAgIGNvbnN0IHBhcmFtZXRlcnMgPSBuZXcgQXJyYXk8cmVmbGVjdC5QYXJhbWV0ZXI+KCk7XG5cbiAgICBmb3IgKGNvbnN0IHAgb2YgY2FsbGFibGUucGFyYW1ldGVycy5zb3J0KHRoaXMub3B0aW9uYWxpdHlDb21wYXJlKSkge1xuICAgICAgaWYgKCF0aGlzLmlzU3RydWN0KHApKSB7XG4gICAgICAgIHBhcmFtZXRlcnMucHVzaChwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHN0cnVjdCBwYXJhbWV0ZXJzIGFyZSBleHBhbmRlZCB0byB0aGUgaW5kaXZpZHVhbCBzdHJ1Y3QgcHJvcGVydGllc1xuICAgICAgICBjb25zdCBzdHJ1Y3QgPSBwLnBhcmVudFR5cGUuc3lzdGVtLmZpbmRJbnRlcmZhY2UocC50eXBlLmZxbiEpO1xuICAgICAgICBmb3IgKGNvbnN0IHByb3BlcnR5IG9mIHN0cnVjdC5hbGxQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgY29uc3QgcGFyYW1ldGVyID0gcHJvcGVydHlUb1BhcmFtZXRlcihjYWxsYWJsZSwgcHJvcGVydHkpO1xuICAgICAgICAgIHBhcmFtZXRlcnMucHVzaChwYXJhbWV0ZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgbmFtZSA9IHRvU25ha2VDYXNlKGNhbGxhYmxlLm5hbWUpO1xuICAgIGNvbnN0IGlucHV0cyA9IHBhcmFtZXRlcnMubWFwKChwKSA9PiB0aGlzLmZvcm1hdFBhcmFtZXRlcnModGhpcy5wYXJhbWV0ZXIocCkpKTtcblxuICAgIGxldCByZXR1cm5UeXBlOiB0cmFuc3BpbGUuVHJhbnNwaWxlZFR5cGVSZWZlcmVuY2UgfCB1bmRlZmluZWQ7XG4gICAgaWYgKHJlZmxlY3QuSW5pdGlhbGl6ZXIuaXNJbml0aWFsaXplcihjYWxsYWJsZSkpIHtcbiAgICAgIHJldHVyblR5cGUgPSB0aGlzLnR5cGVSZWZlcmVuY2UoY2FsbGFibGUucGFyZW50VHlwZS5yZWZlcmVuY2UpO1xuICAgIH0gZWxzZSBpZiAocmVmbGVjdC5NZXRob2QuaXNNZXRob2QoY2FsbGFibGUpKSB7XG4gICAgICByZXR1cm5UeXBlID0gdGhpcy50eXBlUmVmZXJlbmNlKGNhbGxhYmxlLnJldHVybnMudHlwZSk7XG4gICAgfVxuICAgIGNvbnN0IHJldHVybnMgPSByZXR1cm5UeXBlPy50b1N0cmluZyh7XG4gICAgICB0eXBlRm9ybWF0dGVyOiAodCkgPT4gdC5uYW1lLFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWUsXG4gICAgICBwYXJlbnRUeXBlOiB0eXBlLFxuICAgICAgaW1wb3J0OiBmb3JtYXRJbXBvcnQodHlwZSksXG4gICAgICBwYXJhbWV0ZXJzLFxuICAgICAgc2lnbmF0dXJlczogW2Zvcm1hdFNpZ25hdHVyZShuYW1lLCBpbnB1dHMsIHJldHVybnMpXSxcbiAgICAgIGludm9jYXRpb25zOiBbZm9ybWF0SW52b2NhdGlvbihcbiAgICAgICAgdHlwZSxcbiAgICAgICAgaW5wdXRzLFxuICAgICAgICBjYWxsYWJsZS5raW5kID09PSByZWZsZWN0Lk1lbWJlcktpbmQuSW5pdGlhbGl6ZXIgPyB1bmRlZmluZWQgOiBuYW1lLFxuICAgICAgKV0sXG4gICAgfTtcbiAgfVxuXG4gIHB1YmxpYyB0eXBlKHR5cGU6IHJlZmxlY3QuVHlwZSk6IHRyYW5zcGlsZS5UcmFuc3BpbGVkVHlwZSB7XG4gICAgY29uc3Qgc3VibW9kdWxlID0gdGhpcy5maW5kU3VibW9kdWxlKHR5cGUpO1xuICAgIGNvbnN0IG1vZHVsZUxpa2UgPSB0aGlzLm1vZHVsZUxpa2Uoc3VibW9kdWxlID8gc3VibW9kdWxlIDogdHlwZS5hc3NlbWJseSk7XG5cbiAgICBjb25zdCBmcW4gPSBbbW9kdWxlTGlrZS5uYW1lXTtcblxuICAgIGlmICh0eXBlLm5hbWVzcGFjZSkge1xuICAgICAgZnFuLnB1c2godHlwZS5uYW1lc3BhY2UpO1xuICAgIH1cbiAgICBmcW4ucHVzaCh0eXBlLm5hbWUpO1xuXG4gICAgcmV0dXJuIG5ldyB0cmFuc3BpbGUuVHJhbnNwaWxlZFR5cGUoe1xuICAgICAgZnFuOiBmcW4uam9pbignLicpLFxuICAgICAgbmFtZTogdHlwZS5uYW1lLFxuICAgICAgbmFtZXNwYWNlOiB0eXBlLm5hbWVzcGFjZSxcbiAgICAgIG1vZHVsZTogbW9kdWxlTGlrZS5uYW1lLFxuICAgICAgc3VibW9kdWxlOiBtb2R1bGVMaWtlLnN1Ym1vZHVsZSxcbiAgICAgIHN1Ym1vZHVsZVBhdGg6IHN1Ym1vZHVsZVBhdGgoc3VibW9kdWxlKSxcbiAgICAgIHNvdXJjZTogdHlwZSxcbiAgICAgIGxhbmd1YWdlOiB0aGlzLmxhbmd1YWdlLFxuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIG1vZHVsZUxpa2UoXG4gICAgbW9kdWxlTGlrZTogcmVmbGVjdC5Nb2R1bGVMaWtlLFxuICApOiB0cmFuc3BpbGUuVHJhbnNwaWxlZE1vZHVsZUxpa2Uge1xuICAgIGNvbnN0IHB5dGhvbk1vZHVsZSA9IG1vZHVsZUxpa2UudGFyZ2V0cz8ucHl0aG9uPy5tb2R1bGU7XG5cbiAgICBpZiAobW9kdWxlTGlrZSBpbnN0YW5jZW9mIHJlZmxlY3QuU3VibW9kdWxlKSB7XG4gICAgICBjb25zdCBhc3NlbWJseSA9IHRoaXMuZ2V0UGFyZW50TW9kdWxlKG1vZHVsZUxpa2UpO1xuICAgICAgY29uc3QgcGFyZW50UHl0aG9uTW9kdWxlID0gYXNzZW1ibHkudGFyZ2V0cz8ucHl0aG9uPy5tb2R1bGU7XG5cbiAgICAgIC8vIGlmIHRoZSBzdWJtb2R1bGUgZG9lcyBub3QgZXhwbGljaXRseSBkZWZpbmVzIHRoZSBweXRob24gbW9kdWxlIG5hbWUsIHRoZW5cbiAgICAgIC8vIGFwcGVuZCBhIHNuYWtlIGNhc2UgdmVyc2lvbiBvZiB0aGUgc3VibW9kdWxlIG5hbWUgdG8gdGhlIHBhcmVudCBtb2R1bGUgbmFtZVxuICAgICAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9hd3MvanNpaS9ibG9iL2IzMjk2NzBiZjllYzIyMmZhZDVmYzBkNjE0ZGNkZGQ1ZGFjYTdhZjUvcGFja2FnZXMvanNpaS1wYWNtYWsvbGliL3RhcmdldHMvcHl0aG9uL3R5cGUtbmFtZS50cyNMNDU1XG4gICAgICBjb25zdCBzdWJtb2R1bGVQeXRob25Nb2R1bGUgPSBweXRob25Nb2R1bGUgPz8gYCR7cGFyZW50UHl0aG9uTW9kdWxlfS4ke0Nhc2Uuc25ha2UobW9kdWxlTGlrZS5uYW1lKX1gO1xuXG4gICAgICBjb25zdCBtb2R1bGVQYXJ0cyA9IHN1Ym1vZHVsZVB5dGhvbk1vZHVsZS5zcGxpdCgnLicpO1xuICAgICAgcmV0dXJuIHsgbmFtZTogbW9kdWxlUGFydHNbMF0sIHN1Ym1vZHVsZTogbW9kdWxlUGFydHNbMV0gfTtcbiAgICB9XG5cbiAgICBpZiAoIXB5dGhvbk1vZHVsZSkge1xuICAgICAgdGhyb3cgbmV3IExhbmd1YWdlTm90U3VwcG9ydGVkRXJyb3IoXG4gICAgICAgIGBQeXRob24gaXMgbm90IGEgc3VwcG9ydGVkIHRhcmdldCBmb3IgbW9kdWxlOiAke21vZHVsZUxpa2UuZnFufWAsXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiB7IG5hbWU6IHB5dGhvbk1vZHVsZSB9O1xuICB9XG5cbiAgcHVibGljIGludGVyZmFjZShcbiAgICBpZmFjZTogcmVmbGVjdC5JbnRlcmZhY2VUeXBlLFxuICApOiB0cmFuc3BpbGUuVHJhbnNwaWxlZEludGVyZmFjZSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IGlmYWNlLm5hbWUsXG4gICAgICB0eXBlOiB0aGlzLnR5cGUoaWZhY2UpLFxuICAgIH07XG4gIH1cblxuICBwcml2YXRlIGlzU3RydWN0KHA6IHJlZmxlY3QuUGFyYW1ldGVyKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHAudHlwZS5mcW4gPyBwLnN5c3RlbS5maW5kRnFuKHAudHlwZS5mcW4pLmlzRGF0YVR5cGUoKSA6IGZhbHNlO1xuICB9XG5cbiAgcHJpdmF0ZSB0eXBpbmcodHlwZTogJ0xpc3QnIHwgJ01hcHBpbmcnIHwgJ0FueScgfCAnVW5pb24nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gYHR5cGluZy4ke3R5cGV9YDtcbiAgfVxuXG4gIHByaXZhdGUgZm9ybWF0UGFyYW1ldGVycyhcbiAgICB0cmFuc3BpbGVkOiB0cmFuc3BpbGUuVHJhbnNwaWxlZFBhcmFtZXRlciB8IHRyYW5zcGlsZS5UcmFuc3BpbGVkUHJvcGVydHksXG4gICk6IHN0cmluZyB7XG4gICAgY29uc3QgdGYgPSB0cmFuc3BpbGVkLnR5cGVSZWZlcmVuY2UudG9TdHJpbmcoe1xuICAgICAgdHlwZUZvcm1hdHRlcjogKHQpID0+IHQubmFtZSxcbiAgICB9KTtcbiAgICByZXR1cm4gYCR7dHJhbnNwaWxlZC5uYW1lfTogJHt0Zn0ke3RyYW5zcGlsZWQub3B0aW9uYWwgPyAnID0gTm9uZScgOiAnJ31gO1xuICB9XG5cbiAgcHJpdmF0ZSBmb3JtYXRQcm9wZXJ0eShcbiAgICBuYW1lOiBzdHJpbmcsXG4gICAgdHlwZVJlZmVyZW5jZTogdHJhbnNwaWxlLlRyYW5zcGlsZWRUeXBlUmVmZXJlbmNlLFxuICApOiBzdHJpbmcge1xuICAgIGNvbnN0IHRmID0gdHlwZVJlZmVyZW5jZS50b1N0cmluZyh7XG4gICAgICB0eXBlRm9ybWF0dGVyOiAodCkgPT4gdC5uYW1lLFxuICAgIH0pO1xuICAgIHJldHVybiBgJHtuYW1lfTogJHt0Zn1gO1xuICB9XG59XG4iXX0=