"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Npm_npmCommand;
Object.defineProperty(exports, "__esModule", { value: true });
exports.OptionalPeerDepsFilter = exports.Npm = void 0;
const child_process_1 = require("child_process");
const fs_1 = require("fs");
const os = __importStar(require("os"));
const path_1 = require("path");
const semver_1 = require("semver");
const documentation_1 = require("./documentation");
const errors_1 = require("../../errors");
class Npm {
    constructor(workingDirectory, logger = console.log, npmCommand) {
        this.workingDirectory = workingDirectory;
        this.logger = logger;
        _Npm_npmCommand.set(this, void 0);
        __classPrivateFieldSet(this, _Npm_npmCommand, npmCommand, "f");
    }
    /**
     * Installs the designated package into this repository's working directory.
     *
     * @param target the name or path to the package that needs to be installed.
     * @param force whether to pass `--force` to `npm install`.
     *
     * @returns the name of the package that was installed.
     */
    async install(target, force = false) {
        const commonFlags = [
            ...force
                ? [
                    // force install, ignoring recommended protections such as platform checks. This is okay
                    // because we are not actually executing the code being installed in this context.
                    '--force',
                ]
                : [],
            // this is critical from a security perspective to prevent
            // code execution as part of the install command using npm hooks. (e.g postInstall)
            '--ignore-scripts',
            // save time by not running audit
            '--no-audit',
            // ensures npm does not insert anything in $PATH
            '--no-bin-links',
            // don't write or update a package-lock.json file
            '--no-package-lock',
            // always produce JSON output
            '--json',
        ];
        try {
            assertSuccess(await this.runCommand(await this.npmCommandPath(), [
                'install',
                JSON.stringify(target),
                ...commonFlags,
                // ensures we are installing devDependencies, too.
                '--include=dev',
                '--include=peer',
                '--include=optional',
                // Make sure we get a `package.json` so we can figure out the actual package name.
                '--save',
            ], chunksToObject, {
                cwd: this.workingDirectory,
                shell: true,
            }));
            const { dependencies } = JSON.parse(await fs_1.promises.readFile((0, path_1.join)(this.workingDirectory, 'package.json'), 'utf-8'));
            const names = Object.keys(dependencies !== null && dependencies !== void 0 ? dependencies : {});
            const name = names.length === 1
                ? names[0]
                : (0, documentation_1.extractPackageName)(target);
            const optionalPeerDeps = await this.listOptionalPeerDeps(name);
            if (optionalPeerDeps.length > 0) {
                assertSuccess(await this.runCommand(await this.npmCommandPath(), [
                    'install',
                    ...optionalPeerDeps,
                    ...commonFlags,
                    // Save as optional in the root package.json (courtesy)
                    '--save-optional',
                ], chunksToObject, {
                    cwd: this.workingDirectory,
                    shell: true,
                }));
            }
            return name;
        }
        catch (e) {
            if (!force && (e instanceof errors_1.NpmError) && e.npmErrorCode === 'EBADPLATFORM') {
                console.warn('npm install failed with EBADPLATFORM, retrying with --force');
                return this.install(target, true);
            }
            return Promise.reject(e);
        }
    }
    async listOptionalPeerDeps(target) {
        var _a;
        const result = new Array();
        const packageJson = JSON.parse(await fs_1.promises.readFile((0, path_1.join)(this.workingDirectory, 'node_modules', target, 'package.json'), 'utf-8'));
        for (const [name, { optional }] of Object.entries((_a = packageJson.peerDependenciesMeta) !== null && _a !== void 0 ? _a : {})) {
            if (!optional) {
                continue;
            }
            const version = packageJson.peerDependencies[name];
            if (version == null) {
                continue;
            }
            result.push(JSON.stringify(`${name}@${version}`));
        }
        return result;
    }
    /**
     * Obtains the path to the npm command that should be run. This always returns
     * the path to an npm >= 7, which "correctly" handles peerDependencies. If the
     * npm version that's available in $PATH satisfies this predicate, this will
     * simply return `npm`.
     */
    async npmCommandPath() {
        if (__classPrivateFieldGet(this, _Npm_npmCommand, "f")) {
            return __classPrivateFieldGet(this, _Npm_npmCommand, "f");
        }
        // Get the platform specific npm command
        const npm = npmPlatformAwareCommand();
        try {
            // If the npm in $PATH is >= v7, we can use that directly. The
            // `npm version --json` command returns a JSON object containing the
            // versions of several components (npm, node, v8, etc...). We are only
            // interested in the `npm` key here.
            const { exitCode, stdout } = await this.runCommand(npm, ['version', '--json'], chunksToObject);
            if (exitCode === 0 && (0, semver_1.major)(stdout.npm) >= 7) {
                return __classPrivateFieldSet(this, _Npm_npmCommand, npm, "f");
            }
        }
        catch (e) {
            this.logger('Could not determine version of npm in $PATH:', e);
        }
        // npm@8 is needed so that we also install peerDependencies - they are needed to construct
        // the full type system.
        this.logger('The npm in $PATH is not >= v7. Installing npm@8 locally...');
        const result = await this.runCommand(npm, ['install', 'npm@8', '--no-package-lock', '--no-save', '--json'], chunksToObject, {
            cwd: this.workingDirectory,
            shell: true,
        });
        assertSuccess(result);
        __classPrivateFieldSet(this, _Npm_npmCommand, (0, path_1.join)(this.workingDirectory, 'node_modules', '.bin', npm), "f");
        this.logger(`Done installing npm@8 at ${__classPrivateFieldGet(this, _Npm_npmCommand, "f")}`);
        return __classPrivateFieldGet(this, _Npm_npmCommand, "f");
    }
    /**
     * Runs the supplied command with the provided arguments, captures the data
     * pushed to STDOUT, and "parses" it using `outputTransform` to produce a
     * result.
     *
     * You must consult the `exitCode` of the return value to determine whether
     * the command was successful or not. Use the `assertSuccess` function to
     * throw/reject in case the execution was not successful.
     *
     * @param command         the command to invoke.
     * @param args            arguments to provide to the command.
     * @param outputTransform the function that will parse STDOUT data.
     * @param options         additional `spawn` options, if necessary.
     */
    async runCommand(command, args, outputTransform, options) {
        return new Promise((ok, ko) => {
            // On Windows, spawning a program ending in .cmd or .bat needs to run in a shell
            // https://nodejs.org/en/blog/vulnerability/april-2024-security-releases-2
            const shell = onWindows() && (command.endsWith('.cmd') || command.endsWith('.bat'));
            const child = (0, child_process_1.spawn)(command, args, { shell, ...options, stdio: ['inherit', 'pipe', 'pipe'] });
            const stdout = new Array();
            child.stdout.on('data', (chunk) => {
                stdout.push(Buffer.from(chunk));
            });
            child.stderr.on('data', (chunk) => {
                stdout.push(Buffer.from(chunk));
            });
            child.once('error', ko);
            child.once('close', (exitCode, signal) => {
                try {
                    ok({
                        command: `${command} ${args.join(' ')}`,
                        exitCode,
                        signal,
                        stdout: outputTransform(stdout),
                    });
                }
                catch (error) {
                    ko(error);
                }
            });
        });
    }
}
exports.Npm = Npm;
_Npm_npmCommand = new WeakMap();
/**
 * A filter to apply when selecting optional peer dependencies, based on how
 * their version target is specified.
 */
var OptionalPeerDepsFilter;
(function (OptionalPeerDepsFilter) {
    /**
     * Ignore all optional peer dependencies when installing.
     */
    OptionalPeerDepsFilter[OptionalPeerDepsFilter["None"] = 0] = "None";
    /**
     * Install only optional peer dependencies specified as a version range, and
     * ignore those specified as a URL or local path.
     */
    OptionalPeerDepsFilter[OptionalPeerDepsFilter["VersionRange"] = 1] = "VersionRange";
    /**
     * Install all optional peer dependencies regardless of how they are
     * specified. This requires URL and local-path dependencies to be reachable.
     */
    OptionalPeerDepsFilter[OptionalPeerDepsFilter["All"] = 2] = "All";
})(OptionalPeerDepsFilter || (exports.OptionalPeerDepsFilter = OptionalPeerDepsFilter = {}));
/**
 * Asserts the provided CommandResult corresponds to a command that exited with
 * code `0`. If that is not the case, this will throw an appropriate error,
 * either `NpmError` or `NoSpaceLeftOnDevice`.
 */
function assertSuccess(result) {
    var _a;
    const { command, exitCode, signal, stdout } = result;
    if (exitCode === 0) {
        return;
    }
    if (signal != null) {
        throw new errors_1.NpmError(`Command "${command}" was killed by ${signal}`, stdout);
    }
    if (exitCode === 228 || ((_a = stdout.error) === null || _a === void 0 ? void 0 : _a.code) === 'ENOSPC') {
        throw new errors_1.NoSpaceLeftOnDevice(`Command "${command}" failed due to insufficient available disk space`);
    }
    const { code, detail, summary } = stdout.error;
    const message = [
        `Command "${command}" exited with code ${exitCode}`,
        summary ? `: ${summary}` : '',
        detail ? `\n${detail}` : '',
        // If we have an error, but neither detail nor summary, then we probably
        // have an actual Error object, so we'll stringify that here...
        stdout.error && !detail && !summary ? `: ${stdout.error}` : '',
    ].join('');
    if (typeof summary === 'string' && summary.includes('must provide string spec')) {
        // happens when package.json dependencies don't have a spec.
        // for example: https://github.com/markusl/cdk-codepipeline-bitbucket-build-result-reporter/blob/v0.0.7/package.json
        throw new errors_1.UnInstallablePackageError(summary);
    }
    // happens when a package has been deleted from npm
    // for example: sns-app-jsii-component
    if (!code && !detail && typeof summary === 'string' && summary.includes('Cannot convert undefined or null to object')) {
        throw new errors_1.UnInstallablePackageError(summary);
    }
    switch (code) {
        case 'E404': // package (or dependency) can't be found on NPM. This can happen if the package depends on a deprecated package (for example).
        case 'EOVERRIDE': // Package contains some version overrides that conflict.
        case 'ERESOLVE': // dependency resolution problem requires a manual intervention (most likely...)
        case 'ENOVERSIONS': // package has been removed from npm
            throw new errors_1.UnInstallablePackageError(message);
        default:
            throw new errors_1.NpmError(message, stdout, code);
    }
}
/**
 * Concatenates the provided chunks into a single Buffer, converts it to a
 * string using the designated encoding, then JSON-parses it. If any part of
 * this process results in an error, returns an object that contains the error
 * and the raw chunks.
 */
function chunksToObject(chunks, encoding = 'utf-8') {
    const raw = Buffer.concat(chunks).toString(encoding);
    try {
        // npm will sometimes print non json log lines even though --json was requested.
        // observed these log lines always start with 'npm', so we filter those out.
        // for example: "npm notice New patch version of npm available! 8.1.0 -> 8.1.3"
        // for example: "npm ERR! must provide string spec"
        const onlyJson = raw.split(/[\r\n]+/) // split on any newlines, because npm returns inconsistent newline characters on Windows
            .filter(l => !l.startsWith('npm'))
            // Suppress debugger messages, if present...
            .filter(l => l !== 'Debugger attached.')
            .filter(l => l !== 'Waiting for the debugger to disconnect...')
            // Re-join...
            .join(os.EOL);
        return JSON.parse(onlyJson);
    }
    catch (error) {
        return { error, raw };
    }
}
/**
 * Helper to detect if we are running on Windows.
 */
function onWindows() {
    return process.platform === 'win32';
}
/**
 * Get the npm binary path depending on the platform.
 * @returns "npm.cmd" on Windows, otherwise "npm"
 */
function npmPlatformAwareCommand() {
    if (onWindows()) {
        return 'npm.cmd';
    }
    return 'npm';
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiX25wbS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9kb2NnZW4vdmlldy9fbnBtLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsaURBQWdFO0FBQ2hFLDJCQUFvQztBQUNwQyx1Q0FBeUI7QUFDekIsK0JBQTRCO0FBQzVCLG1DQUErQjtBQUMvQixtREFBcUQ7QUFDckQseUNBQXdGO0FBRXhGLE1BQWEsR0FBRztJQUdkLFlBQ21CLGdCQUF3QixFQUN4QixTQUFTLE9BQU8sQ0FBQyxHQUFHLEVBQ3JDLFVBQW1CO1FBRkYscUJBQWdCLEdBQWhCLGdCQUFnQixDQUFRO1FBQ3hCLFdBQU0sR0FBTixNQUFNLENBQWM7UUFKdkMsa0NBQWdDO1FBTzlCLHVCQUFBLElBQUksbUJBQWUsVUFBVSxNQUFBLENBQUM7SUFDaEMsQ0FBQztJQUVEOzs7Ozs7O09BT0c7SUFDSSxLQUFLLENBQUMsT0FBTyxDQUFDLE1BQWMsRUFBRSxLQUFLLEdBQUcsS0FBSztRQUNoRCxNQUFNLFdBQVcsR0FBRztZQUNsQixHQUFHLEtBQUs7Z0JBQ04sQ0FBQyxDQUFDO29CQUNBLHdGQUF3RjtvQkFDeEYsa0ZBQWtGO29CQUNsRixTQUFTO2lCQUNWO2dCQUNELENBQUMsQ0FBQyxFQUFFO1lBQ04sMERBQTBEO1lBQzFELG1GQUFtRjtZQUNuRixrQkFBa0I7WUFDbEIsaUNBQWlDO1lBQ2pDLFlBQVk7WUFDWixnREFBZ0Q7WUFDaEQsZ0JBQWdCO1lBQ2hCLGlEQUFpRDtZQUNqRCxtQkFBbUI7WUFDbkIsNkJBQTZCO1lBQzdCLFFBQVE7U0FDVCxDQUFDO1FBRUYsSUFBSSxDQUFDO1lBQ0gsYUFBYSxDQUFDLE1BQU0sSUFBSSxDQUFDLFVBQVUsQ0FDakMsTUFBTSxJQUFJLENBQUMsY0FBYyxFQUFFLEVBQzNCO2dCQUNFLFNBQVM7Z0JBQ1QsSUFBSSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUM7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LENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEtBQUssMkNBQTJDLENBQUM7WUFDL0QsYUFBYTthQUNaLElBQUksQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDaEIsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQzlCLENBQUM7SUFBQyxPQUFPLEtBQUssRUFBRSxDQUFDO1FBQ2YsT0FBTyxFQUFFLEtBQUssRUFBRSxHQUFHLEVBQUUsQ0FBQztJQUN4QixDQUFDO0FBQ0gsQ0FBQztBQVVEOztHQUVHO0FBQ0gsU0FBUyxTQUFTO0lBQ2hCLE9BQU8sT0FBTyxDQUFDLFFBQVEsS0FBSyxPQUFPLENBQUM7QUFDdEMsQ0FBQztBQUVEOzs7R0FHRztBQUNILFNBQVMsdUJBQXVCO0lBQzlCLElBQUksU0FBUyxFQUFFLEVBQUUsQ0FBQztRQUNoQixPQUFPLFNBQVMsQ0FBQztJQUNuQixDQUFDO0lBRUQsT0FBTyxLQUFLLENBQUM7QUFDZixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc3Bhd24sIFNwYXduT3B0aW9uc1dpdGhvdXRTdGRpbyB9IGZyb20gJ2NoaWxkX3Byb2Nlc3MnO1xuaW1wb3J0IHsgcHJvbWlzZXMgYXMgZnMgfSBmcm9tICdmcyc7XG5pbXBvcnQgKiBhcyBvcyBmcm9tICdvcyc7XG5pbXBvcnQgeyBqb2luIH0gZnJvbSAncGF0aCc7XG5pbXBvcnQgeyBtYWpvciB9IGZyb20gJ3NlbXZlcic7XG5pbXBvcnQgeyBleHRyYWN0UGFja2FnZU5hbWUgfSBmcm9tICcuL2RvY3VtZW50YXRpb24nO1xuaW1wb3J0IHsgTm9TcGFjZUxlZnRPbkRldmljZSwgVW5JbnN0YWxsYWJsZVBhY2thZ2VFcnJvciwgTnBtRXJyb3IgfSBmcm9tICcuLi8uLi9lcnJvcnMnO1xuXG5leHBvcnQgY2xhc3MgTnBtIHtcbiAgI25wbUNvbW1hbmQ6IHN0cmluZyB8IHVuZGVmaW5lZDtcblxuICBwdWJsaWMgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSByZWFkb25seSB3b3JraW5nRGlyZWN0b3J5OiBzdHJpbmcsXG4gICAgcHJpdmF0ZSByZWFkb25seSBsb2dnZXIgPSBjb25zb2xlLmxvZyxcbiAgICBucG1Db21tYW5kPzogc3RyaW5nLFxuICApIHtcbiAgICB0aGlzLiNucG1Db21tYW5kID0gbnBtQ29tbWFuZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnN0YWxscyB0aGUgZGVzaWduYXRlZCBwYWNrYWdlIGludG8gdGhpcyByZXBvc2l0b3J5J3Mgd29ya2luZyBkaXJlY3RvcnkuXG4gICAqXG4gICAqIEBwYXJhbSB0YXJnZXQgdGhlIG5hbWUgb3IgcGF0aCB0byB0aGUgcGFja2FnZSB0aGF0IG5lZWRzIHRvIGJlIGluc3RhbGxlZC5cbiAgICogQHBhcmFtIGZvcmNlIHdoZXRoZXIgdG8gcGFzcyBgLS1mb3JjZWAgdG8gYG5wbSBpbnN0YWxsYC5cbiAgICpcbiAgICogQHJldHVybnMgdGhlIG5hbWUgb2YgdGhlIHBhY2thZ2UgdGhhdCB3YXMgaW5zdGFsbGVkLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIGluc3RhbGwodGFyZ2V0OiBzdHJpbmcsIGZvcmNlID0gZmFsc2UpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIGNvbnN0IGNvbW1vbkZsYWdzID0gW1xuICAgICAgLi4uZm9yY2VcbiAgICAgICAgPyBbXG4gICAgICAgICAgLy8gZm9yY2UgaW5zdGFsbCwgaWdub3JpbmcgcmVjb21tZW5kZWQgcHJvdGVjdGlvbnMgc3VjaCBhcyBwbGF0Zm9ybSBjaGVja3MuIFRoaXMgaXMgb2theVxuICAgICAgICAgIC8vIGJlY2F1c2Ugd2UgYXJlIG5vdCBhY3R1YWxseSBleGVjdXRpbmcgdGhlIGNvZGUgYmVpbmcgaW5zdGFsbGVkIGluIHRoaXMgY29udGV4dC5cbiAgICAgICAgICAnLS1mb3JjZScsXG4gICAgICAgIF1cbiAgICAgICAgOiBbXSxcbiAgICAgIC8vIHRoaXMgaXMgY3JpdGljYWwgZnJvbSBhIHNlY3VyaXR5IHBlcnNwZWN0aXZlIHRvIHByZXZlbnRcbiAgICAgIC8vIGNvZGUgZXhlY3V0aW9uIGFzIHBhcnQgb2YgdGhlIGluc3RhbGwgY29tbWFuZCB1c2luZyBucG0gaG9va3MuIChlLmcgcG9zdEluc3RhbGwpXG4gICAgICAnLS1pZ25vcmUtc2NyaXB0cycsXG4gICAgICAvLyBzYXZlIHRpbWUgYnkgbm90IHJ1bm5pbmcgYXVkaXRcbiAgICAgICctLW5vLWF1ZGl0JyxcbiAgICAgIC8vIGVuc3VyZXMgbnBtIGRvZXMgbm90IGluc2VydCBhbnl0aGluZyBpbiAkUEFUSFxuICAgICAgJy0tbm8tYmluLWxpbmtzJyxcbiAgICAgIC8vIGRvbid0IHdyaXRlIG9yIHVwZGF0ZSBhIHBhY2thZ2UtbG9jay5qc29uIGZpbGVcbiAgICAgICctLW5vLXBhY2thZ2UtbG9jaycsXG4gICAgICAvLyBhbHdheXMgcHJvZHVjZSBKU09OIG91dHB1dFxuICAgICAgJy0tanNvbicsXG4gICAgXTtcblxuICAgIHRyeSB7XG4gICAgICBhc3NlcnRTdWNjZXNzKGF3YWl0IHRoaXMucnVuQ29tbWFuZChcbiAgICAgICAgYXdhaXQgdGhpcy5ucG1Db21tYW5kUGF0aCgpLFxuICAgICAgICBbXG4gICAgICAgICAgJ2luc3RhbGwnLFxuICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHRhcmdldCksXG4gICAgICAgICAgLi4uY29tbW9uRmxhZ3MsXG4gICAgICAgICAgLy8gZW5zdXJlcyB3ZSBhcmUgaW5zdGFsbGluZyBkZXZEZXBlbmRlbmNpZXMsIHRvby5cbiAgICAgICAgICAnLS1pbmNsdWRlPWRldicsXG4gICAgICAgICAgJy0taW5jbHVkZT1wZWVyJyxcbiAgICAgICAgICAnLS1pbmNsdWRlPW9wdGlvbmFsJyxcbiAgICAgICAgICAvLyBNYWtlIHN1cmUgd2UgZ2V0IGEgYHBhY2thZ2UuanNvbmAgc28gd2UgY2FuIGZpZ3VyZSBvdXQgdGhlIGFjdHVhbCBwYWNrYWdlIG5hbWUuXG4gICAgICAgICAgJy0tc2F2ZScsXG4gICAgICAgIF0sXG4gICAgICAgIGNodW5rc1RvT2JqZWN0LFxuICAgICAgICB7XG4gICAgICAgICAgY3dkOiB0aGlzLndvcmtpbmdEaXJlY3RvcnksXG4gICAgICAgICAgc2hlbGw6IHRydWUsXG4gICAgICAgIH0sXG4gICAgICApKTtcblxuICAgICAgY29uc3QgeyBkZXBlbmRlbmNpZXMgfSA9IEpTT04ucGFyc2UoYXdhaXQgZnMucmVhZEZpbGUoam9pbih0aGlzLndvcmtpbmdEaXJlY3RvcnksICdwYWNrYWdlLmpzb24nKSwgJ3V0Zi04JykpO1xuICAgICAgY29uc3QgbmFtZXMgPSBPYmplY3Qua2V5cyhkZXBlbmRlbmNpZXMgPz8ge30pO1xuICAgICAgY29uc3QgbmFtZSA9IG5hbWVzLmxlbmd0aCA9PT0gMVxuICAgICAgICA/IG5hbWVzWzBdXG4gICAgICAgIDogZXh0cmFjdFBhY2thZ2VOYW1lKHRhcmdldCk7XG5cbiAgICAgIGNvbnN0IG9wdGlvbmFsUGVlckRlcHMgPSBhd2FpdCB0aGlzLmxpc3RPcHRpb25hbFBlZXJEZXBzKG5hbWUpO1xuICAgICAgaWYgKG9wdGlvbmFsUGVlckRlcHMubGVuZ3RoID4gMCkge1xuICAgICAgICBhc3NlcnRTdWNjZXNzKGF3YWl0IHRoaXMucnVuQ29tbWFuZChcbiAgICAgICAgICBhd2FpdCB0aGlzLm5wbUNvbW1hbmRQYXRoKCksXG4gICAgICAgICAgW1xuICAgICAgICAgICAgJ2luc3RhbGwnLFxuICAgICAgICAgICAgLi4ub3B0aW9uYWxQZWVyRGVwcyxcbiAgICAgICAgICAgIC4uLmNvbW1vbkZsYWdzLFxuICAgICAgICAgICAgLy8gU2F2ZSBhcyBvcHRpb25hbCBpbiB0aGUgcm9vdCBwYWNrYWdlLmpzb24gKGNvdXJ0ZXN5KVxuICAgICAgICAgICAgJy0tc2F2ZS1vcHRpb25hbCcsXG4gICAgICAgICAgXSxcbiAgICAgICAgICBjaHVua3NUb09iamVjdCxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjd2Q6IHRoaXMud29ya2luZ0RpcmVjdG9yeSxcbiAgICAgICAgICAgIHNoZWxsOiB0cnVlLFxuICAgICAgICAgIH0sXG4gICAgICAgICkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmFtZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoIWZvcmNlICYmIChlIGluc3RhbmNlb2YgTnBtRXJyb3IpICYmIGUubnBtRXJyb3JDb2RlID09PSAnRUJBRFBMQVRGT1JNJykge1xuICAgICAgICBjb25zb2xlLndhcm4oJ25wbSBpbnN0YWxsIGZhaWxlZCB3aXRoIEVCQURQTEFURk9STSwgcmV0cnlpbmcgd2l0aCAtLWZvcmNlJyk7XG4gICAgICAgIHJldHVybiB0aGlzLmluc3RhbGwodGFyZ2V0LCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGxpc3RPcHRpb25hbFBlZXJEZXBzKHRhcmdldDogc3RyaW5nKTogUHJvbWlzZTxyZWFkb25seSBzdHJpbmdbXT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBBcnJheTxzdHJpbmc+KCk7XG5cbiAgICBjb25zdCBwYWNrYWdlSnNvbiA9IEpTT04ucGFyc2UoYXdhaXQgZnMucmVhZEZpbGUoam9pbih0aGlzLndvcmtpbmdEaXJlY3RvcnksICdub2RlX21vZHVsZXMnLCB0YXJnZXQsICdwYWNrYWdlLmpzb24nKSwgJ3V0Zi04JykpO1xuICAgIGZvciAoY29uc3QgW25hbWUsIHsgb3B0aW9uYWwgfV0gb2YgT2JqZWN0LmVudHJpZXMocGFja2FnZUpzb24ucGVlckRlcGVuZGVuY2llc01ldGEgPz8ge30pIGFzIFtzdHJpbmcsIHsgb3B0aW9uYWw6IGJvb2xlYW4gfV1bXSkge1xuICAgICAgaWYgKCFvcHRpb25hbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHZlcnNpb24gPSBwYWNrYWdlSnNvbi5wZWVyRGVwZW5kZW5jaWVzW25hbWVdO1xuICAgICAgaWYgKHZlcnNpb24gPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5wdXNoKEpTT04uc3RyaW5naWZ5KGAke25hbWV9QCR7dmVyc2lvbn1gKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBPYnRhaW5zIHRoZSBwYXRoIHRvIHRoZSBucG0gY29tbWFuZCB0aGF0IHNob3VsZCBiZSBydW4uIFRoaXMgYWx3YXlzIHJldHVybnNcbiAgICogdGhlIHBhdGggdG8gYW4gbnBtID49IDcsIHdoaWNoIFwiY29ycmVjdGx5XCIgaGFuZGxlcyBwZWVyRGVwZW5kZW5jaWVzLiBJZiB0aGVcbiAgICogbnBtIHZlcnNpb24gdGhhdCdzIGF2YWlsYWJsZSBpbiAkUEFUSCBzYXRpc2ZpZXMgdGhpcyBwcmVkaWNhdGUsIHRoaXMgd2lsbFxuICAgKiBzaW1wbHkgcmV0dXJuIGBucG1gLlxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBucG1Db21tYW5kUGF0aCgpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIGlmICh0aGlzLiNucG1Db21tYW5kKSB7XG4gICAgICByZXR1cm4gdGhpcy4jbnBtQ29tbWFuZDtcbiAgICB9XG5cbiAgICAvLyBHZXQgdGhlIHBsYXRmb3JtIHNwZWNpZmljIG5wbSBjb21tYW5kXG4gICAgY29uc3QgbnBtID0gbnBtUGxhdGZvcm1Bd2FyZUNvbW1hbmQoKTtcblxuICAgIHRyeSB7XG4gICAgICAvLyBJZiB0aGUgbnBtIGluICRQQVRIIGlzID49IHY3LCB3ZSBjYW4gdXNlIHRoYXQgZGlyZWN0bHkuIFRoZVxuICAgICAgLy8gYG5wbSB2ZXJzaW9uIC0tanNvbmAgY29tbWFuZCByZXR1cm5zIGEgSlNPTiBvYmplY3QgY29udGFpbmluZyB0aGVcbiAgICAgIC8vIHZlcnNpb25zIG9mIHNldmVyYWwgY29tcG9uZW50cyAobnBtLCBub2RlLCB2OCwgZXRjLi4uKS4gV2UgYXJlIG9ubHlcbiAgICAgIC8vIGludGVyZXN0ZWQgaW4gdGhlIGBucG1gIGtleSBoZXJlLlxuICAgICAgY29uc3QgeyBleGl0Q29kZSwgc3Rkb3V0IH0gPSBhd2FpdCB0aGlzLnJ1bkNvbW1hbmQoXG4gICAgICAgIG5wbSwgWyd2ZXJzaW9uJywgJy0tanNvbiddLFxuICAgICAgICBjaHVua3NUb09iamVjdCxcbiAgICAgICk7XG4gICAgICBpZiAoZXhpdENvZGUgPT09IDAgJiYgbWFqb3IoKHN0ZG91dCBhcyBhbnkpLm5wbSkgPj0gNykge1xuICAgICAgICByZXR1cm4gdGhpcy4jbnBtQ29tbWFuZCA9IG5wbTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aGlzLmxvZ2dlcignQ291bGQgbm90IGRldGVybWluZSB2ZXJzaW9uIG9mIG5wbSBpbiAkUEFUSDonLCBlKTtcbiAgICB9XG5cbiAgICAvLyBucG1AOCBpcyBuZWVkZWQgc28gdGhhdCB3ZSBhbHNvIGluc3RhbGwgcGVlckRlcGVuZGVuY2llcyAtIHRoZXkgYXJlIG5lZWRlZCB0byBjb25zdHJ1Y3RcbiAgICAvLyB0aGUgZnVsbCB0eXBlIHN5c3RlbS5cbiAgICB0aGlzLmxvZ2dlcignVGhlIG5wbSBpbiAkUEFUSCBpcyBub3QgPj0gdjcuIEluc3RhbGxpbmcgbnBtQDggbG9jYWxseS4uLicpO1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMucnVuQ29tbWFuZChcbiAgICAgIG5wbSxcbiAgICAgIFsnaW5zdGFsbCcsICducG1AOCcsICctLW5vLXBhY2thZ2UtbG9jaycsICctLW5vLXNhdmUnLCAnLS1qc29uJ10sXG4gICAgICBjaHVua3NUb09iamVjdCxcbiAgICAgIHtcbiAgICAgICAgY3dkOiB0aGlzLndvcmtpbmdEaXJlY3RvcnksXG4gICAgICAgIHNoZWxsOiB0cnVlLFxuICAgICAgfSxcbiAgICApO1xuICAgIGFzc2VydFN1Y2Nlc3MocmVzdWx0KTtcblxuICAgIHRoaXMuI25wbUNvbW1hbmQgPSBqb2luKHRoaXMud29ya2luZ0RpcmVjdG9yeSwgJ25vZGVfbW9kdWxlcycsICcuYmluJywgbnBtKTtcbiAgICB0aGlzLmxvZ2dlcihgRG9uZSBpbnN0YWxsaW5nIG5wbUA4IGF0ICR7dGhpcy4jbnBtQ29tbWFuZH1gKTtcbiAgICByZXR1cm4gdGhpcy4jbnBtQ29tbWFuZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSdW5zIHRoZSBzdXBwbGllZCBjb21tYW5kIHdpdGggdGhlIHByb3ZpZGVkIGFyZ3VtZW50cywgY2FwdHVyZXMgdGhlIGRhdGFcbiAgICogcHVzaGVkIHRvIFNURE9VVCwgYW5kIFwicGFyc2VzXCIgaXQgdXNpbmcgYG91dHB1dFRyYW5zZm9ybWAgdG8gcHJvZHVjZSBhXG4gICAqIHJlc3VsdC5cbiAgICpcbiAgICogWW91IG11c3QgY29uc3VsdCB0aGUgYGV4aXRDb2RlYCBvZiB0aGUgcmV0dXJuIHZhbHVlIHRvIGRldGVybWluZSB3aGV0aGVyXG4gICAqIHRoZSBjb21tYW5kIHdhcyBzdWNjZXNzZnVsIG9yIG5vdC4gVXNlIHRoZSBgYXNzZXJ0U3VjY2Vzc2AgZnVuY3Rpb24gdG9cbiAgICogdGhyb3cvcmVqZWN0IGluIGNhc2UgdGhlIGV4ZWN1dGlvbiB3YXMgbm90IHN1Y2Nlc3NmdWwuXG4gICAqXG4gICAqIEBwYXJhbSBjb21tYW5kICAgICAgICAgdGhlIGNvbW1hbmQgdG8gaW52b2tlLlxuICAgKiBAcGFyYW0gYXJncyAgICAgICAgICAgIGFyZ3VtZW50cyB0byBwcm92aWRlIHRvIHRoZSBjb21tYW5kLlxuICAgKiBAcGFyYW0gb3V0cHV0VHJhbnNmb3JtIHRoZSBmdW5jdGlvbiB0aGF0IHdpbGwgcGFyc2UgU1RET1VUIGRhdGEuXG4gICAqIEBwYXJhbSBvcHRpb25zICAgICAgICAgYWRkaXRpb25hbCBgc3Bhd25gIG9wdGlvbnMsIGlmIG5lY2Vzc2FyeS5cbiAgICovXG4gIHByaXZhdGUgYXN5bmMgcnVuQ29tbWFuZDxUID0gQnVmZmVyPihcbiAgICBjb21tYW5kOiBzdHJpbmcsXG4gICAgYXJnczogcmVhZG9ubHkgc3RyaW5nW10sXG4gICAgb3V0cHV0VHJhbnNmb3JtOiAoc3RkZXJyOiByZWFkb25seSBCdWZmZXJbXSkgPT4gVCxcbiAgICBvcHRpb25zPzogU3Bhd25PcHRpb25zV2l0aG91dFN0ZGlvLFxuICApOiBQcm9taXNlPENvbW1hbmRSZXN1bHQ8VD4+IHtcbiAgICByZXR1cm4gbmV3IFByb21pc2U8Q29tbWFuZFJlc3VsdDxUPj4oKG9rLCBrbykgPT4ge1xuICAgICAgLy8gT24gV2luZG93cywgc3Bhd25pbmcgYSBwcm9ncmFtIGVuZGluZyBpbiAuY21kIG9yIC5iYXQgbmVlZHMgdG8gcnVuIGluIGEgc2hlbGxcbiAgICAgIC8vIGh0dHBzOi8vbm9kZWpzLm9yZy9lbi9ibG9nL3Z1bG5lcmFiaWxpdHkvYXByaWwtMjAyNC1zZWN1cml0eS1yZWxlYXNlcy0yXG4gICAgICBjb25zdCBzaGVsbCA9IG9uV2luZG93cygpICYmIChjb21tYW5kLmVuZHNXaXRoKCcuY21kJykgfHwgY29tbWFuZC5lbmRzV2l0aCgnLmJhdCcpKTtcbiAgICAgIGNvbnN0IGNoaWxkID0gc3Bhd24oY29tbWFuZCwgYXJncywgeyBzaGVsbCwgLi4ub3B0aW9ucywgc3RkaW86IFsnaW5oZXJpdCcsICdwaXBlJywgJ3BpcGUnXSB9KTtcbiAgICAgIGNvbnN0IHN0ZG91dCA9IG5ldyBBcnJheTxCdWZmZXI+KCk7XG4gICAgICBjaGlsZC5zdGRvdXQub24oJ2RhdGEnLCAoY2h1bmspID0+IHtcbiAgICAgICAgc3Rkb3V0LnB1c2goQnVmZmVyLmZyb20oY2h1bmspKTtcbiAgICAgIH0pO1xuICAgICAgY2hpbGQuc3RkZXJyLm9uKCdkYXRhJywgKGNodW5rKSA9PiB7XG4gICAgICAgIHN0ZG91dC5wdXNoKEJ1ZmZlci5mcm9tKGNodW5rKSk7XG4gICAgICB9KTtcblxuICAgICAgY2hpbGQub25jZSgnZXJyb3InLCBrbyk7XG4gICAgICBjaGlsZC5vbmNlKCdjbG9zZScsIChleGl0Q29kZSwgc2lnbmFsKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgb2soe1xuICAgICAgICAgICAgY29tbWFuZDogYCR7Y29tbWFuZH0gJHthcmdzLmpvaW4oJyAnKX1gLFxuICAgICAgICAgICAgZXhpdENvZGUsXG4gICAgICAgICAgICBzaWduYWwsXG4gICAgICAgICAgICBzdGRvdXQ6IG91dHB1dFRyYW5zZm9ybShzdGRvdXQpLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGtvKGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBBIGZpbHRlciB0byBhcHBseSB3aGVuIHNlbGVjdGluZyBvcHRpb25hbCBwZWVyIGRlcGVuZGVuY2llcywgYmFzZWQgb24gaG93XG4gKiB0aGVpciB2ZXJzaW9uIHRhcmdldCBpcyBzcGVjaWZpZWQuXG4gKi9cbmV4cG9ydCBlbnVtIE9wdGlvbmFsUGVlckRlcHNGaWx0ZXIge1xuICAvKipcbiAgICogSWdub3JlIGFsbCBvcHRpb25hbCBwZWVyIGRlcGVuZGVuY2llcyB3aGVuIGluc3RhbGxpbmcuXG4gICAqL1xuICBOb25lLFxuXG4gIC8qKlxuICAgKiBJbnN0YWxsIG9ubHkgb3B0aW9uYWwgcGVlciBkZXBlbmRlbmNpZXMgc3BlY2lmaWVkIGFzIGEgdmVyc2lvbiByYW5nZSwgYW5kXG4gICAqIGlnbm9yZSB0aG9zZSBzcGVjaWZpZWQgYXMgYSBVUkwgb3IgbG9jYWwgcGF0aC5cbiAgICovXG4gIFZlcnNpb25SYW5nZSxcblxuICAvKipcbiAgICogSW5zdGFsbCBhbGwgb3B0aW9uYWwgcGVlciBkZXBlbmRlbmNpZXMgcmVnYXJkbGVzcyBvZiBob3cgdGhleSBhcmVcbiAgICogc3BlY2lmaWVkLiBUaGlzIHJlcXVpcmVzIFVSTCBhbmQgbG9jYWwtcGF0aCBkZXBlbmRlbmNpZXMgdG8gYmUgcmVhY2hhYmxlLlxuICAgKi9cbiAgQWxsLFxufVxuXG5pbnRlcmZhY2UgQ29tbWFuZFJlc3VsdDxUPiB7XG4gIHJlYWRvbmx5IGNvbW1hbmQ6IHN0cmluZztcbiAgcmVhZG9ubHkgZXhpdENvZGU6IG51bWJlciB8IG51bGw7XG4gIHJlYWRvbmx5IHNpZ25hbDogTm9kZUpTLlNpZ25hbHMgfCBudWxsO1xuICByZWFkb25seSBzdGRvdXQ6IFQ7XG59XG5pbnRlcmZhY2UgU3VjY2Vzc2Z1bENvbW1hbmRSZXN1bHQ8VD4gZXh0ZW5kcyBDb21tYW5kUmVzdWx0PFQ+IHtcbiAgcmVhZG9ubHkgZXhpdENvZGU6IDA7XG4gIHJlYWRvbmx5IHNpZ25hbDogbnVsbDtcbn1cblxuLyoqXG4gKiBBc3NlcnRzIHRoZSBwcm92aWRlZCBDb21tYW5kUmVzdWx0IGNvcnJlc3BvbmRzIHRvIGEgY29tbWFuZCB0aGF0IGV4aXRlZCB3aXRoXG4gKiBjb2RlIGAwYC4gSWYgdGhhdCBpcyBub3QgdGhlIGNhc2UsIHRoaXMgd2lsbCB0aHJvdyBhbiBhcHByb3ByaWF0ZSBlcnJvcixcbiAqIGVpdGhlciBgTnBtRXJyb3JgIG9yIGBOb1NwYWNlTGVmdE9uRGV2aWNlYC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0U3VjY2VzcyhyZXN1bHQ6IENvbW1hbmRSZXN1bHQ8UmVzcG9uc2VPYmplY3Q+KTogYXNzZXJ0cyByZXN1bHQgaXMgU3VjY2Vzc2Z1bENvbW1hbmRSZXN1bHQ8UmVzcG9uc2VPYmplY3Q+IHtcbiAgY29uc3QgeyBjb21tYW5kLCBleGl0Q29kZSwgc2lnbmFsLCBzdGRvdXQgfSA9IHJlc3VsdDtcbiAgaWYgKGV4aXRDb2RlID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChzaWduYWwgIT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBOcG1FcnJvcihgQ29tbWFuZCBcIiR7Y29tbWFuZH1cIiB3YXMga2lsbGVkIGJ5ICR7c2lnbmFsfWAsIHN0ZG91dCk7XG4gIH1cbiAgaWYgKGV4aXRDb2RlID09PSAyMjggfHwgc3Rkb3V0LmVycm9yPy5jb2RlID09PSAnRU5PU1BDJykge1xuICAgIHRocm93IG5ldyBOb1NwYWNlTGVmdE9uRGV2aWNlKGBDb21tYW5kIFwiJHtjb21tYW5kfVwiIGZhaWxlZCBkdWUgdG8gaW5zdWZmaWNpZW50IGF2YWlsYWJsZSBkaXNrIHNwYWNlYCk7XG4gIH1cbiAgY29uc3QgeyBjb2RlLCBkZXRhaWwsIHN1bW1hcnkgfSA9IHN0ZG91dC5lcnJvcjtcbiAgY29uc3QgbWVzc2FnZSA9IFtcbiAgICBgQ29tbWFuZCBcIiR7Y29tbWFuZH1cIiBleGl0ZWQgd2l0aCBjb2RlICR7ZXhpdENvZGV9YCxcbiAgICBzdW1tYXJ5ID8gYDogJHtzdW1tYXJ5fWAgOiAnJyxcbiAgICBkZXRhaWwgPyBgXFxuJHtkZXRhaWx9YCA6ICcnLFxuICAgIC8vIElmIHdlIGhhdmUgYW4gZXJyb3IsIGJ1dCBuZWl0aGVyIGRldGFpbCBub3Igc3VtbWFyeSwgdGhlbiB3ZSBwcm9iYWJseVxuICAgIC8vIGhhdmUgYW4gYWN0dWFsIEVycm9yIG9iamVjdCwgc28gd2UnbGwgc3RyaW5naWZ5IHRoYXQgaGVyZS4uLlxuICAgIHN0ZG91dC5lcnJvciAmJiAhZGV0YWlsICYmICFzdW1tYXJ5ID8gYDogJHtzdGRvdXQuZXJyb3J9YCA6ICcnLFxuICBdLmpvaW4oJycpO1xuXG4gIGlmICh0eXBlb2Ygc3VtbWFyeSA9PT0gJ3N0cmluZycgJiYgc3VtbWFyeS5pbmNsdWRlcygnbXVzdCBwcm92aWRlIHN0cmluZyBzcGVjJykpIHtcbiAgICAvLyBoYXBwZW5zIHdoZW4gcGFja2FnZS5qc29uIGRlcGVuZGVuY2llcyBkb24ndCBoYXZlIGEgc3BlYy5cbiAgICAvLyBmb3IgZXhhbXBsZTogaHR0cHM6Ly9naXRodWIuY29tL21hcmt1c2wvY2RrLWNvZGVwaXBlbGluZS1iaXRidWNrZXQtYnVpbGQtcmVzdWx0LXJlcG9ydGVyL2Jsb2IvdjAuMC43L3BhY2thZ2UuanNvblxuICAgIHRocm93IG5ldyBVbkluc3RhbGxhYmxlUGFja2FnZUVycm9yKHN1bW1hcnkpO1xuICB9XG5cbiAgLy8gaGFwcGVucyB3aGVuIGEgcGFja2FnZSBoYXMgYmVlbiBkZWxldGVkIGZyb20gbnBtXG4gIC8vIGZvciBleGFtcGxlOiBzbnMtYXBwLWpzaWktY29tcG9uZW50XG4gIGlmICghY29kZSAmJiAhZGV0YWlsICYmIHR5cGVvZiBzdW1tYXJ5ID09PSAnc3RyaW5nJyAmJiBzdW1tYXJ5LmluY2x1ZGVzKCdDYW5ub3QgY29udmVydCB1bmRlZmluZWQgb3IgbnVsbCB0byBvYmplY3QnKSkge1xuICAgIHRocm93IG5ldyBVbkluc3RhbGxhYmxlUGFja2FnZUVycm9yKHN1bW1hcnkpO1xuICB9XG5cbiAgc3dpdGNoIChjb2RlKSB7XG4gICAgY2FzZSAnRTQwNCc6IC8vIHBhY2thZ2UgKG9yIGRlcGVuZGVuY3kpIGNhbid0IGJlIGZvdW5kIG9uIE5QTS4gVGhpcyBjYW4gaGFwcGVuIGlmIHRoZSBwYWNrYWdlIGRlcGVuZHMgb24gYSBkZXByZWNhdGVkIHBhY2thZ2UgKGZvciBleGFtcGxlKS5cbiAgICBjYXNlICdFT1ZFUlJJREUnOiAvLyBQYWNrYWdlIGNvbnRhaW5zIHNvbWUgdmVyc2lvbiBvdmVycmlkZXMgdGhhdCBjb25mbGljdC5cbiAgICBjYXNlICdFUkVTT0xWRSc6IC8vIGRlcGVuZGVuY3kgcmVzb2x1dGlvbiBwcm9ibGVtIHJlcXVpcmVzIGEgbWFudWFsIGludGVydmVudGlvbiAobW9zdCBsaWtlbHkuLi4pXG4gICAgY2FzZSAnRU5PVkVSU0lPTlMnOiAvLyBwYWNrYWdlIGhhcyBiZWVuIHJlbW92ZWQgZnJvbSBucG1cbiAgICAgIHRocm93IG5ldyBVbkluc3RhbGxhYmxlUGFja2FnZUVycm9yKG1lc3NhZ2UpO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgTnBtRXJyb3IobWVzc2FnZSwgc3Rkb3V0LCBjb2RlKTtcbiAgfVxufVxuXG4vKipcbiAqIENvbmNhdGVuYXRlcyB0aGUgcHJvdmlkZWQgY2h1bmtzIGludG8gYSBzaW5nbGUgQnVmZmVyLCBjb252ZXJ0cyBpdCB0byBhXG4gKiBzdHJpbmcgdXNpbmcgdGhlIGRlc2lnbmF0ZWQgZW5jb2RpbmcsIHRoZW4gSlNPTi1wYXJzZXMgaXQuIElmIGFueSBwYXJ0IG9mXG4gKiB0aGlzIHByb2Nlc3MgcmVzdWx0cyBpbiBhbiBlcnJvciwgcmV0dXJucyBhbiBvYmplY3QgdGhhdCBjb250YWlucyB0aGUgZXJyb3JcbiAqIGFuZCB0aGUgcmF3IGNodW5rcy5cbiAqL1xuZnVuY3Rpb24gY2h1bmtzVG9PYmplY3QoY2h1bmtzOiByZWFkb25seSBCdWZmZXJbXSwgZW5jb2Rpbmc6IEJ1ZmZlckVuY29kaW5nID0gJ3V0Zi04Jyk6IFJlc3BvbnNlT2JqZWN0IHtcbiAgY29uc3QgcmF3ID0gQnVmZmVyLmNvbmNhdChjaHVua3MpLnRvU3RyaW5nKGVuY29kaW5nKTtcbiAgdHJ5IHtcbiAgICAvLyBucG0gd2lsbCBzb21ldGltZXMgcHJpbnQgbm9uIGpzb24gbG9nIGxpbmVzIGV2ZW4gdGhvdWdoIC0tanNvbiB3YXMgcmVxdWVzdGVkLlxuICAgIC8vIG9ic2VydmVkIHRoZXNlIGxvZyBsaW5lcyBhbHdheXMgc3RhcnQgd2l0aCAnbnBtJywgc28gd2UgZmlsdGVyIHRob3NlIG91dC5cbiAgICAvLyBmb3IgZXhhbXBsZTogXCJucG0gbm90aWNlIE5ldyBwYXRjaCB2ZXJzaW9uIG9mIG5wbSBhdmFpbGFibGUhIDguMS4wIC0+IDguMS4zXCJcbiAgICAvLyBmb3IgZXhhbXBsZTogXCJucG0gRVJSISBtdXN0IHByb3ZpZGUgc3RyaW5nIHNwZWNcIlxuICAgIGNvbnN0IG9ubHlKc29uID0gcmF3LnNwbGl0KC9bXFxyXFxuXSsvKSAvLyBzcGxpdCBvbiBhbnkgbmV3bGluZXMsIGJlY2F1c2UgbnBtIHJldHVybnMgaW5jb25zaXN0ZW50IG5ld2xpbmUgY2hhcmFjdGVycyBvbiBXaW5kb3dzXG4gICAgICAuZmlsdGVyKGwgPT4gIWwuc3RhcnRzV2l0aCgnbnBtJykpXG4gICAgICAvLyBTdXBwcmVzcyBkZWJ1Z2dlciBtZXNzYWdlcywgaWYgcHJlc2VudC4uLlxuICAgICAgLmZpbHRlcihsID0+IGwgIT09ICdEZWJ1Z2dlciBhdHRhY2hlZC4nKVxuICAgICAgLmZpbHRlcihsID0+IGwgIT09ICdXYWl0aW5nIGZvciB0aGUgZGVidWdnZXIgdG8gZGlzY29ubmVjdC4uLicpXG4gICAgICAvLyBSZS1qb2luLi4uXG4gICAgICAuam9pbihvcy5FT0wpO1xuICAgIHJldHVybiBKU09OLnBhcnNlKG9ubHlKc29uKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4geyBlcnJvciwgcmF3IH07XG4gIH1cbn1cblxudHlwZSBSZXNwb25zZU9iamVjdCA9XG4gIC8vIFRoZSBlcnJvciB3aGVuIHdlIGZhaWxlZCB0byBwYXJzZSB0aGUgb3V0cHV0IGFzIEpTT05cbiAgfCB7IHJlYWRvbmx5IGVycm9yOiBhbnk7IHJlYWRvbmx5IHJhdzogc3RyaW5nIH1cbiAgLy8gVGhlIGVycm9yIG9iamVjdHMgbnBtIHJldHVybnMgd2hlbiBvcGVyYXRpbmcgaW4gLS1qc29uIG1vZGVcbiAgfCB7IHJlYWRvbmx5IGVycm9yOiB7IHJlYWRvbmx5IGNvZGU6IHN0cmluZzsgcmVhZG9ubHkgc3VtbWFyeTogc3RyaW5nOyByZWFkb25seSBkZXRhaWw6IHN0cmluZyB9IH1cbiAgLy8gVGhlIHN1Y2Nlc3NmdWwgb2JqZWN0cyBhcmUgdHJlYXRlZCBhcyBvcGFxdWUgYmxvYnMgaGVyZVxuICB8IHsgcmVhZG9ubHkgZXJyb3I6IHVuZGVmaW5lZDsgcmVhZG9ubHkgW2tleTogc3RyaW5nXTogdW5rbm93biB9O1xuXG4vKipcbiAqIEhlbHBlciB0byBkZXRlY3QgaWYgd2UgYXJlIHJ1bm5pbmcgb24gV2luZG93cy5cbiAqL1xuZnVuY3Rpb24gb25XaW5kb3dzKCkge1xuICByZXR1cm4gcHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJztcbn1cblxuLyoqXG4gKiBHZXQgdGhlIG5wbSBiaW5hcnkgcGF0aCBkZXBlbmRpbmcgb24gdGhlIHBsYXRmb3JtLlxuICogQHJldHVybnMgXCJucG0uY21kXCIgb24gV2luZG93cywgb3RoZXJ3aXNlIFwibnBtXCJcbiAqL1xuZnVuY3Rpb24gbnBtUGxhdGZvcm1Bd2FyZUNvbW1hbmQoKSB7XG4gIGlmIChvbldpbmRvd3MoKSkge1xuICAgIHJldHVybiAnbnBtLmNtZCc7XG4gIH1cblxuICByZXR1cm4gJ25wbSc7XG59XG4iXX0=