"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LANGUAGE_SPECIFIC = exports.Documentation = void 0;
exports.extractPackageName = extractPackageName;
const os = __importStar(require("os"));
const path = __importStar(require("path"));
const spec_1 = require("@jsii/spec");
const fs = __importStar(require("fs-extra"));
const glob = __importStar(require("glob-promise"));
const reflect = __importStar(require("jsii-reflect"));
const jsii_rosetta_1 = require("jsii-rosetta");
const _npm_1 = require("./_npm");
const api_reference_1 = require("./api-reference");
const readme_1 = require("./readme");
const __1 = require("../..");
const json_1 = require("../render/json");
const markdown_doc_1 = require("../render/markdown-doc");
const markdown_render_1 = require("../render/markdown-render");
const schema_1 = require("../schema");
const csharp_1 = require("../transpile/csharp");
const go_1 = require("../transpile/go");
const java_1 = require("../transpile/java");
const python_1 = require("../transpile/python");
const transpile_1 = require("../transpile/transpile");
const typescript_1 = require("../transpile/typescript");
// https://github.com/aws/jsii/blob/main/packages/jsii-reflect/lib/assembly.ts#L175
const NOT_FOUND_IN_ASSEMBLY_REGEX = /Type '(.*)\..*' not found in assembly (.*)$/;
/**
 * Render documentation pages for a jsii library.
 */
class Documentation {
    /**
     * Create a `Documentation` object from a package installable by npm.
     *
     * Note that this method installs the target package to the local file-system. Make sure
     * to call `Documentation.cleanup` once you are done rendering.
     *
     * @param target - The target to install. This can either be a local path or a registry identifier (e.g <name>@<version>)
     * @param options - Additional options.
     *
     * @throws NoSpaceLeftOnDevice if the installation fails due to running out of disk space
     * @throws NpmError if some `npm` command fails when preparing the working set
     */
    static async forPackage(target, options = {}) {
        var _a;
        const workdir = await fs.mkdtemp(path.join(os.tmpdir(), path.sep));
        const npm = new _npm_1.Npm(workdir);
        if ((_a = options.verbose) !== null && _a !== void 0 ? _a : true) {
            console.log(`Installing package ${target}`);
        }
        const name = await npm.install(target);
        if (options._postInstall != null) {
            await options._postInstall(workdir);
        }
        const docs = await Documentation.forProject(path.join(workdir, 'node_modules', name), { ...options, assembliesDir: workdir });
        // we cannot delete this directory immediately since it is used during `render` calls.
        // instead we register it so that callers can clean it up by calling the `cleanup` method.
        docs.addCleanupDirectory(workdir);
        return docs;
    }
    /**
     * Create a `Documentation` object from a local directory containing a node project.
     *
     * @param root - The local directory path. Must contain a package.json file.
     * @param options - Additional options.
     */
    static async forProject(root, options = {}) {
        var _a;
        const manifestPath = path.join(root, 'package.json');
        if (!(await fs.pathExists(manifestPath))) {
            throw new Error(`Unable to locate ${manifestPath}`);
        }
        // normally the assemblies are located in subdirectories
        // of the root package dir (i.e ./node_modules)
        const assembliesDir = (_a = options === null || options === void 0 ? void 0 : options.assembliesDir) !== null && _a !== void 0 ? _a : root;
        const { name } = JSON.parse(await fs.readFile(manifestPath, 'utf-8'));
        return Documentation.forAssembly(name, assembliesDir);
    }
    /**
     * Create a `Documentation` object for a specific assembly from a directory of assemblies.
     *
     * @param assemblyName - The assembly name.
     * @param assembliesDir - The directory containing the assemblies that comprise the type-system.
     */
    static async forAssembly(assemblyName, assembliesDir) {
        return new Documentation(assemblyName, assembliesDir);
    }
    constructor(assemblyName, assembliesDir) {
        this.assemblyName = assemblyName;
        this.assembliesDir = assembliesDir;
        this.cleanupDirectories = new Set();
        this.assembliesCache = new Map();
    }
    /**
     * List all submodules in the assembly.
     */
    async listSubmodules() {
        const tsAssembly = await this.createAssembly(undefined, { loose: true, validate: false });
        return tsAssembly.allSubmodules;
    }
    async toIndexMarkdown(fileSuffix, options) {
        const assembly = await this.createAssembly(undefined, { loose: true, validate: false });
        const submodules = await this.listSubmodules();
        const schema = (await this.toJson({
            ...options,
            submodule: undefined,
            allSubmodules: false,
        })).content;
        const ref = new markdown_doc_1.MarkdownDocument({ header: { title: 'API Reference' }, id: 'api-reference' });
        if (schema.version !== schema_1.CURRENT_SCHEMA_VERSION) {
            throw new Error(`Unexpected schema version: ${schema.version}`);
        }
        const renderer = new markdown_render_1.MarkdownRenderer({
            language: options.language,
            packageName: assembly.name,
            packageVersion: assembly.version,
        });
        if (submodules.length) {
            ref.section(renderer.visitSubmodules(submodules, fileSuffix));
        }
        if (schema.apiReference) {
            ref.section(renderer.visitConstructs(schema.apiReference.constructs));
            ref.section(renderer.visitStructs(schema.apiReference.structs));
            ref.section(renderer.visitClasses(schema.apiReference.classes));
            ref.section(renderer.visitInterfaces(schema.apiReference.interfaces));
            ref.section(renderer.visitEnums(schema.apiReference.enums));
        }
        const documentation = new markdown_doc_1.MarkdownDocument();
        documentation.section(ref);
        return documentation;
    }
    /**
     * Generate markdown.
     */
    async toJson(options) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const language = (_a = options.language) !== null && _a !== void 0 ? _a : transpile_1.Language.TYPESCRIPT;
        const loose = (_b = options.loose) !== null && _b !== void 0 ? _b : true;
        const validate = (_c = options.validate) !== null && _c !== void 0 ? _c : false;
        const allSubmodules = (_d = options.allSubmodules) !== null && _d !== void 0 ? _d : false;
        // Get the TS assembly first to check what languages are supported before calling rosetta
        const tsAssembly = await this.createAssembly(undefined, { loose, validate });
        const isSupported = language === transpile_1.Language.TYPESCRIPT || language.isValidConfiguration((_e = tsAssembly === null || tsAssembly === void 0 ? void 0 : tsAssembly.targets) === null || _e === void 0 ? void 0 : _e[language.targetName]);
        this.assemblyFqn = `${tsAssembly.name}@${tsAssembly.version}`;
        if (!isSupported) {
            throw new __1.LanguageNotSupportedError(`Laguage ${language} is not supported for package ${this.assemblyFqn}`);
        }
        let submoduleStr = options.submodule;
        if (allSubmodules && submoduleStr) {
            throw new Error('Cannot call toJson with allSubmodules and a specific submodule both selected.');
        }
        const { assembly, transpile } = await this.languageSpecific(language, { loose, validate });
        const targets = assembly.targets;
        if (!targets) {
            throw new Error(`Assembly ${this.assemblyFqn} does not have any targets defined`);
        }
        const submodule = submoduleStr ? this.findSubmodule(assembly, submoduleStr) : undefined;
        let readme;
        if ((_f = options === null || options === void 0 ? void 0 : options.readme) !== null && _f !== void 0 ? _f : false) {
            readme = new readme_1.Readme(transpile, assembly, submodule).render();
        }
        let apiReference;
        if ((_g = options === null || options === void 0 ? void 0 : options.apiReference) !== null && _g !== void 0 ? _g : true) {
            try {
                apiReference = new api_reference_1.ApiReference(transpile, assembly, submodule, allSubmodules);
            }
            catch (error) {
                if (!(error instanceof Error)) {
                    throw error;
                }
                throw (_h = maybeCorruptedAssemblyError(error)) !== null && _h !== void 0 ? _h : error;
            }
        }
        const contents = {
            version: schema_1.CURRENT_SCHEMA_VERSION,
            language: language.toString(),
            metadata: {
                packageName: assembly.name,
                packageVersion: assembly.version,
                submodule: (0, schema_1.submodulePath)(submodule),
            },
            readme: readme === null || readme === void 0 ? void 0 : readme.render(),
            apiReference: apiReference === null || apiReference === void 0 ? void 0 : apiReference.toJson(),
        };
        return new json_1.Json(contents);
    }
    async toMarkdown(options) {
        const json = (await this.toJson(options)).content;
        return markdown_render_1.MarkdownRenderer.fromSchema(json, {
            anchorFormatter: options.anchorFormatter,
            linkFormatter: options.linkFormatter,
            typeFormatter: options.typeFormatter,
            header: options.header,
        });
    }
    addCleanupDirectory(directory) {
        this.cleanupDirectories.add(directory);
    }
    /**
     * Removes any internal working directories.
     */
    async cleanup() {
        for (const dir of [...this.cleanupDirectories]) {
            await fs.remove(dir);
            this.cleanupDirectories.delete(dir);
        }
    }
    async languageSpecific(lang, options) {
        const { rosettaTarget, transpile } = exports.LANGUAGE_SPECIFIC[lang.toString()];
        return { assembly: await this.createAssembly(rosettaTarget, options), transpile };
    }
    /**
     * Lookup a submodule by a submodule name.
     *
     * The contract of this function is historically quite confused: the submodule
     * name can be either an FQN (`asm.sub1.sub2`) or just a submodule name
     * (`sub1` or `sub1.sub2`).
     *
     * This is sligthly complicated by ambiguity: `asm.asm.package` and
     * `asm.package` can both exist, and which one do you mean when you say
     * `asm.package`?
     *
     * We prefer an FQN match if possible (`asm.sub1.sub2`), but will accept a
     * root-relative submodule name as well (`sub1.sub2`).
     */
    findSubmodule(assembly, submodule) {
        const fqnSubs = assembly.allSubmodules.filter((s) => s.fqn === submodule);
        if (fqnSubs.length === 1) {
            return fqnSubs[0];
        }
        // Fallback: assembly-relative name
        const relSubs = assembly.allSubmodules.filter((s) => s.fqn === `${assembly.name}.${submodule}`);
        if (relSubs.length === 1) {
            console.error(`[WARNING] findSubmodule() is being called with a relative submodule name: '${submodule}'. Prefer the absolute name: '${assembly.name}.${submodule}'`);
            return relSubs[0];
        }
        if (fqnSubs.length + relSubs.length === 0) {
            throw new Error(`Submodule ${submodule} not found in assembly ${assembly.name}@${assembly.version} (neither as '${submodule}' nor as '${assembly.name}.${submodule})`);
        }
        // Almost impossible that this would be true
        if (fqnSubs.length > 1) {
            throw new Error(`Found multiple submodules with FQN: ${submodule} in assembly ${assembly.name}@${assembly.version}`);
        }
        throw new Error(`Found multiple submodules with relative name: ${submodule} in assembly ${assembly.name}@${assembly.version}`);
    }
    async createAssembly(language, options) {
        const cacheKey = `lang:${language !== null && language !== void 0 ? language : 'ts'}.loose:${options.loose}.validate:${options.validate}`;
        const cached = this.assembliesCache.get(cacheKey);
        if (cached) {
            return cached;
        }
        const created = await withTempDir(async (workdir) => {
            // always better not to pollute an externally provided directory
            await fs.copy(this.assembliesDir, workdir, {
                // Ensure we don't try to copy socket files, as they can be found under .git when
                // core.fsmonitor is enabled.
                filter: async (src) => {
                    const stat = await fs.stat(src);
                    return stat.isFile() || stat.isDirectory();
                },
            });
            const ts = new reflect.TypeSystem();
            // assembliesDir might include backslashes on Windows.
            // The glob pattern must only used forward slashes, so we pass the assembliesDir as CWD which does not have this restriction
            const assemblies = await glob.promise(`**/${spec_1.SPEC_FILE_NAME}`, {
                cwd: path.normalize(this.assembliesDir),
                absolute: true,
            });
            for (let dotJsii of assemblies) {
                // we only transliterate the top level assembly and not the entire type-system.
                // note that the only reason to translate dependant assemblies is to show code examples
                // for expanded python arguments - which we don't to right now anyway.
                // we don't want to make any assumption of the directory structure, so this is the most
                // robust way to detect the root assembly.
                const spec = (0, spec_1.loadAssemblyFromFile)(dotJsii, false); // don't validate we only need this for the spec name
                if (language && spec.name === this.assemblyName) {
                    const packageDir = path.dirname(dotJsii);
                    try {
                        await (0, jsii_rosetta_1.transliterateAssembly)([packageDir], [language], { loose: options.loose, unknownSnippets: jsii_rosetta_1.UnknownSnippetMode.FAIL, outdir: workdir });
                    }
                    catch (e) {
                        throw new __1.TransliterationError(`Could not transliterate snippets in '${this.assemblyFqn}' to ${language}: ${e.message}`);
                    }
                    dotJsii = path.join(workdir, `${spec_1.SPEC_FILE_NAME}.${language}`);
                }
                await loadAssembly(dotJsii, ts, options);
            }
            return ts.findAssembly(this.assemblyName);
        });
        this.assembliesCache.set(cacheKey, created);
        return created;
    }
}
exports.Documentation = Documentation;
exports.LANGUAGE_SPECIFIC = {
    [transpile_1.Language.PYTHON.toString()]: {
        transpile: new python_1.PythonTranspile(),
        rosettaTarget: jsii_rosetta_1.TargetLanguage.PYTHON,
    },
    [transpile_1.Language.TYPESCRIPT.toString()]: {
        transpile: new typescript_1.TypeScriptTranspile(),
        rosettaTarget: undefined, // no transpilation needed
    },
    [transpile_1.Language.JAVA.toString()]: {
        transpile: new java_1.JavaTranspile(),
        rosettaTarget: jsii_rosetta_1.TargetLanguage.JAVA,
    },
    [transpile_1.Language.CSHARP.toString()]: {
        transpile: new csharp_1.CSharpTranspile(),
        rosettaTarget: jsii_rosetta_1.TargetLanguage.CSHARP,
    },
    [transpile_1.Language.GO.toString()]: {
        transpile: new go_1.GoTranspile(),
        rosettaTarget: jsii_rosetta_1.TargetLanguage.GO,
    },
};
/**
 * Loads the specified assembly document into the provided type system, and
 * recursively attempt to load the assembly's dependencies.
 *
 * @param dotJsii the assembly to be loaded.
 * @param ts the type system in which the assembly is to be loaded.
 * @param validate whether assemblies should be validated.
 */
async function loadAssembly(dotJsii, ts, { validate } = {}) {
    var _a;
    const loaded = await ts.load(dotJsii, { validate });
    for (const dep of Object.keys((_a = loaded.spec.dependencies) !== null && _a !== void 0 ? _a : {})) {
        if (ts.tryFindAssembly(dep) != null) {
            // dependency already loaded... move on...
            continue;
        }
        try {
            // Resolve the dependencies relative to the dependent's package root.
            const depPath = require.resolve(`${dep}/.jsii`, { paths: [path.dirname(dotJsii)] });
            await loadAssembly(depPath, ts, { validate });
        }
        catch {
            // Silently ignore any resolution errors... We'll fail later if the dependency is
            // ACTUALLY required, but it's okay to omit it if none of its types are actually exposed
            // by the translated assembly's own API.
        }
    }
    return loaded;
}
async function withTempDir(work) {
    const workdir = await fs.mkdtemp(path.join(os.tmpdir(), path.sep));
    const cwd = process.cwd();
    try {
        process.chdir(workdir);
        // wait for the work to be completed before
        // we cleanup the work environment.
        return await work(workdir);
    }
    finally {
        process.chdir(cwd);
        await fs.remove(workdir);
    }
}
function extractPackageName(spec) {
    const firstAt = spec.indexOf('@');
    if (firstAt === 0) {
        const lastAt = spec.indexOf('@', firstAt + 1);
        if (lastAt === -1) {
            // @aws-cdk/aws-ecr
            return spec;
        }
        else {
            // @aws-cdk/aws-ecr@2.0.0
            return spec.substring(0, lastAt);
        }
    }
    if (firstAt > 0) {
        // aws-cdk-lib@2.0.0
        return spec.substring(0, firstAt);
    }
    // aws-cdk-lib
    return spec;
}
/**
 * Return a `CorruptedAssemblyError` if the error matches, undefined otherwise.
 *
 * Note that an 'not found in assembly` can be thrown in two cases:
 *
 * 1. Direct usage of `assembly.findType(fqn)`
 *
 *    In this case the error could be caused by a wrong FQN being passed to the function. This is not considered
 *    a corrupted assembly since the caller might be passing an FQN from a different assembly.
 *
 * 2. Implicit usage of `assembly.findType(fqn)` by calling `.type` (e.g `parameter.type`)
 *
 *    In this case the assembly we look in is always the same assembly the type itself comes from, and if it doesn't exist,
 *    then the assembly is considered corrupt.
 */
function maybeCorruptedAssemblyError(error) {
    const match = error.message.match(NOT_FOUND_IN_ASSEMBLY_REGEX);
    if (!match) {
        return;
    }
    const searchedAssembly = match[2];
    const typeAssembly = match[1];
    if (searchedAssembly === typeAssembly) {
        return new __1.CorruptedAssemblyError(error.message);
    }
    return;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZG9jdW1lbnRhdGlvbi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9kb2NnZW4vdmlldy9kb2N1bWVudGF0aW9uLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaWdCQSxnREFxQkM7QUF0aEJELHVDQUF5QjtBQUN6QiwyQ0FBNkI7QUFDN0IscUNBQWtFO0FBQ2xFLDZDQUErQjtBQUMvQixtREFBcUM7QUFDckMsc0RBQXdDO0FBQ3hDLCtDQUF5RjtBQUN6RixpQ0FBNkI7QUFDN0IsbURBQStDO0FBQy9DLHFDQUFrQztBQUNsQyw2QkFBZ0c7QUFDaEcseUNBQXNDO0FBQ3RDLHlEQUEwRDtBQUMxRCwrREFBd0Y7QUFDeEYsc0NBQTBFO0FBQzFFLGdEQUFzRDtBQUN0RCx3Q0FBOEM7QUFDOUMsNENBQWtEO0FBQ2xELGdEQUFzRDtBQUN0RCxzREFBNkQ7QUFDN0Qsd0RBQThEO0FBRTlELG1GQUFtRjtBQUNuRixNQUFNLDJCQUEyQixHQUFHLDZDQUE2QyxDQUFDO0FBK0ZsRjs7R0FFRztBQUNILE1BQWEsYUFBYTtJQUV4Qjs7Ozs7Ozs7Ozs7T0FXRztJQUNJLE1BQU0sQ0FBQyxLQUFLLENBQUMsVUFBVSxDQUFDLE1BQWMsRUFBRSxVQUEwQyxFQUFFOztRQUN6RixNQUFNLE9BQU8sR0FBRyxNQUFNLEVBQUUsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsTUFBTSxFQUFFLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7UUFFbkUsTUFBTSxHQUFHLEdBQUcsSUFBSSxVQUFHLENBQUMsT0FBTyxDQUFDLENBQUM7UUFFN0IsSUFBSSxNQUFBLE9BQU8sQ0FBQyxPQUFPLG1DQUFJLElBQUksRUFBRSxDQUFDO1lBQzVCLE9BQU8sQ0FBQyxHQUFHLENBQUMsc0JBQXNCLE1BQU0sRUFBRSxDQUFDLENBQUM7UUFDOUMsQ0FBQztRQUVELE1BQU0s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UUFDOUMsSUFBSSxNQUFNLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQztZQUNsQixtQkFBbUI7WUFDbkIsT0FBTyxJQUFJLENBQUM7UUFDZCxDQUFDO2FBQU0sQ0FBQztZQUNOLHlCQUF5QjtZQUN6QixPQUFPLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDO1FBQ25DLENBQUM7SUFDSCxDQUFDO0lBRUQsSUFBSSxPQUFPLEdBQUcsQ0FBQyxFQUFFLENBQUM7UUFDaEIsb0JBQW9CO1FBQ3BCLE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLEVBQUUsT0FBTyxDQUFDLENBQUM7SUFDcEMsQ0FBQztJQUVELGNBQWM7SUFDZCxPQUFPLElBQUksQ0FBQztBQUNkLENBQUM7QUFFRDs7Ozs7Ozs7Ozs7Ozs7R0FjRztBQUNILFNBQVMsMkJBQTJCLENBQUMsS0FBWTtJQUUvQyxNQUFNLEtBQUssR0FBRyxLQUFLLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQywyQkFBMkIsQ0FBQyxDQUFDO0lBQy9ELElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQztRQUNYLE9BQU87SUFDVCxDQUFDO0lBQ0QsTUFBTSxnQkFBZ0IsR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDbEMsTUFBTSxZQUFZLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBRTlCLElBQUksZ0JBQWdCLEtBQUssWUFBWSxFQUFFLENBQUM7UUFDdEMsT0FBTyxJQUFJLDBCQUFzQixDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUNuRCxDQUFDO0lBQ0QsT0FBTztBQUNULENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBvcyBmcm9tICdvcyc7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IHsgbG9hZEFzc2VtYmx5RnJvbUZpbGUsIFNQRUNfRklMRV9OQU1FIH0gZnJvbSAnQGpzaWkvc3BlYyc7XG5pbXBvcnQgKiBhcyBmcyBmcm9tICdmcy1leHRyYSc7XG5pbXBvcnQgKiBhcyBnbG9iIGZyb20gJ2dsb2ItcHJvbWlzZSc7XG5pbXBvcnQgKiBhcyByZWZsZWN0IGZyb20gJ2pzaWktcmVmbGVjdCc7XG5pbXBvcnQgeyBUYXJnZXRMYW5ndWFnZSwgdHJhbnNsaXRlcmF0ZUFzc2VtYmx5LCBVbmtub3duU25pcHBldE1vZGUgfSBmcm9tICdqc2lpLXJvc2V0dGEnO1xuaW1wb3J0IHsgTnBtIH0gZnJvbSAnLi9fbnBtJztcbmltcG9ydCB7IEFwaVJlZmVyZW5jZSB9IGZyb20gJy4vYXBpLXJlZmVyZW5jZSc7XG5pbXBvcnQgeyBSZWFkbWUgfSBmcm9tICcuL3JlYWRtZSc7XG5pbXBvcnQgeyBDb3JydXB0ZWRBc3NlbWJseUVycm9yLCBMYW5ndWFnZU5vdFN1cHBvcnRlZEVycm9yLCBUcmFuc2xpdGVyYXRpb25FcnJvciB9IGZyb20gJy4uLy4uJztcbmltcG9ydCB7IEpzb24gfSBmcm9tICcuLi9yZW5kZXIvanNvbic7XG5pbXBvcnQgeyBNYXJrZG93bkRvY3VtZW50IH0gZnJvbSAnLi4vcmVuZGVyL21hcmtkb3duLWRvYyc7XG5pbXBvcnQgeyBNYXJrZG93bkZvcm1hdHRpbmdPcHRpb25zLCBNYXJrZG93blJlbmRlcmVyIH0gZnJvbSAnLi4vcmVuZGVyL21hcmtkb3duLXJlbmRlcic7XG5pbXBvcnQgeyBTY2hlbWEsIENVUlJFTlRfU0NIRU1BX1ZFUlNJT04sIHN1Ym1vZHVsZVBhdGggfSBmcm9tICcuLi9zY2hlbWEnO1xuaW1wb3J0IHsgQ1NoYXJwVHJhbnNwaWxlIH0gZnJvbSAnLi4vdHJhbnNwaWxlL2NzaGFycCc7XG5pbXBvcnQgeyBHb1RyYW5zcGlsZSB9IGZyb20gJy4uL3RyYW5zcGlsZS9nbyc7XG5pbXBvcnQgeyBKYXZhVHJhbnNwaWxlIH0gZnJvbSAnLi4vdHJhbnNwaWxlL2phdmEnO1xuaW1wb3J0IHsgUHl0aG9uVHJhbnNwaWxlIH0gZnJvbSAnLi4vdHJhbnNwaWxlL3B5dGhvbic7XG5pbXBvcnQgeyBUcmFuc3BpbGUsIExhbmd1YWdlIH0gZnJvbSAnLi4vdHJhbnNwaWxlL3RyYW5zcGlsZSc7XG5pbXBvcnQgeyBUeXBlU2NyaXB0VHJhbnNwaWxlIH0gZnJvbSAnLi4vdHJhbnNwaWxlL3R5cGVzY3JpcHQnO1xuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vYXdzL2pzaWkvYmxvYi9tYWluL3BhY2thZ2VzL2pzaWktcmVmbGVjdC9saWIvYXNzZW1ibHkudHMjTDE3NVxuY29uc3QgTk9UX0ZPVU5EX0lOX0FTU0VNQkxZX1JFR0VYID0gL1R5cGUgJyguKilcXC4uKicgbm90IGZvdW5kIGluIGFzc2VtYmx5ICguKikkLztcblxuLyoqXG4gKiBPcHRpb25zIGZvciByZW5kZXJpbmcgYSBgRG9jdW1lbnRhdGlvbmAgb2JqZWN0LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFJlbmRlck9wdGlvbnMgZXh0ZW5kcyBUcmFuc2xpdGVyYXRpb25PcHRpb25zIHtcbiAgLyoqXG4gICAqIFdoaWNoIGxhbmd1YWdlIHRvIGdlbmVyYXRlIGRvY3MgZm9yLlxuICAgKi9cbiAgcmVhZG9ubHkgbGFuZ3VhZ2U6IExhbmd1YWdlO1xuXG4gIC8qKlxuICAgKiBJbmNsdWRlIGEgZ2VuZXJhdGVkIGFwaSByZWZlcmVuY2UgaW4gdGhlIGRvY3VtZW50YXRpb24uXG4gICAqXG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIHJlYWRvbmx5IGFwaVJlZmVyZW5jZT86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIEluY2x1ZGUgdGhlIHVzZXIgZGVmaW5lZCBSRUFETUUubWQgaW4gdGhlIGRvY3VtZW50YXRpb24uXG4gICAqXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICByZWFkb25seSByZWFkbWU/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBkb2N1bWVudGF0aW9uIG9ubHkgZm9yIGEgc3BlY2lmaWMgc3VibW9kdWxlLlxuICAgKlxuICAgKiBAZGVmYXVsdCAtIERvY3VtZW50YXRpb24gaXMgZ2VuZXJhdGVkIGZvciB0aGUgcm9vdCBtb2R1bGUgb25seS5cbiAgICovXG4gIHJlYWRvbmx5IHN1Ym1vZHVsZT86IHN0cmluZztcblxuICAvKipcbiAgICogR2VuZXJhdGUgYSBzaW5nbGUgZG9jdW1lbnQgd2l0aCBBUElzIGZyb20gYWxsIGFzc2VtYmx5IHN1Ym1vZHVsZXNcbiAgICogKGluY2x1ZGluZyB0aGUgcm9vdCkuXG4gICAqXG4gICAqIE5vdGU6IG9ubHkgdGhlIHJvb3QtbGV2ZWwgUkVBRE1FIGlzIGluY2x1ZGVkLlxuICAgKlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgcmVhZG9ubHkgYWxsU3VibW9kdWxlcz86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHJhbnNsaXRlcmF0aW9uT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIGlnbm9yZSBtaXNzaW5nIGZpeHR1cmUgZmlsZXMgdGhhdCB3aWxsIHByZXZlbnQgdHJhbnNsaXRlcmF0aW5nXG4gICAqIHNvbWUgY29kZSBzbmlwcGV0IGV4YW1wbGVzLlxuICAgKlxuICAgKiBAZGVmYXVsdCB0cnVlXG4gICAqL1xuICByZWFkb25seSBsb29zZT86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gdmFsaWRhdGUganNpaSBhc3NlbWJsaWVzIGFnYWluc3QgdGhlIGpzaWkgc2NoZW1hIGJlZm9yZVxuICAgKiB1c2luZyB0aGVtLlxuICAgKlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgcmVhZG9ubHkgdmFsaWRhdGU/OiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE1hcmtkb3duUmVuZGVyT3B0aW9ucyBleHRlbmRzIFJlbmRlck9wdGlvbnMsIE1hcmtkb3duRm9ybWF0dGluZ09wdGlvbnMge31cblxuLyoqXG4gKiBPcHRpb25zIGZvciBjcmVhdGluZyBhIGBEb2N1bWVudGF0aW9uYCBvYmplY3QgdXNpbmcgdGhlIGBmcm9tTG9jYWxQYWNrYWdlYCBmdW5jdGlvbi5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBGb3JMb2NhbFBhY2thZ2VEb2N1bWVudGF0aW9uT3B0aW9ucyB7XG5cbiAgLyoqXG4gICAqIEEgbG9jYWwgZGlyZWN0b3J5IGNvbnRhaW5pbmcganNpaSBhc3NlbWJseSBmaWxlcyB0aGF0IHdpbGxcbiAgICogY29tcHJpc2UgdGhlIHR5cGUtc3lzdGVtLlxuICAgKlxuICAgKiBAZGVmYXVsdCAtIHRoZSByb290IHBhY2thZ2UgZGlyZWN0b3J5IHdpbGwgYmUgdXNlZC5cbiAgICovXG4gIHJlYWRvbmx5IGFzc2VtYmxpZXNEaXI/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRm9yUGFja2FnZURvY3VtZW50YXRpb25PcHRpb25zIHtcbiAgLyoqXG4gICAqIFdoZXRoZXIgdmVyYm9zZSBsb2dnaW5nIGlzIHRvIGJlIHBlcmZvcm1lZC5cbiAgICpcbiAgICogQGRlZmF1bHQgdHJ1ZVxuICAgKi9cbiAgcmVhZG9ubHkgdmVyYm9zZT86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIEEgZnVuY3Rpb24gdG8gcnVuIGFmdGVyIHJ1bm5pbmcgYG5wbSBpbnN0YWxsYCBmb3IgdGhlIHRhcmdldCBwYWNrYWdlLiBUaGlzXG4gICAqIGV4aXN0cyBvbmx5IGZvciB0ZXN0aW5nIHB1cnBvc2VzIGFuZCBzaG91bGQgbm90IGJlIHVzZWQgYnkgY29uc3VtZXJzIG9mXG4gICAqIHRoaXMgbW9kdWxlLlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHJlYWRvbmx5IF9wb3N0SW5zdGFsbD86IChkaXI6IHN0cmluZykgPT4gUHJvbWlzZTx2b2lkPjtcbn1cblxuLyoqXG4gKiBSZW5kZXIgZG9jdW1lbnRhdGlvbiBwYWdlcyBmb3IgYSBqc2lpIGxpYnJhcnkuXG4gKi9cbmV4cG9ydCBjbGFzcyBEb2N1bWVudGF0aW9uIHtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgYERvY3VtZW50YXRpb25gIG9iamVjdCBmcm9tIGEgcGFja2FnZSBpbnN0YWxsYWJsZSBieSBucG0uXG4gICAqXG4gICAqIE5vdGUgdGhhdCB0aGlzIG1ldGhvZCBpbnN0YWxscyB0aGUgdGFyZ2V0IHBhY2thZ2UgdG8gdGhlIGxvY2FsIGZpbGUtc3lzdGVtLiBNYWtlIHN1cmVcbiAgICogdG8gY2FsbCBgRG9jdW1lbnRhdGlvbi5jbGVhbnVwYCBvbmNlIHlvdSBhcmUgZG9uZSByZW5kZXJpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB0YXJnZXQgLSBUaGUgdGFyZ2V0IHRvIGluc3RhbGwuIFRoaXMgY2FuIGVpdGhlciBiZSBhIGxvY2FsIHBhdGggb3IgYSByZWdpc3RyeSBpZGVudGlmaWVyIChlLmcgPG5hbWU+QDx2ZXJzaW9uPilcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBBZGRpdGlvbmFsIG9wdGlvbnMuXG4gICAqXG4gICAqIEB0aHJvd3MgTm9TcGFjZUxlZnRPbkRldmljZSBpZiB0aGUgaW5zdGFsbGF0aW9uIGZhaWxzIGR1ZSB0byBydW5uaW5nIG91dCBvZiBkaXNrIHNwYWNlXG4gICAqIEB0aHJvd3MgTnBtRXJyb3IgaWYgc29tZSBgbnBtYCBjb21tYW5kIGZhaWxzIHdoZW4gcHJlcGFyaW5nIHRoZSB3b3JraW5nIHNldFxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBhc3luYyBmb3JQYWNrYWdlKHRhcmdldDogc3RyaW5nLCBvcHRpb25zOiBGb3JQYWNrYWdlRG9jdW1lbnRhdGlvbk9wdGlvbnMgPSB7fSk6IFByb21pc2U8RG9jdW1lbnRhdGlvbj4ge1xuICAgIGNvbnN0IHdvcmtkaXIgPSBhd2FpdCBmcy5ta2R0ZW1wKHBhdGguam9pbihvcy50bXBkaXIoKSwgcGF0aC5zZXApKTtcblxuICAgIGNvbnN0IG5wbSA9IG5ldyBOcG0od29ya2Rpcik7XG5cbiAgICBpZiAob3B0aW9ucy52ZXJib3NlID8/IHRydWUpIHtcbiAgICAgIGNvbnNvbGUubG9nKGBJbnN0YWxsaW5nIHBhY2thZ2UgJHt0YXJnZXR9YCk7XG4gICAgfVxuXG4gICAgY29uc3QgbmFtZSA9IGF3YWl0IG5wbS5pbnN0YWxsKHRhcmdldCk7XG5cbiAgICBpZiAob3B0aW9ucy5fcG9zdEluc3RhbGwgIT0gbnVsbCkge1xuICAgICAgYXdhaXQgb3B0aW9ucy5fcG9zdEluc3RhbGwod29ya2Rpcik7XG4gICAgfVxuXG4gICAgY29uc3QgZG9jcyA9IGF3YWl0IERvY3VtZW50YXRpb24uZm9yUHJvamVjdChwYXRoLmpvaW4od29ya2RpciwgJ25vZGVfbW9kdWxlcycsIG5hbWUpLCB7IC4uLm9wdGlvbnMsIGFzc2VtYmxpZXNEaXI6IHdvcmtkaXIgfSk7XG5cbiAgICAvLyB3ZSBjYW5ub3QgZGVsZXRlIHRoaXMgZGlyZWN0b3J5IGltbWVkaWF0ZWx5IHNpbmNlIGl0IGlzIHVzZWQgZHVyaW5nIGByZW5kZXJgIGNhbGxzLlxuICAgIC8vIGluc3RlYWQgd2UgcmVnaXN0ZXIgaXQgc28gdGhhdCBjYWxsZXJzIGNhbiBjbGVhbiBpdCB1cCBieSBjYWxsaW5nIHRoZSBgY2xlYW51cGAgbWV0aG9kLlxuICAgIGRvY3MuYWRkQ2xlYW51cERpcmVjdG9yeSh3b3JrZGlyKTtcblxuICAgIHJldHVybiBkb2NzO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGBEb2N1bWVudGF0aW9uYCBvYmplY3QgZnJvbSBhIGxvY2FsIGRpcmVjdG9yeSBjb250YWluaW5nIGEgbm9kZSBwcm9qZWN0LlxuICAgKlxuICAgKiBAcGFyYW0gcm9vdCAtIFRoZSBsb2NhbCBkaXJlY3RvcnkgcGF0aC4gTXVzdCBjb250YWluIGEgcGFja2FnZS5qc29uIGZpbGUuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gQWRkaXRpb25hbCBvcHRpb25zLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBhc3luYyBmb3JQcm9qZWN0KHJvb3Q6IHN0cmluZywgb3B0aW9uczogRm9yTG9jYWxQYWNrYWdlRG9jdW1lbnRhdGlvbk9wdGlvbnMgPSB7fSk6IFByb21pc2U8RG9jdW1lbnRhdGlvbj4ge1xuICAgIGNvbnN0IG1hbmlmZXN0UGF0aCA9IHBhdGguam9pbihyb290LCAncGFja2FnZS5qc29uJyk7XG4gICAgaWYgKCEoYXdhaXQgZnMucGF0aEV4aXN0cyhtYW5pZmVzdFBhdGgpKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gbG9jYXRlICR7bWFuaWZlc3RQYXRofWApO1xuICAgIH1cblxuICAgIC8vIG5vcm1hbGx5IHRoZSBhc3NlbWJsaWVzIGFyZSBsb2NhdGVkIGluIHN1YmRpcmVjdG9yaWVzXG4gICAgLy8gb2YgdGhlIHJvb3QgcGFja2FnZSBkaXIgKGkuZSAuL25vZGVfbW9kdWxlcylcbiAgICBjb25zdCBhc3NlbWJsaWVzRGlyID0gb3B0aW9ucz8uYXNzZW1ibGllc0RpciA/PyByb290O1xuXG4gICAgY29uc3QgeyBuYW1lIH0gPSBKU09OLnBhcnNlKGF3YWl0IGZzLnJlYWRGaWxlKG1hbmlmZXN0UGF0aCwgJ3V0Zi04JykpO1xuICAgIHJldHVybiBEb2N1bWVudGF0aW9uLmZvckFzc2VtYmx5KG5hbWUsIGFzc2VtYmxpZXNEaXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGBEb2N1bWVudGF0aW9uYCBvYmplY3QgZm9yIGEgc3BlY2lmaWMgYXNzZW1ibHkgZnJvbSBhIGRpcmVjdG9yeSBvZiBhc3NlbWJsaWVzLlxuICAgKlxuICAgKiBAcGFyYW0gYXNzZW1ibHlOYW1lIC0gVGhlIGFzc2VtYmx5IG5hbWUuXG4gICAqIEBwYXJhbSBhc3NlbWJsaWVzRGlyIC0gVGhlIGRpcmVjdG9yeSBjb250YWluaW5nIHRoZSBhc3NlbWJsaWVzIHRoYXQgY29tcHJpc2UgdGhlIHR5cGUtc3lzdGVtLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBhc3luYyBmb3JBc3NlbWJseShhc3NlbWJseU5hbWU6IHN0cmluZywgYXNzZW1ibGllc0Rpcjogc3RyaW5nKTogUHJvbWlzZTxEb2N1bWVudGF0aW9uPiB7XG4gICAgcmV0dXJuIG5ldyBEb2N1bWVudGF0aW9uKGFzc2VtYmx5TmFtZSwgYXNzZW1ibGllc0Rpcik7XG4gIH1cblxuICBwcml2YXRlIHJlYWRvbmx5IGNsZWFudXBEaXJlY3RvcmllczogU2V0PHN0cmluZz4gPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgcHJpdmF0ZSByZWFkb25seSBhc3NlbWJsaWVzQ2FjaGU6IE1hcDxzdHJpbmcsIHJlZmxlY3QuQXNzZW1ibHk+ID0gbmV3IE1hcDxzdHJpbmcsIHJlZmxlY3QuQXNzZW1ibHk+KCk7XG4gIHByaXZhdGUgYXNzZW1ibHlGcW46IHN0cmluZyB8IHVuZGVmaW5lZDtcblxuICBwcml2YXRlIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcmVhZG9ubHkgYXNzZW1ibHlOYW1lOiBzdHJpbmcsXG4gICAgcHJpdmF0ZSByZWFkb25seSBhc3NlbWJsaWVzRGlyOiBzdHJpbmcsXG4gICkge31cblxuICAvKipcbiAgICogTGlzdCBhbGwgc3VibW9kdWxlcyBpbiB0aGUgYXNzZW1ibHkuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgbGlzdFN1Ym1vZHVsZXMoKSB7XG4gICAgY29uc3QgdHNBc3NlbWJseSA9IGF3YWl0IHRoaXMuY3JlYXRlQXNzZW1ibHkodW5kZWZpbmVkLCB7IGxvb3NlOiB0cnVlLCB2YWxpZGF0ZTogZmFsc2UgfSk7XG4gICAgcmV0dXJuIHRzQXNzZW1ibHkuYWxsU3VibW9kdWxlcztcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyB0b0luZGV4TWFya2Rvd24oZmlsZVN1ZmZpeDpzdHJpbmcsIG9wdGlvbnM6IFJlbmRlck9wdGlvbnMpIHtcbiAgICBjb25zdCBhc3NlbWJseSA9IGF3YWl0IHRoaXMuY3JlYXRlQXNzZW1ibHkodW5kZWZpbmVkLCB7IGxvb3NlOiB0cnVlLCB2YWxpZGF0ZTogZmFsc2UgfSk7XG4gICAgY29uc3Qgc3VibW9kdWxlcyA9IGF3YWl0IHRoaXMubGlzdFN1Ym1vZHVsZXMoKTtcbiAgICBjb25zdCBzY2hlbWEgPSAoYXdhaXQgdGhpcy50b0pzb24oe1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIHN1Ym1vZHVsZTogdW5kZWZpbmVkLFxuICAgICAgYWxsU3VibW9kdWxlczogZmFsc2UsXG4gICAgfSkpLmNvbnRlbnQ7XG5cbiAgICBjb25zdCByZWYgPSBuZXcgTWFya2Rvd25Eb2N1bWVudCh7IGhlYWRlcjogeyB0aXRsZTogJ0FQSSBSZWZlcmVuY2UnIH0sIGlkOiAnYXBpLXJlZmVyZW5jZScgfSk7XG5cbiAgICBpZiAoc2NoZW1hLnZlcnNpb24gIT09IENVUlJFTlRfU0NIRU1BX1ZFUlNJT04pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBzY2hlbWEgdmVyc2lvbjogJHtzY2hlbWEudmVyc2lvbn1gKTtcbiAgICB9XG5cbiAgICBjb25zdCByZW5kZXJlciA9IG5ldyBNYXJrZG93blJlbmRlcmVyKHtcbiAgICAgIGxhbmd1YWdlOiBvcHRpb25zLmxhbmd1YWdlLFxuICAgICAgcGFja2FnZU5hbWU6IGFzc2VtYmx5Lm5hbWUsXG4gICAgICBwYWNrYWdlVmVyc2lvbjogYXNzZW1ibHkudmVyc2lvbixcbiAgICB9KTtcblxuICAgIGlmIChzdWJtb2R1bGVzLmxlbmd0aCkge1xuICAgICAgcmVmLnNlY3Rpb24ocmVuZGVyZXIudmlzaXRTdWJtb2R1bGVzKHN1Ym1vZHVsZXMsIGZpbGVTdWZmaXgpKTtcbiAgICB9XG5cbiAgICBpZiAoc2NoZW1hLmFwaVJlZmVyZW5jZSkge1xuICAgICAgcmVmLnNlY3Rpb24ocmVuZGVyZXIudmlzaXRDb25zdHJ1Y3RzKHNjaGVtYS5hcGlSZWZlcmVuY2UuY29uc3RydWN0cykpO1xuICAgICAgcmVmLnNlY3Rpb24ocmVuZGVyZXIudmlzaXRTdHJ1Y3RzKHNjaGVtYS5hcGlSZWZlcmVuY2Uuc3RydWN0cykpO1xuICAgICAgcmVmLnNlY3Rpb24ocmVuZGVyZXIudmlzaXRDbGFzc2VzKHNjaGVtYS5hcGlSZWZlcmVuY2UuY2xhc3NlcykpO1xuICAgICAgcmVmLnNlY3Rpb24ocmVuZGVyZXIudmlzaXRJbnRlcmZhY2VzKHNjaGVtYS5hcGlSZWZlcmVuY2UuaW50ZXJmYWNlcykpO1xuICAgICAgcmVmLnNlY3Rpb24ocmVuZGVyZXIudmlzaXRFbnVtcyhzY2hlbWEuYXBpUmVmZXJlbmNlLmVudW1zKSk7XG4gICAgfVxuXG4gICAgY29uc3QgZG9jdW1lbnRhdGlvbiA9IG5ldyBNYXJrZG93bkRvY3VtZW50KCk7XG4gICAgZG9jdW1lbnRhdGlvbi5zZWN0aW9uKHJlZik7XG4gICAgcmV0dXJuIGRvY3VtZW50YXRpb247XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgbWFya2Rvd24uXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgdG9Kc29uKG9wdGlvbnM6IFJlbmRlck9wdGlvbnMpOiBQcm9taXNlPEpzb248U2NoZW1hPj4ge1xuXG4gICAgY29uc3QgbGFuZ3VhZ2UgPSBvcHRpb25zLmxhbmd1YWdlID8/IExhbmd1YWdlLlRZUEVTQ1JJUFQ7XG4gICAgY29uc3QgbG9vc2UgPSBvcHRpb25zLmxvb3NlID8/IHRydWU7XG4gICAgY29uc3QgdmFsaWRhdGUgPSBvcHRpb25zLnZhbGlkYXRlID8/IGZhbHNlO1xuICAgIGNvbnN0IGFsbFN1Ym1vZHVsZXMgPSBvcHRpb25zLmFsbFN1Ym1vZHVsZXMgPz8gZmFsc2U7XG5cblxuICAgIC8vIEdldCB0aGUgVFMgYXNzZW1ibHkgZmlyc3QgdG8gY2hlY2sgd2hhdCBsYW5ndWFnZXMgYXJlIHN1cHBvcnRlZCBiZWZvcmUgY2FsbGluZyByb3NldHRhXG4gICAgY29uc3QgdHNBc3NlbWJseSA9IGF3YWl0IHRoaXMuY3JlYXRlQXNzZW1ibHkodW5kZWZpbmVkLCB7IGxvb3NlLCB2YWxpZGF0ZSB9KTtcbiAgICBjb25zdCBpc1N1cHBvcnRlZCA9IGxhbmd1YWdlID09PSBMYW5ndWFnZS5UWVBFU0NSSVBUIHx8IGxhbmd1YWdlLmlzVmFsaWRDb25maWd1cmF0aW9uKHRzQXNzZW1ibHk/LnRhcmdldHM/LltsYW5ndWFnZS50YXJnZXROYW1lXSk7XG4gICAgdGhpcy5hc3NlbWJseUZxbiA9IGAke3RzQXNzZW1ibHkubmFtZX1AJHt0c0Fzc2VtYmx5LnZlcnNpb259YDtcblxuICAgIGlmICghaXNTdXBwb3J0ZWQpIHtcbiAgICAgIHRocm93IG5ldyBMYW5ndWFnZU5vdFN1cHBvcnRlZEVycm9yKGBMYWd1YWdlICR7bGFuZ3VhZ2V9IGlzIG5vdCBzdXBwb3J0ZWQgZm9yIHBhY2thZ2UgJHt0aGlzLmFzc2VtYmx5RnFufWApO1xuICAgIH1cblxuICAgIGxldCBzdWJtb2R1bGVTdHIgPSBvcHRpb25zLnN1Ym1vZHVsZTtcblxuICAgIGlmIChhbGxTdWJtb2R1bGVzICYmIHN1Ym1vZHVsZVN0cikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY2FsbCB0b0pzb24gd2l0aCBhbGxTdWJtb2R1bGVzIGFuZCBhIHNwZWNpZmljIHN1Ym1vZHVsZSBib3RoIHNlbGVjdGVkLicpO1xuICAgIH1cblxuICAgIGNvbnN0IHsgYXNzZW1ibHksIHRyYW5zcGlsZSB9ID0gYXdhaXQgdGhpcy5sYW5ndWFnZVNwZWNpZmljKGxhbmd1YWdlLCB7IGxvb3NlLCB2YWxpZGF0ZSB9KTtcbiAgICBjb25zdCB0YXJnZXRzID0gYXNzZW1ibHkudGFyZ2V0cztcblxuICAgIGlmICghdGFyZ2V0cykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBBc3NlbWJseSAke3RoaXMuYXNzZW1ibHlGcW59IGRvZXMgbm90IGhhdmUgYW55IHRhcmdldHMgZGVmaW5lZGApO1xuICAgIH1cblxuICAgIGNvbnN0IHN1Ym1vZHVsZSA9IHN1Ym1vZHVsZVN0ciA/IHRoaXMuZmluZFN1Ym1vZHVsZShhc3NlbWJseSwgc3VibW9kdWxlU3RyKSA6IHVuZGVmaW5lZDtcblxuICAgIGxldCByZWFkbWU6IE1hcmtkb3duRG9jdW1lbnQgfCB1bmRlZmluZWQ7XG4gICAgaWYgKG9wdGlvbnM/LnJlYWRtZSA/PyBmYWxzZSkge1xuICAgICAgcmVhZG1lID0gbmV3IFJlYWRtZSh0cmFuc3BpbGUsIGFzc2VtYmx5LCBzdWJtb2R1bGUpLnJlbmRlcigpO1xuICAgIH1cblxuICAgIGxldCBhcGlSZWZlcmVuY2U6IEFwaVJlZmVyZW5jZSB8IHVuZGVmaW5lZDtcbiAgICBpZiAob3B0aW9ucz8uYXBpUmVmZXJlbmNlID8/IHRydWUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGFwaVJlZmVyZW5jZSA9IG5ldyBBcGlSZWZlcmVuY2UodHJhbnNwaWxlLCBhc3NlbWJseSwgc3VibW9kdWxlLCBhbGxTdWJtb2R1bGVzKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmICghKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbWF5YmVDb3JydXB0ZWRBc3NlbWJseUVycm9yKGVycm9yKSA/PyBlcnJvcjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBjb250ZW50czogU2NoZW1hID0ge1xuICAgICAgdmVyc2lvbjogQ1VSUkVOVF9TQ0hFTUFfVkVSU0lPTixcbiAgICAgIGxhbmd1YWdlOiBsYW5ndWFnZS50b1N0cmluZygpLFxuICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgcGFja2FnZU5hbWU6IGFzc2VtYmx5Lm5hbWUsXG4gICAgICAgIHBhY2thZ2VWZXJzaW9uOiBhc3NlbWJseS52ZXJzaW9uLFxuICAgICAgICBzdWJtb2R1bGU6IHN1Ym1vZHVsZVBhdGgoc3VibW9kdWxlKSxcbiAgICAgIH0sXG4gICAgICByZWFkbWU6IHJlYWRtZT8ucmVuZGVyKCksXG4gICAgICBhcGlSZWZlcmVuY2U6IGFwaVJlZmVyZW5jZT8udG9Kc29uKCksXG4gICAgfTtcblxuICAgIHJldHVybiBuZXcgSnNvbihjb250ZW50cyk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgdG9NYXJrZG93bihvcHRpb25zOiBNYXJrZG93blJlbmRlck9wdGlvbnMpOiBQcm9taXNlPE1hcmtkb3duRG9jdW1lbnQ+IHtcbiAgICBjb25zdCBqc29uID0gKGF3YWl0IHRoaXMudG9Kc29uKG9wdGlvbnMpKS5jb250ZW50O1xuICAgIHJldHVybiBNYXJrZG93blJlbmRlcmVyLmZyb21TY2hlbWEoanNvbiwge1xuICAgICAgYW5jaG9yRm9ybWF0dGVyOiBvcHRpb25zLmFuY2hvckZvcm1hdHRlcixcbiAgICAgIGxpbmtGb3JtYXR0ZXI6IG9wdGlvbnMubGlua0Zvcm1hdHRlcixcbiAgICAgIHR5cGVGb3JtYXR0ZXI6IG9wdGlvbnMudHlwZUZvcm1hdHRlcixcbiAgICAgIGhlYWRlcjogb3B0aW9ucy5oZWFkZXIsXG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIGFkZENsZWFudXBEaXJlY3RvcnkoZGlyZWN0b3J5OiBzdHJpbmcpIHtcbiAgICB0aGlzLmNsZWFudXBEaXJlY3Rvcmllcy5hZGQoZGlyZWN0b3J5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGFueSBpbnRlcm5hbCB3b3JraW5nIGRpcmVjdG9yaWVzLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIGNsZWFudXAoKSB7XG4gICAgZm9yIChjb25zdCBkaXIgb2YgWy4uLnRoaXMuY2xlYW51cERpcmVjdG9yaWVzXSkge1xuICAgICAgYXdhaXQgZnMucmVtb3ZlKGRpcik7XG4gICAgICB0aGlzLmNsZWFudXBEaXJlY3Rvcmllcy5kZWxldGUoZGlyKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGxhbmd1YWdlU3BlY2lmaWMoXG4gICAgbGFuZzogTGFuZ3VhZ2UsXG4gICAgb3B0aW9uczogUmVxdWlyZWQ8VHJhbnNsaXRlcmF0aW9uT3B0aW9ucz4sXG4gICk6IFByb21pc2U8eyBhc3NlbWJseTogcmVmbGVjdC5Bc3NlbWJseTsgdHJhbnNwaWxlOiBUcmFuc3BpbGV9PiB7XG4gICAgY29uc3QgeyByb3NldHRhVGFyZ2V0LCB0cmFuc3BpbGUgfSA9IExBTkdVQUdFX1NQRUNJRklDW2xhbmcudG9TdHJpbmcoKV07XG4gICAgcmV0dXJuIHsgYXNzZW1ibHk6IGF3YWl0IHRoaXMuY3JlYXRlQXNzZW1ibHkocm9zZXR0YVRhcmdldCwgb3B0aW9ucyksIHRyYW5zcGlsZSB9O1xuICB9XG5cbiAgLyoqXG4gICAqIExvb2t1cCBhIHN1Ym1vZHVsZSBieSBhIHN1Ym1vZHVsZSBuYW1lLlxuICAgKlxuICAgKiBUaGUgY29udHJhY3Qgb2YgdGhpcyBmdW5jdGlvbiBpcyBoaXN0b3JpY2FsbHkgcXVpdGUgY29uZnVzZWQ6IHRoZSBzdWJtb2R1bGVcbiAgICogbmFtZSBjYW4gYmUgZWl0aGVyIGFuIEZRTiAoYGFzbS5zdWIxLnN1YjJgKSBvciBqdXN0IGEgc3VibW9kdWxlIG5hbWVcbiAgICogKGBzdWIxYCBvciBgc3ViMS5zdWIyYCkuXG4gICAqXG4gICAqIFRoaXMgaXMgc2xpZ3RobHkgY29tcGxpY2F0ZWQgYnkgYW1iaWd1aXR5OiBgYXNtLmFzbS5wYWNrYWdlYCBhbmRcbiAgICogYGFzbS5wYWNrYWdlYCBjYW4gYm90aCBleGlzdCwgYW5kIHdoaWNoIG9uZSBkbyB5b3UgbWVhbiB3aGVuIHlvdSBzYXlcbiAgICogYGFzbS5wYWNrYWdlYD9cbiAgICpcbiAgICogV2UgcHJlZmVyIGFuIEZRTiBtYXRjaCBpZiBwb3NzaWJsZSAoYGFzbS5zdWIxLnN1YjJgKSwgYnV0IHdpbGwgYWNjZXB0IGFcbiAgICogcm9vdC1yZWxhdGl2ZSBzdWJtb2R1bGUgbmFtZSBhcyB3ZWxsIChgc3ViMS5zdWIyYCkuXG4gICAqL1xuICBwcml2YXRlIGZpbmRTdWJtb2R1bGUoYXNzZW1ibHk6IHJlZmxlY3QuQXNzZW1ibHksIHN1Ym1vZHVsZTogc3RyaW5nKTogcmVmbGVjdC5TdWJtb2R1bGUge1xuICAgIGNvbnN0IGZxblN1YnMgPSBhc3NlbWJseS5hbGxTdWJtb2R1bGVzLmZpbHRlcihcbiAgICAgIChzKSA9PiBzLmZxbiA9PT0gc3VibW9kdWxlLFxuICAgICk7XG4gICAgaWYgKGZxblN1YnMubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gZnFuU3Vic1swXTtcbiAgICB9XG5cbiAgICAvLyBGYWxsYmFjazogYXNzZW1ibHktcmVsYXRpdmUgbmFtZVxuICAgIGNvbnN0IHJlbFN1YnMgPSBhc3NlbWJseS5hbGxTdWJtb2R1bGVzLmZpbHRlcihcbiAgICAgIChzKSA9PiBzLmZxbiA9PT0gYCR7YXNzZW1ibHkubmFtZX0uJHtzdWJtb2R1bGV9YCxcbiAgICApO1xuICAgIGlmIChyZWxTdWJzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgY29uc29sZS5lcnJvcihgW1dBUk5JTkddIGZpbmRTdWJtb2R1bGUoKSBpcyBiZWluZyBjYWxsZWQgd2l0aCBhIHJlbGF0aXZlIHN1Ym1vZHVsZSBuYW1lOiAnJHtzdWJtb2R1bGV9Jy4gUHJlZmVyIHRoZSBhYnNvbHV0ZSBuYW1lOiAnJHthc3NlbWJseS5uYW1lfS4ke3N1Ym1vZHVsZX0nYCk7XG4gICAgICByZXR1cm4gcmVsU3Vic1swXTtcbiAgICB9XG5cbiAgICBpZiAoZnFuU3Vicy5sZW5ndGggKyByZWxTdWJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBTdWJtb2R1bGUgJHtzdWJtb2R1bGV9IG5vdCBmb3VuZCBpbiBhc3NlbWJseSAke2Fzc2VtYmx5Lm5hbWV9QCR7YXNzZW1ibHkudmVyc2lvbn0gKG5laXRoZXIgYXMgJyR7c3VibW9kdWxlfScgbm9yIGFzICcke2Fzc2VtYmx5Lm5hbWV9LiR7c3VibW9kdWxlfSlgKTtcbiAgICB9XG5cbiAgICAvLyBBbG1vc3QgaW1wb3NzaWJsZSB0aGF0IHRoaXMgd291bGQgYmUgdHJ1ZVxuICAgIGlmIChmcW5TdWJzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRm91bmQgbXVsdGlwbGUgc3VibW9kdWxlcyB3aXRoIEZRTjogJHtzdWJtb2R1bGV9IGluIGFzc2VtYmx5ICR7YXNzZW1ibHkubmFtZX1AJHthc3NlbWJseS52ZXJzaW9ufWApO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYEZvdW5kIG11bHRpcGxlIHN1Ym1vZHVsZXMgd2l0aCByZWxhdGl2ZSBuYW1lOiAke3N1Ym1vZHVsZX0gaW4gYXNzZW1ibHkgJHthc3NlbWJseS5uYW1lfUAke2Fzc2VtYmx5LnZlcnNpb259YCk7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGNyZWF0ZUFzc2VtYmx5KFxuICAgIGxhbmd1YWdlOiBUYXJnZXRMYW5ndWFnZSB8IHVuZGVmaW5lZCxcbiAgICBvcHRpb25zOiBSZXF1aXJlZDxUcmFuc2xpdGVyYXRpb25PcHRpb25zPixcbiAgKTogUHJvbWlzZTxyZWZsZWN0LkFzc2VtYmx5PiB7XG5cbiAgICBjb25zdCBjYWNoZUtleSA9IGBsYW5nOiR7bGFuZ3VhZ2UgPz8gJ3RzJ30ubG9vc2U6JHtvcHRpb25zLmxvb3NlfS52YWxpZGF0ZToke29wdGlvbnMudmFsaWRhdGV9YDtcbiAgICBjb25zdCBjYWNoZWQgPSB0aGlzLmFzc2VtYmxpZXNDYWNoZS5nZXQoY2FjaGVLZXkpO1xuICAgIGlmIChjYWNoZWQpIHtcbiAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgfVxuXG4gICAgY29uc3QgY3JlYXRlZCA9IGF3YWl0IHdpdGhUZW1wRGlyKGFzeW5jICh3b3JrZGlyOiBzdHJpbmcpID0+IHtcblxuICAgICAgLy8gYWx3YXlzIGJldHRlciBub3QgdG8gcG9sbHV0ZSBhbiBleHRlcm5hbGx5IHByb3ZpZGVkIGRpcmVjdG9yeVxuICAgICAgYXdhaXQgZnMuY29weSh0aGlzLmFzc2VtYmxpZXNEaXIsIHdvcmtkaXIsIHtcbiAgICAgICAgLy8gRW5zdXJlIHdlIGRvbid0IHRyeSB0byBjb3B5IHNvY2tldCBmaWxlcywgYXMgdGhleSBjYW4gYmUgZm91bmQgdW5kZXIgLmdpdCB3aGVuXG4gICAgICAgIC8vIGNvcmUuZnNtb25pdG9yIGlzIGVuYWJsZWQuXG4gICAgICAgIGZpbHRlcjogYXN5bmMgKHNyYykgPT4ge1xuICAgICAgICAgIGNvbnN0IHN0YXQgPSBhd2FpdCBmcy5zdGF0KHNyYyk7XG4gICAgICAgICAgcmV0dXJuIHN0YXQuaXNGaWxlKCkgfHwgc3RhdC5pc0RpcmVjdG9yeSgpO1xuICAgICAgICB9LFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHRzID0gbmV3IHJlZmxlY3QuVHlwZVN5c3RlbSgpO1xuXG4gICAgICAvLyBhc3NlbWJsaWVzRGlyIG1pZ2h0IGluY2x1ZGUgYmFja3NsYXNoZXMgb24gV2luZG93cy5cbiAgICAgIC8vIFRoZSBnbG9iIHBhdHRlcm4gbXVzdCBvbmx5IHVzZWQgZm9yd2FyZCBzbGFzaGVzLCBzbyB3ZSBwYXNzIHRoZSBhc3NlbWJsaWVzRGlyIGFzIENXRCB3aGljaCBkb2VzIG5vdCBoYXZlIHRoaXMgcmVzdHJpY3Rpb25cbiAgICAgIGNvbnN0IGFzc2VtYmxpZXMgPSBhd2FpdCBnbG9iLnByb21pc2UoYCoqLyR7U1BFQ19GSUxFX05BTUV9YCwge1xuICAgICAgICBjd2Q6IHBhdGgubm9ybWFsaXplKHRoaXMuYXNzZW1ibGllc0RpciksXG4gICAgICAgIGFic29sdXRlOiB0cnVlLFxuICAgICAgfSk7XG4gICAgICBmb3IgKGxldCBkb3RKc2lpIG9mIGFzc2VtYmxpZXMpIHtcbiAgICAgICAgLy8gd2Ugb25seSB0cmFuc2xpdGVyYXRlIHRoZSB0b3AgbGV2ZWwgYXNzZW1ibHkgYW5kIG5vdCB0aGUgZW50aXJlIHR5cGUtc3lzdGVtLlxuICAgICAgICAvLyBub3RlIHRoYXQgdGhlIG9ubHkgcmVhc29uIHRvIHRyYW5zbGF0ZSBkZXBlbmRhbnQgYXNzZW1ibGllcyBpcyB0byBzaG93IGNvZGUgZXhhbXBsZXNcbiAgICAgICAgLy8gZm9yIGV4cGFuZGVkIHB5dGhvbiBhcmd1bWVudHMgLSB3aGljaCB3ZSBkb24ndCB0byByaWdodCBub3cgYW55d2F5LlxuICAgICAgICAvLyB3ZSBkb24ndCB3YW50IHRvIG1ha2UgYW55IGFzc3VtcHRpb24gb2YgdGhlIGRpcmVjdG9yeSBzdHJ1Y3R1cmUsIHNvIHRoaXMgaXMgdGhlIG1vc3RcbiAgICAgICAgLy8gcm9idXN0IHdheSB0byBkZXRlY3QgdGhlIHJvb3QgYXNzZW1ibHkuXG4gICAgICAgIGNvbnN0IHNwZWMgPSBsb2FkQXNzZW1ibHlGcm9tRmlsZShkb3RKc2lpLCBmYWxzZSk7IC8vIGRvbid0IHZhbGlkYXRlIHdlIG9ubHkgbmVlZCB0aGlzIGZvciB0aGUgc3BlYyBuYW1lXG4gICAgICAgIGlmIChsYW5ndWFnZSAmJiBzcGVjLm5hbWUgPT09IHRoaXMuYXNzZW1ibHlOYW1lKSB7XG4gICAgICAgICAgY29uc3QgcGFja2FnZURpciA9IHBhdGguZGlybmFtZShkb3RKc2lpKTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgdHJhbnNsaXRlcmF0ZUFzc2VtYmx5KFtwYWNrYWdlRGlyXSwgW2xhbmd1YWdlXSxcbiAgICAgICAgICAgICAgeyBsb29zZTogb3B0aW9ucy5sb29zZSwgdW5rbm93blNuaXBwZXRzOiBVbmtub3duU25pcHBldE1vZGUuRkFJTCwgb3V0ZGlyOiB3b3JrZGlyIH0pO1xuICAgICAgICAgIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFRyYW5zbGl0ZXJhdGlvbkVycm9yKGBDb3VsZCBub3QgdHJhbnNsaXRlcmF0ZSBzbmlwcGV0cyBpbiAnJHt0aGlzLmFzc2VtYmx5RnFufScgdG8gJHtsYW5ndWFnZX06ICR7ZS5tZXNzYWdlfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkb3RKc2lpID0gcGF0aC5qb2luKHdvcmtkaXIsIGAke1NQRUNfRklMRV9OQU1FfS4ke2xhbmd1YWdlfWApO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IGxvYWRBc3NlbWJseShkb3RKc2lpLCB0cywgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHMuZmluZEFzc2VtYmx5KHRoaXMuYXNzZW1ibHlOYW1lKTtcbiAgICB9KTtcblxuICAgIHRoaXMuYXNzZW1ibGllc0NhY2hlLnNldChjYWNoZUtleSwgY3JlYXRlZCk7XG4gICAgcmV0dXJuIGNyZWF0ZWQ7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IExBTkdVQUdFX1NQRUNJRklDID0ge1xuICBbTGFuZ3VhZ2UuUFlUSE9OLnRvU3RyaW5nKCldOiB7XG4gICAgdHJhbnNwaWxlOiBuZXcgUHl0aG9uVHJhbnNwaWxlKCksXG4gICAgcm9zZXR0YVRhcmdldDogVGFyZ2V0TGFuZ3VhZ2UuUFlUSE9OLFxuICB9LFxuICBbTGFuZ3VhZ2UuVFlQRVNDUklQVC50b1N0cmluZygpXToge1xuICAgIHRyYW5zcGlsZTogbmV3IFR5cGVTY3JpcHRUcmFuc3BpbGUoKSxcbiAgICByb3NldHRhVGFyZ2V0OiB1bmRlZmluZWQsIC8vIG5vIHRyYW5zcGlsYXRpb24gbmVlZGVkXG4gIH0sXG4gIFtMYW5ndWFnZS5KQVZBLnRvU3RyaW5nKCldOiB7XG4gICAgdHJhbnNwaWxlOiBuZXcgSmF2YVRyYW5zcGlsZSgpLFxuICAgIHJvc2V0dGFUYXJnZXQ6IFRhcmdldExhbmd1YWdlLkpBVkEsXG4gIH0sXG4gIFtMYW5ndWFnZS5DU0hBUlAudG9TdHJpbmcoKV06IHtcbiAgICB0cmFuc3BpbGU6IG5ldyBDU2hhcnBUcmFuc3BpbGUoKSxcbiAgICByb3NldHRhVGFyZ2V0OiBUYXJnZXRMYW5ndWFnZS5DU0hBUlAsXG4gIH0sXG4gIFtMYW5ndWFnZS5HTy50b1N0cmluZygpXToge1xuICAgIHRyYW5zcGlsZTogbmV3IEdvVHJhbnNwaWxlKCksXG4gICAgcm9zZXR0YVRhcmdldDogVGFyZ2V0TGFuZ3VhZ2UuR08sXG4gIH0sXG59O1xuXG4vKipcbiAqIExvYWRzIHRoZSBzcGVjaWZpZWQgYXNzZW1ibHkgZG9jdW1lbnQgaW50byB0aGUgcHJvdmlkZWQgdHlwZSBzeXN0ZW0sIGFuZFxuICogcmVjdXJzaXZlbHkgYXR0ZW1wdCB0byBsb2FkIHRoZSBhc3NlbWJseSdzIGRlcGVuZGVuY2llcy5cbiAqXG4gKiBAcGFyYW0gZG90SnNpaSB0aGUgYXNzZW1ibHkgdG8gYmUgbG9hZGVkLlxuICogQHBhcmFtIHRzIHRoZSB0eXBlIHN5c3RlbSBpbiB3aGljaCB0aGUgYXNzZW1ibHkgaXMgdG8gYmUgbG9hZGVkLlxuICogQHBhcmFtIHZhbGlkYXRlIHdoZXRoZXIgYXNzZW1ibGllcyBzaG91bGQgYmUgdmFsaWRhdGVkLlxuICovXG5hc3luYyBmdW5jdGlvbiBsb2FkQXNzZW1ibHkoXG4gIGRvdEpzaWk6IHN0cmluZyxcbiAgdHM6IHJlZmxlY3QuVHlwZVN5c3RlbSxcbiAgeyB2YWxpZGF0ZSB9OiB7IHJlYWRvbmx5IHZhbGlkYXRlPzogYm9vbGVhbiB9ID0ge30sXG4pOiBQcm9taXNlPHJlZmxlY3QuQXNzZW1ibHk+IHtcbiAgY29uc3QgbG9hZGVkID0gYXdhaXQgdHMubG9hZChkb3RKc2lpLCB7IHZhbGlkYXRlIH0pO1xuXG4gIGZvciAoY29uc3QgZGVwIG9mIE9iamVjdC5rZXlzKGxvYWRlZC5zcGVjLmRlcGVuZGVuY2llcyA/PyB7fSkpIHtcbiAgICBpZiAodHMudHJ5RmluZEFzc2VtYmx5KGRlcCkgIT0gbnVsbCkge1xuICAgICAgLy8gZGVwZW5kZW5jeSBhbHJlYWR5IGxvYWRlZC4uLiBtb3ZlIG9uLi4uXG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIC8vIFJlc29sdmUgdGhlIGRlcGVuZGVuY2llcyByZWxhdGl2ZSB0byB0aGUgZGVwZW5kZW50J3MgcGFja2FnZSByb290LlxuICAgICAgY29uc3QgZGVwUGF0aCA9IHJlcXVpcmUucmVzb2x2ZShgJHtkZXB9Ly5qc2lpYCwgeyBwYXRoczogW3BhdGguZGlybmFtZShkb3RKc2lpKV0gfSk7XG4gICAgICBhd2FpdCBsb2FkQXNzZW1ibHkoZGVwUGF0aCwgdHMsIHsgdmFsaWRhdGUgfSk7XG4gICAgfSBjYXRjaCB7XG4gICAgICAvLyBTaWxlbnRseSBpZ25vcmUgYW55IHJlc29sdXRpb24gZXJyb3JzLi4uIFdlJ2xsIGZhaWwgbGF0ZXIgaWYgdGhlIGRlcGVuZGVuY3kgaXNcbiAgICAgIC8vIEFDVFVBTExZIHJlcXVpcmVkLCBidXQgaXQncyBva2F5IHRvIG9taXQgaXQgaWYgbm9uZSBvZiBpdHMgdHlwZXMgYXJlIGFjdHVhbGx5IGV4cG9zZWRcbiAgICAgIC8vIGJ5IHRoZSB0cmFuc2xhdGVkIGFzc2VtYmx5J3Mgb3duIEFQSS5cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxvYWRlZDtcbn1cblxuYXN5bmMgZnVuY3Rpb24gd2l0aFRlbXBEaXI8VD4od29yazogKHdvcmtkaXI6IHN0cmluZykgPT4gUHJvbWlzZTxUPik6IFByb21pc2U8VD4ge1xuICBjb25zdCB3b3JrZGlyID0gYXdhaXQgZnMubWtkdGVtcChwYXRoLmpvaW4ob3MudG1wZGlyKCksIHBhdGguc2VwKSk7XG4gIGNvbnN0IGN3ZCA9IHByb2Nlc3MuY3dkKCk7XG4gIHRyeSB7XG4gICAgcHJvY2Vzcy5jaGRpcih3b3JrZGlyKTtcbiAgICAvLyB3YWl0IGZvciB0aGUgd29yayB0byBiZSBjb21wbGV0ZWQgYmVmb3JlXG4gICAgLy8gd2UgY2xlYW51cCB0aGUgd29yayBlbnZpcm9ubWVudC5cbiAgICByZXR1cm4gYXdhaXQgd29yayh3b3JrZGlyKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBwcm9jZXNzLmNoZGlyKGN3ZCk7XG4gICAgYXdhaXQgZnMucmVtb3ZlKHdvcmtkaXIpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0UGFja2FnZU5hbWUoc3BlYzogc3RyaW5nKSB7XG4gIGNvbnN0IGZpcnN0QXQgPSBzcGVjLmluZGV4T2YoJ0AnKTtcblxuICBpZiAoZmlyc3RBdCA9PT0gMCkge1xuICAgIGNvbnN0IGxhc3RBdCA9IHNwZWMuaW5kZXhPZignQCcsIGZpcnN0QXQgKyAxKTtcbiAgICBpZiAobGFzdEF0ID09PSAtMSkge1xuICAgICAgLy8gQGF3cy1jZGsvYXdzLWVjclxuICAgICAgcmV0dXJuIHNwZWM7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEBhd3MtY2RrL2F3cy1lY3JAMi4wLjBcbiAgICAgIHJldHVybiBzcGVjLnN1YnN0cmluZygwLCBsYXN0QXQpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChmaXJzdEF0ID4gMCkge1xuICAgIC8vIGF3cy1jZGstbGliQDIuMC4wXG4gICAgcmV0dXJuIHNwZWMuc3Vic3RyaW5nKDAsIGZpcnN0QXQpO1xuICB9XG5cbiAgLy8gYXdzLWNkay1saWJcbiAgcmV0dXJuIHNwZWM7XG59XG5cbi8qKlxuICogUmV0dXJuIGEgYENvcnJ1cHRlZEFzc2VtYmx5RXJyb3JgIGlmIHRoZSBlcnJvciBtYXRjaGVzLCB1bmRlZmluZWQgb3RoZXJ3aXNlLlxuICpcbiAqIE5vdGUgdGhhdCBhbiAnbm90IGZvdW5kIGluIGFzc2VtYmx5YCBjYW4gYmUgdGhyb3duIGluIHR3byBjYXNlczpcbiAqXG4gKiAxLiBEaXJlY3QgdXNhZ2Ugb2YgYGFzc2VtYmx5LmZpbmRUeXBlKGZxbilgXG4gKlxuICogICAgSW4gdGhpcyBjYXNlIHRoZSBlcnJvciBjb3VsZCBiZSBjYXVzZWQgYnkgYSB3cm9uZyBGUU4gYmVpbmcgcGFzc2VkIHRvIHRoZSBmdW5jdGlvbi4gVGhpcyBpcyBub3QgY29uc2lkZXJlZFxuICogICAgYSBjb3JydXB0ZWQgYXNzZW1ibHkgc2luY2UgdGhlIGNhbGxlciBtaWdodCBiZSBwYXNzaW5nIGFuIEZRTiBmcm9tIGEgZGlmZmVyZW50IGFzc2VtYmx5LlxuICpcbiAqIDIuIEltcGxpY2l0IHVzYWdlIG9mIGBhc3NlbWJseS5maW5kVHlwZShmcW4pYCBieSBjYWxsaW5nIGAudHlwZWAgKGUuZyBgcGFyYW1ldGVyLnR5cGVgKVxuICpcbiAqICAgIEluIHRoaXMgY2FzZSB0aGUgYXNzZW1ibHkgd2UgbG9vayBpbiBpcyBhbHdheXMgdGhlIHNhbWUgYXNzZW1ibHkgdGhlIHR5cGUgaXRzZWxmIGNvbWVzIGZyb20sIGFuZCBpZiBpdCBkb2Vzbid0IGV4aXN0LFxuICogICAgdGhlbiB0aGUgYXNzZW1ibHkgaXMgY29uc2lkZXJlZCBjb3JydXB0LlxuICovXG5mdW5jdGlvbiBtYXliZUNvcnJ1cHRlZEFzc2VtYmx5RXJyb3IoZXJyb3I6IEVycm9yKTogQ29ycnVwdGVkQXNzZW1ibHlFcnJvciB8IHVuZGVmaW5lZCB7XG5cbiAgY29uc3QgbWF0Y2ggPSBlcnJvci5tZXNzYWdlLm1hdGNoKE5PVF9GT1VORF9JTl9BU1NFTUJMWV9SRUdFWCk7XG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qgc2VhcmNoZWRBc3NlbWJseSA9IG1hdGNoWzJdO1xuICBjb25zdCB0eXBlQXNzZW1ibHkgPSBtYXRjaFsxXTtcblxuICBpZiAoc2VhcmNoZWRBc3NlbWJseSA9PT0gdHlwZUFzc2VtYmx5KSB7XG4gICAgcmV0dXJuIG5ldyBDb3JydXB0ZWRBc3NlbWJseUVycm9yKGVycm9yLm1lc3NhZ2UpO1xuICB9XG4gIHJldHVybjtcbn1cbiJdfQ==